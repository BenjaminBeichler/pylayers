

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.measures.cormoran &mdash; PyLayers</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_issue314.html">Exemple of issue 314</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction_polar.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html">1&nbsp;&nbsp;&nbsp;pylayers.util.project Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.layout">2&nbsp;&nbsp;&nbsp;pylayers.gis.layout Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.selectl">3&nbsp;&nbsp;&nbsp;pylayers.gis.selectl Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.srtm">4&nbsp;&nbsp;&nbsp;pylayers.gis.srtm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.osmparser">5&nbsp;&nbsp;&nbsp;pylayers.gis.osmparser Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.ezone">6&nbsp;&nbsp;&nbsp;pylayers.gis.ezone Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antenna">7&nbsp;&nbsp;&nbsp;pylayers.antprop.antenna Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.aarray">8&nbsp;&nbsp;&nbsp;pylayers.antprop.aarray Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.spharm">9&nbsp;&nbsp;&nbsp;pylayers.antprop.spharm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antssh">10&nbsp;&nbsp;&nbsp;pylayers.antprop.antssh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antvsh">11&nbsp;&nbsp;&nbsp;pylayers.antprop.antvsh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.slab">12&nbsp;&nbsp;&nbsp;pylayers.antprop.slab Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.signature">13&nbsp;&nbsp;&nbsp;pylayers.antprop.signature Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.interactions">14&nbsp;&nbsp;&nbsp;pylayers.antprop.interactions Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffraction">15&nbsp;&nbsp;&nbsp;pylayers.antprop.diffraction Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffRT">16&nbsp;&nbsp;&nbsp;pylayers.antprop.diffRT Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.rays">17&nbsp;&nbsp;&nbsp;pylayers.antprop.rays Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.loss">18&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.channel">19&nbsp;&nbsp;&nbsp;pylayers.antprop.channel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id39">20&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coverage">21&nbsp;&nbsp;&nbsp;pylayers.antprop.coverage Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coeffModel">22&nbsp;&nbsp;&nbsp;pylayers.antprop.coeffModel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.link">23&nbsp;&nbsp;&nbsp;pylayers.simul.link Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit">24&nbsp;&nbsp;&nbsp;pylayers.simul.exploit Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit_simulnet">25&nbsp;&nbsp;&nbsp;pylayers.simul.exploit_simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simulnet">26&nbsp;&nbsp;&nbsp;pylayers.simul.simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simultraj">27&nbsp;&nbsp;&nbsp;pylayers.simul.simultraj Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.exploit.simnet">28&nbsp;&nbsp;&nbsp;pylayers.exploit.simnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesuwb">29&nbsp;&nbsp;&nbsp;pylayers.measures.mesuwb Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesmimo">30&nbsp;&nbsp;&nbsp;pylayers.measures.mesmimo Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.cormoran">31&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.vna.E5072A">32&nbsp;&nbsp;&nbsp;pylayers.measures.vna.E5072A Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.parker.smparker">33&nbsp;&nbsp;&nbsp;pylayers.measures.parker.smparker Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.bsignal">34&nbsp;&nbsp;&nbsp;pylayers.signal.bsignal Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.standard">35&nbsp;&nbsp;&nbsp;pylayers.signal.standard Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.device">36&nbsp;&nbsp;&nbsp;pylayers.signal.device Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.DF">37&nbsp;&nbsp;&nbsp;pylayers.signal.DF Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.waveform">38&nbsp;&nbsp;&nbsp;pylayers.signal.waveform Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.agent">39&nbsp;&nbsp;&nbsp;pylayers.mobility.agent Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.ban.body">40&nbsp;&nbsp;&nbsp;pylayers.mobility.ban.body Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id138">41&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pylayers.measures.cormoran</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.measures.cormoran</h1><div class="highlight"><pre>
<span></span># -*- coding:Utf-8 -*-
&quot;&quot;&quot;

This module handles CORMORAN measurement data

CorSer Class
============

.. autoclass:: CorSer
    :members:

Notes
-----

Useful members

distdf : distance between radio nodes (122 columns)
devdf  : device data frame

&quot;&quot;&quot;
#import mayavi.mlab as mlabc
import os
import pdb
import sys
import pandas as pd
import numpy as np
import numpy.ma as ma
import scipy.io as io
from pylayers.util.project import *
from pylayers.util.pyutil import *
from pylayers.mobility.ban.body import *
from pylayers.gis.layout import *
import pylayers.antprop.antenna as antenna

from matplotlib.widgets import Slider, CheckButtons, Button, Cursor
from pylayers.signal.DF import *

# from moviepy.editor import *
from skimage import img_as_ubyte
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable

import pickle
try:
    from tvtk.api import tvtk
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi import mlab
except:
    print(&#39;Layout:Mayavi is not installed&#39;)
#Those lines handle incompatibility between mayavi and VTK
#and redirect noisy warning message into a log file
# import vtk
# output=vtk.vtkFileOutputWindow()
# output.SetFileName(&quot;mayaviwarninglog.tmp&quot;)
# vtk.vtkOutputWindow().SetInstance(output)


<div class="viewcode-block" id="cor_log"><a class="viewcode-back" href="../../../api/pylayers.measures.cormoran.cor_log.html#pylayers.measures.cormoran.cor_log">[docs]</a>def cor_log(short=True):
    &quot;&quot;&quot; display cormoran measurement campaign logfile

    Parameters
    ----------

    short : boolean
        enable short version

    Examples
    --------

    &gt;&gt;&gt; from pylayers.measures.cormoran import *
    &gt;&gt;&gt; cor_log(short=True)

    &quot;&quot;&quot;

    filelog = os.path.join(os.environ[&#39;CORMORAN&#39;],&#39;RAW&#39;,&#39;Doc&#39;,&#39;MeasurementLog.csv&#39;)
    log = pd.read_csv(filelog)
    if short :
        log[&#39;day&#39;] =  [x.split(&#39;/&#39;)[0] for x in log[&#39;Date&#39;].values]
        log[&#39;serie&#39;]=log[&#39;Meas Serie&#39;]
        return log[[&#39;serie&#39;,&#39;day&#39;,&#39;Subject&#39;,&#39;techno&#39;,&#39;Short Notes&#39;]]
    else:
        return log</div>

<div class="viewcode-block" id="time2npa"><a class="viewcode-back" href="../../../api/pylayers.measures.cormoran.time2npa.html#pylayers.measures.cormoran.time2npa">[docs]</a>def time2npa(lt):
    &quot;&quot;&quot; convert pd.datetime.time to numpy array

    Parameters
    ----------

    lt : pd.datetime.time

    Returns
    -------

    ta : numpy array
        time in seconds

    &quot;&quot;&quot;
    ta = (lt.microsecond*1e-6+
    lt.second+
    lt.minute*60+
    lt.hour*3600)
    return(ta)</div>

<div class="viewcode-block" id="CorSer"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer">[docs]</a>class CorSer(PyLayers):
    &quot;&quot;&quot; Handle CORMORAN measurement data

    Hikob data handling from CORMORAN measurement campaign

    11/06/2014
        single subject (Bernard and Nicolas)

    12/06/2014
        several subject (Jihad, Eric , Nicolas)
    &quot;&quot;&quot;

    def __init__(self,serie=6,day=11,source=&#39;CITI&#39;,layout=False):
        &quot;&quot;&quot;
        Parameters
        ----------

        serie : int
        day : int
        source : string

        Notes
        -----

        The environment variable CORMORAN is indicating the location of data directory

        &quot;&quot;&quot;
        assert (day in [11,12]),&quot;wrong day&quot;

        try:
            self.rootdir = os.environ[&#39;CORMORAN&#39;]
        except:
            raise NameError(&#39;Please add a CORMORAN environement variable \
                            pointing to the data&#39;)

        # infos
        self.serie = serie
        self.day = day
        self.loadlog()

        if day == 11:
            if serie in [7,8]:
                raise &#39;Serie &#39;+str(serie) + &#39; has no hkb data and will not be loaded&#39;
        if day ==12:
            if serie in [17,18,19,20]:
                raise  AttributeError(&#39;Serie &#39;+str(serie) + \
                                     &#39; has no hkb data and will not be loaded&#39;)
        #Measures
        if day==11:
            self.stcr = [1,2,3,4,10,11,12,32,33,34,35,9,17,18,19,20,25,26]
            self.shkb = [5,6,13,14,15,16,21,22,23,24,27,28,29,30,31,32,33,34,35]
            self.sbs  = [5,6,7,8,13,14,15,16,21,22,23,24,27,28,29,30,31,32,33,34,35]
            self.mocap = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35]
            self.mocapinterf=[]
        if day==12:
            self.stcr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
            self.shkb = [9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]
            self.sbs  = [9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]
            self.mocap =[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]
            self.mocapinterf = [5,6,7,8,13,14,15,16,21,22,23,24,]

        self.typ=&#39;&#39;

        # HIKOB
        if serie in self.shkb:
            self._loadhkb(serie=serie,day=day,source=source)

        # IR-UWB  TCR
        if serie in self.stcr:
            self._loadTCR(serie=serie,day=day)

        # BeSpoon
        if serie in self.sbs:
            self._loadBS(serie=serie,day=day)

        # set filename
        if self.typ==&#39;FULL&#39;:
            self._filename = &#39;Sc&#39; + self.scenario + &#39;_S&#39; + str(self.serie) + &#39;_R&#39; + str(self.run) + &#39;_&#39; + self.typ.capitalize()
        else:
            self._filename = &#39;Sc&#39; + self.scenario + &#39;_S&#39; + str(self.serie) + &#39;_R&#39; + str(self.run) + &#39;_&#39; + self.typ


        #Layout
        if layout:
            self.L= Layout(&#39;MOCAP-small2.lay&#39;)


        # Load Infrastructure Nodes
        self._loadinfranodes()

        # Load cameras
        self._loadcam()
        #BODY &amp; interferers
        self.subject = str(self.log[&#39;Subject&#39;].values[0].replace(&#39;jihad&#39;,&#39;Jihad&#39;)).split(&#39; &#39;)
        #filter typos in  self.subject
        self.subject = [ x for x in self.subject if len(x)!=0 ] 
        if &#39;Jihad&#39; in self.subject :
            uj = self.subject.index(&#39;Jihad&#39;)
            self.subject[uj]=&#39;Jihan&#39;

        if serie in self.mocap :
            # load bodies from mocap file
            self._loadbody(serie=serie,day=day)
            self._distancematrix()
            self._computedevpdf()
            if isinstance(self.B,dict):
                for b in self.B:
                    if hasattr(self,&#39;L&#39;):
                        self.B[b].traj.Lfilename=copy.copy(self.L._filename)
                    else:
                        self.B[b].traj.Lfilename=&#39;notloaded&#39;

            else :
                self.B.traj.Lfilename=copy.copy(self.L._filename)

        # reference time is tmocap
        self.tmocap = self.B[self.subject[0]].time

        # load offset dict
        self.offset= self._load_offset_dict()

        ########################
        #realign Radio on mocap
        ########################
        # 1 - Resample radio time =&gt; mocap time
        # 2 - (if available) apply offset

        if (&#39;BS&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
            print( &#39;\nBS data frame index: &#39;,)
            self._align_on_devdf(typ=&#39;BS&#39;)
            print( &#39;Align on mocap OK...&#39;,)
            try:
                self._apply_offset(&#39;BS&#39;)
                print (&#39;time-offset applied OK&#39;)
            except:
                print (&#39;WARNING time-offset NOT applied&#39;)
                print (&#39;No BS offset not yet set =&gt; use self.offset_setter &#39;)

        if (&#39;TCR&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
            print (&#39;\nTCR data frame index:&#39;, )
            self._align_on_devdf(typ=&#39;TCR&#39;)
            print (&#39;Align on mocap OK...&#39;,)
            try:
                self._apply_offset(&#39;TCR&#39;)
                print (&#39;time-offset applied OK&#39;)
            except:
                print (&#39;WARNING time-offset NOT applied&#39;)
                print (&#39;No TCR offset not yet set =&gt; use self.offset_setter&#39;)


        if (&#39;HK&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
            print (&#39;\nHKB data frame index:&#39;,)
            self._align_on_devdf(typ=&#39;HKB&#39;)
            print (&#39;Align on mocap OK...&#39;,)
            try:
                # self._apply_offset(&#39;HKB&#39;)
                print (&#39;time-offset applied OK&#39;)
            except:
                print (&#39;WARNING time-offset NOT applied&#39;)
                print (&#39;No HKB offset not yet set =&gt; use self.offset_setter&#39;)

        print (&#39;\nCreate distance Dataframe...&#39;,)
        self._computedistdf()
        print (&#39;OK&#39;,)

    def __repr__(self):
        st = &#39;&#39;
        st = st + &#39;filename : &#39; + self._filename + &#39;\n&#39;
        st = st + &#39;filewear : &#39; + self.filewear + &#39;\n&#39;
        st = st + &#39;filebody : &#39; + self.filebody + &#39;\n&#39;
        st = st + &#39;filemocap : &#39; + self.filemocap + &#39;\n&#39;
        st = st + &#39;Day : &#39;+ str(self.day)+&#39;/06/2014&#39;+&#39;\n&#39;
        st = st + &#39;Serie : &#39;+ str(self.serie)+&#39;\n&#39;
        st = st + &#39;Scenario : &#39;+str(self.scenario)+&#39;\n&#39;
        st = st + &#39;Run : &#39;+ str(self.run)+&#39;\n&#39;
        st = st + &#39;Type : &#39;+ str(self.typ)+&#39;\n&#39;
        st = st + &#39;Original Video Id : &#39;+ str(self.video)+&#39;\n&#39;
        st = st + &#39;Subject(s) : &#39;

        for k in self.subject:
            st = st + k + &#39; &#39;
        st = st + &#39;\n\n&#39;

        st = st+&#39;Body available: &#39; + str(&#39;B&#39; in dir(self)) + &#39;\n\n&#39;

        try :
            st = st+&#39;BeSPoon : &#39;+self._fileBS+&#39;\n&#39;
        except:
            pass
        try :
            st = st+&#39;HIKOB : &#39;+self._filehkb+&#39;\n&#39;
        except:
            pass
        try :
            st = st+&#39;TCR : &#39;+self._fileTCR+&#39;\n&#39;
        except:
            pass

        st = st + &#39;----------------------\n\n&#39;
        for k in self.log.columns:
            st = st + k + &#39; :&#39; + str(self.log[k].values)+&#39;\n&#39;

        return(st)


    # @property
    # def dev(self):
    #     &quot;&quot;&quot; display device techno, id , id on body, body owner,...
    #     &quot;&quot;&quot;
        
    #     title = &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(&#39;Name in Dataframe&#39;, &#39;Real Id&#39;, &#39;Body Id&#39;, &#39;Subject&#39;)
    #     print title + &#39;\n&#39; + &#39;-&#39;*len(title) 
    #     if (&#39;HK&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
    #         hkbkeys = self.idHKB.keys()
    #         hkbkeys.sort()
    #         for d in hkbkeys:
    #             dev = self.devmapper(self.idHKB[d],&#39;HKB&#39;)
    #             print &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3])
    #     if (&#39;TCR&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
    #         tcrkeys = self.idTCR.keys()
    #         tcrkeys.sort()
    #         for d in tcrkeys:
    #             dev = self.devmapper(self.idTCR[d],&#39;TCR&#39;)
    #             print &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3])

    @property
    def dev(self):
        &quot;&quot;&quot; display device techno, id , id on body, body owner,...
        &quot;&quot;&quot;

        title = &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(&#39;Name in Dataframe&#39;, &#39;Real Id&#39;, &#39;Body Id&#39;, &#39;Subject&#39;)
        print( title + &#39;\n&#39; + &#39;=&#39;*len(title))
        # access points HKB
        for d in self.din:
            if (&#39;HK&#39; in d) :
                dev = self.devmapper(d,&#39;HKB&#39;)
                print(&#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
        if &#39;FULL&#39; in self.typ:
                print (&#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;))
        for d in self.din:
            if (&#39;BS&#39; in d) :
                dev = self.devmapper(d,&#39;BS&#39;)
                print (&#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
        if &#39;FULL&#39; in self.typ:
                print (&#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;))

        # access points TCR
        for d in self.din:
            if (&#39;TCR&#39; in d)  :
                dev = self.devmapper(d,&#39;TCR&#39;)
                print (&#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
        print (&#39;{0:66}&#39;.format(&#39;-&#39;*len(title) ))
        #device per RAT per body
        for b in self.B:
            if b not in self.interf:
                #HKB per body
                for d in self.B[b].dev.keys():

                    if (&#39;HK&#39; in d):
                        dev = self.devmapper(d,&#39;HKB&#39;)
                        print( &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
                #bespoon
                if (&#39;FULL&#39; in self.typ) or (&#39;HKB&#39; in self.typ):
                    print( &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;))
                for d in self.B[b].dev.keys():
                    if (&#39;BS&#39; in d):
                        dev = self.devmapper(d,&#39;BS&#39;)
                        print( &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
                # print &#39;{0:66}&#39;.format(&#39;-&#39;*len(title) )
                #TCR per body
                if &#39;FULL&#39; in self.typ:
                    print (&#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;))
                for d in self.B[b].dev.keys():
                    if (&#39;TCR&#39; in d):
                        dev = self.devmapper(d,&#39;TCR&#39;)
                        print (&#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
                print (&#39;{0:66}&#39;.format(&#39;-&#39;*len(title) ))

    @property
    def ant(self):
        &quot;&quot;&quot; display device techno, id , id on body, body owner,...
        &quot;&quot;&quot;

        title = &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(&#39;Name in Dataframe&#39;, &#39;Real Id&#39;, &#39;Body Id&#39;, &#39;Subject&#39;)
        print (title + &#39;\n&#39; + &#39;=&#39;*len(title) )
        # access points HKB
        for d in self.din:
            if (&#39;HK&#39; in d) :
                dev = self.devmapper(d,&#39;HKB&#39;)
                print (&#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
        if &#39;FULL&#39; in self.typ:
                print (&#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;))
        for d in self.din:
            if (&#39;BS&#39; in d) :
                dev = self.devmapper(d,&#39;BS&#39;)
                print (&#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
        if &#39;FULL&#39; in self.typ:
                print( &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;))

        # access points TCR
        for d in self.din:
            if (&#39;TCR&#39; in d)  :
                dev = self.devmapper(d,&#39;TCR&#39;)
                print( &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
        print (&#39;{0:66}&#39;.format(&#39;-&#39;*len(title) ))
        #device per RAT per body
        for b in self.B:
            if b not in self.interf:
                #HKB per body
                for d in self.B[b].dev.keys():

                    if (&#39;HK&#39; in d):
                        dev = self.devmapper(d,&#39;HKB&#39;)
                        print( &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
                #bespoon
                if (&#39;FULL&#39; in self.typ) or (&#39;HKB&#39; in self.typ):
                    print( &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;))
                for d in self.B[b].dev.keys():
                    if (&#39;BS&#39; in d):
                        dev = self.devmapper(d,&#39;BS&#39;)
                        print( &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
                # print &#39;{0:66}&#39;.format(&#39;-&#39;*len(title) )
                #TCR per body
                if &#39;FULL&#39; in self.typ:
                    print( &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;))
                for d in self.B[b].dev.keys():
                    if (&#39;TCR&#39; in d):
                        dev = self.devmapper(d,&#39;TCR&#39;)
                        print( &#39;{0:21} | {1:7} | {2:8} | {3:10} &#39;.format(dev[0],dev[1],dev[2],dev[3]))
                print( &#39;{0:66}&#39;.format(&#39;-&#39;*len(title) ))



    def _loadcam(self):
        &quot;&quot;&quot; load camera position 

        Returns
        -------

        update self.cam

        &quot;&quot;&quot;

        self.cam = np.array([
            [-6502.16643961174,5440.97951452912,2296.44437108561],
            [-7782.34866625776,4998.47624994092,2417.5861326688],
            [8308.82897665828,3618.50516290547,2698.07710953287],
            [5606.68337709102,-6354.17891528277,2500.27779697402],
            [-8237.91886515041,-2332.98639475305,4765.31798299242],
            [5496.0942989988,6216.91946236788,2433.30012872688],
            [-8296.19706598514,2430.07325486109,4794.01607841197],
            [7718.37527064615,-4644.26760522485,2584.75330667172],
            [8471.27154730777,-3043.74550832061,2683.45089703377],
            [-8213.04824602894,-4034.57371591121,2368.54548665579],
            [-7184.66711497403,-4950.49444503781,2317.68563412347],
            [7531.66103727189,5279.02353243886,2479.36291603544],
            [-6303.08628709464,-7057.06193926342,2288.84938553817],
            [-5441.17834354692,6637.93014323586,2315.15657646861],
            [8287.79937470615,59.1614281340528,4809.14535447027]
            ])*1e-3


    def _loadinfranodes(self):
        &quot;&quot;&quot; load infrastructure nodes


nico

                        A4
                    mpts[6,7,8]
                        X

            A3                     A1
        mpts[9,10,11]        mpts[3,4,5]
            X                      X

                        A2
                    mpts[0,1,2]
                        X


        TCR = mpts[0,3,6,9]
        HKB = mpts[1,2,
                   4,5,
                   7,8,
                   10,11]

bernard


                        A3
                    mpts[3,4,5]
                        X

            A2                     A4
        mpts[6,7,8]        mpts[0,1,2]
            X                      X

                        A1
                    mpts[9,10,11]
                        X


        TCR = mpts[0,3,6,9]
        HKB = mpts[1,2,
                   4,5,
                   7,8,
                   10,11]


        &quot;&quot;&quot;

        filename = os.path.join(self.rootdir,&#39;RAW&#39;,&#39;11-06-2014&#39;,&#39;MOCAP&#39;,&#39;scene.c3d&#39;)

        print( &quot;\nload infrastructure node position:&quot;,)
        a, self.infraname, pts, i = c3d.ReadC3d(filename)

        pts = pts/1000.
        mpts = np.mean(pts, axis=0)
        self.din={}
        if (&#39;HK&#39;  in self.typ) or (&#39;FULL&#39; in self.typ):
            uhkb = np.array([[1,2], [4,5], [7,8], [10,11]])
            mphkb = np.mean(mpts[uhkb], axis=1)

            self.din.update(
                {&#39;HKB:1&#39;:{&#39;p&#39; : mphkb[3],
                          # &#39;T&#39; : np.eye(3),
                          &#39;s3off&#39; : 0.},

                 &#39;HKB:2&#39;:{&#39;p&#39; : mphkb[2],
                          # &#39;T&#39;: np.array([[-0.44807362,  0.89399666,  0.],
                          #                [-0.89399666, -0.44807362,  0.],
                          #                [ 0.,0.,1.        ]]),
                          &#39;s3off&#39;:0.}      ,
                 &#39;HKB:3&#39;:{&#39;p&#39;:mphkb[1],
                          # &#39;T&#39;:array([[-0.59846007, -0.80115264,  0.],
                          #            [ 0.80115264, -0.59846007,  0.],
                          #            [ 0.,0.,  1.]]),
                          &#39;s3off&#39;:0.},
                 &#39;HKB:4&#39;:{&#39;p&#39;:mphkb[0],
                          # &#39;T&#39;:array([[-0.44807362, -0.89399666,  0.],
                          #            [ 0.89399666, -0.44807362,  0.],
                          #            [ 0.,0.,  1.]]),
                          &#39;s3off&#39;:0.}
                 })

        # TCR:31 is the coordinator which was not captured.
        # The position has been determined via optimization
        if (&#39;TCR&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
            self.din.update({&#39;TCR:32&#39;:{&#39;p&#39;:mpts[9],
                                       &#39;T&#39;:np.eye(3),
                                       &#39;s3off&#39;:0.1},
                 &#39;TCR:24&#39;:{&#39;p&#39;:mpts[6],
                           # &#39;T&#39;: np.array([[-0.44807362,  0.89399666,  0.],
                           #               [-0.89399666, -0.44807362,  0.],
                           #               [ 0.,0.,1.        ]]),
                           &#39;s3off&#39;:0.1},
                 &#39;TCR:27&#39;:{&#39;p&#39;:mpts[3],
                           # &#39;T&#39;:array([[-0.59846007, -0.80115264,  0.],
                           #           [ 0.80115264, -0.59846007,  0.],
                           #           [ 0.,0.,  1.]]),
                           &#39;s3off&#39;:0.1},
                 &#39;TCR:28&#39;:{&#39;p&#39;:mpts[0],
                           # &#39;T&#39;:array([[-0.44807362, -0.89399666,  0.],
                           #           [ 0.89399666, -0.44807362,  0.],
                           #           [ 0.,0.,  1.]]),
                           &#39;s3off&#39;:0.1},
                 &#39;TCR:31&#39;:{&#39;p&#39;:array([1.7719,-3.2655,1.74]),
                           # &#39;T&#39;:array([[-0.44807362, -0.89399666,  0.],
                           #           [ 0.89399666, -0.44807362,  0.],
                           #           [ 0.,0.,  1.]]),
                           &#39;s3off&#39;:0.0}
                 })

        if self.day == 12:
            #BS idem HKB:1 and HKB:2
            if (&#39;BS&#39;  in self.typ) or (&#39;FULL&#39; in self.typ):
                self.din.update(
                {&#39;BS:74&#39;:{&#39;p&#39;:mphkb[3],
                          # &#39;T&#39;:np.eye(3),
                          &#39;s3off&#39;:-0.2},
                 &#39;BS:157&#39;:{&#39;p&#39;:mphkb[2],
                          # &#39;T&#39;: np.array([[-0.44807362,  0.89399666,  0.],
                          #                [-0.89399666, -0.44807362,  0.],
                          #                [ 0.,0.,1.        ]]),
                          &#39;s3off&#39;:-0.2}      ,
                 })

        #load extra  information from inifile (antenna, rotation matrix,...)

        inifile = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,str(self.day)+&#39;-06-2014&#39;,&#39;BodyandWear&#39;,&#39;AccesPoints.ini&#39;)
        config = ConfigParser.ConfigParser()
        config.read(inifile)

        for d in self.din:
            self.din[d][&#39;antname&#39;]=config.get(d,&#39;file&#39;)
            self.din[d][&#39;ant&#39;]=antenna.Antenna(config.get(d,&#39;file&#39;))
            self.din[d][&#39;T&#39;]=eval(config.get(d,&#39;t&#39;))
            self.din[d][&#39;comment&#39;]=config.get(d,&#39;comment&#39;)
        # self.pts= np.empty((12,3))
        # self.pts[:,0]= -mpts[:,1]
        # self.pts[:,1]= mpts[:,0]
        # self.pts[:,2]= mpts[:,2]
        # return mpts
        # self.dist = np.sqrt(np.sum((mpts[:,np.newaxis,:]-mpts[np.newaxis,:])**2,axis=2))


<div class="viewcode-block" id="CorSer.loadlog"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.loadlog">[docs]</a>    def loadlog(self):
        &quot;&quot;&quot; load in self.log the log of the current serie
            from MeasurementLog.csv
        &quot;&quot;&quot;

        filelog = os.path.join(self.rootdir,&#39;RAW&#39;,&#39;Doc&#39;,&#39;MeasurementLog.csv&#39;)
        log = pd.read_csv(filelog)
        date = str(self.day)+&#39;/06/14&#39;
        self.log = log[(log[&#39;Meas Serie&#39;] == self.serie) &amp; (log[&#39;Date&#39;] == date)]</div>


    def _loadbody(self,day=11,serie=&#39;&#39;):
        &quot;&quot;&quot; load body from motion capture file

        Parameters
        ----------

        day :
        serie :

        &quot;&quot;&quot;
        assert day in [11,12],&quot;wrong day in _loadbody&quot;
        self.B={}
        color=[&#39;LightBlue&#39;,&#39;YellowGreen&#39;,&#39;PaleVioletRed&#39;,&#39;white&#39;,&#39;white&#39;,&#39;white&#39;,&#39;white&#39;,&#39;white&#39;,&#39;white&#39;,&#39;white&#39;]
        for us,subject in enumerate(self.subject):
            print( &quot;\nload &quot;,subject, &quot; body:&quot;,)
            seriestr = str(self.serie).zfill(3)
            if day == 11:
                self.filemocap = os.path.join(self.rootdir,&#39;RAW&#39;,str(self.day)+&#39;-06-2014&#39;,&#39;MOCAP&#39;,&#39;serie_&#39;+seriestr+&#39;.c3d&#39;)
            elif day == 12:
                self.filemocap = os.path.join(self.rootdir,&#39;RAW&#39;,str(self.day)+&#39;-06-2014&#39;,&#39;MOCAP&#39;,&#39;Nav_serie_&#39;+seriestr+&#39;.c3d&#39;)

            # body and wear directory
            baw = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,str(self.day)+&#39;-06-2014&#39;,&#39;BodyandWear&#39;)
            if subject ==&#39;Jihad&#39;:
                subject =&#39;Jihan&#39;


            #
            # Load body cylinder description : &quot;Subject.ini&quot;
            # Load wearable device description (contains antenna filename) :
            #
            self.filebody = os.path.join(baw, subject + &#39;.ini&#39;)
            self.filewear = os.path.join(baw,subject + &#39;_&#39;  +str(self.day)+&#39;-06-2014_&#39; + self.typ + &#39;.ini&#39;)

            if len(self.subject) &gt;1 or self.mocapinterf:
                multi_subject=True
            else:
                multi_subject=False

            self.B.update({subject:Body(_filebody=self.filebody,
                             _filemocap=self.filemocap,unit = &#39;mm&#39;, loop=False,
                             _filewear=self.filewear,
                             centered=False,
                             multi_subject_mocap=multi_subject,
                             color=color[us])})

        if self.serie in self.mocapinterf:
            self.interf = [&#39;Anis_Cylindre:&#39;,
                     &#39;Benoit_Cylindre:&#39;,
                     &#39;Bernard_Cylindre:&#39;,
                     &#39;Claude_Cylindre:&#39;,
                     &#39;Meriem_Cylindre:&#39;]
            intertmp=[]
            if self.serie==13:
                self.interf.remove(&#39;Bernard_Cylindre:&#39;)
            for ui,i in enumerate(self.interf):
                #try:
                print( &quot;load &quot;,i, &quot; interfering body:&quot;,)
                _filemocap = pyu.getshort(self.filemocap)
                self.B.update({i:Cylinder(name=i,
                                          _filemocap=_filemocap,
                                          unit = &#39;mm&#39;,
                                          color = color[ui])})
                intertmp.append(i)
                #except:
                #    print &quot;Warning ! load &quot;,i, &quot; FAIL !&quot;
            self.interf=intertmp
        else :
            self.interf=[]
        # if len(self.subject) == 1:
        #     self.B = self.B[self.subject]


    def _loadTCR(self,day=11,serie=&#39;&#39;,scenario=&#39;20&#39;,run=1):
        &quot;&quot;&quot; load TCR data

        Parameters
        ----------

        day :
        serie :
        scenario :
        run :

        &quot;&quot;&quot;

        #
        # TNET : (NodeId,MAC)
        #

        self.TNET={0:31,
        1:2,
        7:24,
        8:25,
        9:26,
        10:27,
        11:28,
        12:30,
        14:32,
        15:33,
        16:34,
        17:35,
        18:36,
        19:37,
        20:48,
        21:49}

        if day==11:
            self.dTCR ={&#39;Unused&#39;:49,
                  &#39;COORD&#39;:31,
                  &#39;AP1&#39;:32,
                  &#39;AP2&#39;:24,
                  &#39;AP3&#39;:27,
                  &#39;AP4&#39;:28,
                  &#39;HeadRight&#39;:34,
                  &#39;TorsoTopRight&#39;:25,
                  &#39;TorsoTopLeft&#39;:30,
                  &#39;BackCenter&#39;:35,
                  &#39;HipRight&#39;:2,
                  &#39;WristRight&#39;:26,
                  &#39;WristLeft&#39;:48,
                  &#39;KneeLeft&#39;:33,
                  &#39;AnkleRight&#39;:36,
                  &#39;AnkleLeft&#39;:37}
            dirname = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,&#39;11-06-2014&#39;,&#39;TCR&#39;)


        if day==12:
            dirname = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,&#39;12-06-2014&#39;,&#39;TCR&#39;)
            self.dTCR ={ &#39;COORD&#39;:31,
                        &#39;AP1&#39;:32,
                        &#39;AP2&#39;:24,
                        &#39;AP3&#39;:27,
                        &#39;AP4&#39;:28,
                   &#39;Jihad:TorsoTopRight&#39;:35,
                   &#39;Jihad:TorsoTopLeft&#39;:2,
                   &#39;Jihad:BackCenter&#39;:33,
                   &#39;Jihad:ShoulderLeft&#39;:37,
                   &#39;Nicolas:TorsoTopRight&#39;:34,
                   &#39;Nicolas:TorsoTopLeft&#39;:49,
                   &#39;Nicolas:BackCenter&#39;:48,
                   &#39;Nicolas:ShoulderLeft&#39;:36,
                   &#39;Eric:TorsoCenter&#39;:30,
                   &#39;Eric:BackCenter&#39;:25,
                   &#39;Eric:ShoulderLeft&#39;:26}

        #
        # TCR  : (Name , MAC)
        # iTCR : (MAC , Name)
        # dTCR : (NodeId, Name)
        #

        self.idTCR={}
        for k in self.dTCR:
            self.idTCR[self.dTCR[k]]=k


        dTCRni={}
        for k in self.TNET.keys():
            dTCRni[k]=self.idTCR[self.TNET[k]]


        files = os.listdir(dirname)
        if serie != &#39;&#39;:
            try:
                self._fileTCR = filter(lambda x : &#39;_S&#39;+str(serie)+&#39;_&#39; in x ,files)[0]
            except:
                self._fileTCR = filter(lambda x : &#39;_s&#39;+str(serie)+&#39;_&#39; in x ,files)[0]
            tt = self._fileTCR.split(&#39;_&#39;)
            self.scenario=tt[0].replace(&#39;Sc&#39;,&#39;&#39;)
            self.run = tt[2].replace(&#39;R&#39;,&#39;&#39;)
            self.typ = tt[3].replace(&#39;.csv&#39;,&#39;&#39;).upper()
            self.video = &#39;NA&#39;
        else:
            filesc = filter(lambda x : &#39;Sc&#39;+scenario in x ,files)
            self._fileTCR = filter(lambda x : &#39;R&#39;+str(run) in x ,filsc)[0]
            self.scenario= scenario
            self.run = str(run)

        filename = os.path.join(dirname,self._fileTCR)
        dtTCR = pd.read_csv(filename)
        tcr={}
        for k in dTCRni:
            for l in dTCRni:
                if k!=l:
                    d = dtTCR[((dtTCR[&#39;ida&#39;]==k) &amp; (dtTCR[&#39;idb&#39;]==l))]
                    d.drop_duplicates(&#39;time&#39;,inplace=True)
                    del d[&#39;lqi&#39;]
                    del d[&#39;ida&#39;]
                    del d[&#39;idb&#39;]
                    d = d[d[&#39;time&#39;]!=-1]
                    d.index = d[&#39;time&#39;]
                    del d[&#39;time&#39;]
                    if len(d)!=0:
                        sr = pd.Series(d[&#39;dist&#39;]/1000,index=d.index)
                        tcr[dTCRni[k]+&#39;-&#39;+dTCRni[l]]= sr


        self.tcr = pd.DataFrame(tcr)
        self.tcr = self.tcr.fillna(0)
        ts = 75366400./1e9
        t = np.array(self.tcr.index)*ts
        t = t-t[0]
        self.tcr.index = t
        self.ttcr=self.tcr.index

    def _loadBS(self,day=11,serie=&#39;&#39;,scenario=&#39;20&#39;,run=1):
        &quot;&quot;&quot; load BeSpoon data

        Parameters
        ----------

        day : int
        serie : string
        scenario : string
        run : int

        &quot;&quot;&quot;

        if day == 11:
            self.dBS = {&#39;WristRight&#39;:157,&#39;AnkleRight&#39;:74,&#39;HandRight&#39;:0}
        elif day == 12:
            self.dBS = {&#39;AP1&#39;:157,&#39;AP2&#39;:74,&#39;HandRight&#39;:0}
        self.idBS={}
        for k in self.dBS:
            self.idBS[self.dBS[k]]=k

        if day==11:
            dirname = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,&#39;11-06-2014&#39;,&#39;BeSpoon&#39;)
        if day==12:
            dirname = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,&#39;12-06-2014&#39;,&#39;BeSpoon&#39;)

        files = os.listdir(dirname)
        if serie != &#39;&#39;:
            #self._fileBS = filter(lambda x : &#39;S&#39;+str(serie) in x ,files)[0]
            self._fileBS = [ x for x in files if &#39;S&#39;+str(serie) in x ][0]
        else:
            self._fileBS = [ x for x in files if &#39;R&#39;+str(serie) in x ][0]
            #filesc = filter(lambda x : &#39;Sc&#39;+scenario in x ,files)
            self._fileBS = filter(lambda x : &#39;R&#39;+str(run) in x ,filsc)[0]

        bespo = pd.read_csv(os.path.join(dirname,self._fileBS),index_col=&#39;ts&#39;)


        gb = bespo.groupby([&#39;Sensor&#39;])
        #get device id
        devid,idevid = np.unique(bespo[&#39;Sensor&#39;],return_index=True)
        # get index of each group
        dgb={d:gb.get_group(d) for d in devid}
        lgb=[]
        for i in dgb:
            ind = dgb[i].index/1e3
            dti = pd.to_datetime(ind,unit=&#39;s&#39;)
            npai = time2npa(dti)
            npai = npai - npai[0]
            dgb[i].index=pd.Index(npai)
            lgb.append(pd.DataFrame(dgb[i][&#39;d&#39;].values,columns=[self.idBS[0]+&#39;-&#39;+self.idBS[i]],index=dgb[i].index))
        df = lgb[0].join(lgb[1])
        self.bespo = df


        #self.s157 = self.bespo[self.bespo[&#39;Sensor&#39;]==157]
        #self.s157.set_index(self.s157[&#39;tu&#39;].values/1e9)
        #self.s74  = self.bespo[self.bespo[&#39;Sensor&#39;]==74]
        #self.s74.set_index(self.s74[&#39;tu&#39;].values/1e9)
        #t157 = np.array(self.s157[&#39;tu&#39;]/(1e9))
        #self.t157 = t157-t157[0]
        #t74 = np.array(self.s74[&#39;tu&#39;]/(1e9))
        #self.t74 = t74 - t74[0]


    def _loadhkb(self,day=11,serie=&#39;&#39;,scenario=&#39;20&#39;,run=1,source=&#39;CITI&#39;):
        &quot;&quot;&quot; load hkb measurement data

        Parameters
        ----------

        day : string
        serie : string
        scenario : string
        run : int
        source : &#39;string&#39;

        Returns
        -------

        update self.hkb

        &quot;&quot;&quot;

        if day == 11:
            if serie == 5:
                source = &#39;UR1&#39;

        if day==11:
            self.dHKB ={&#39;AP1&#39;:1,&#39;AP2&#39;:2,&#39;AP3&#39;:3,&#39;AP4&#39;:4,
                       &#39;HeadRight&#39;:5,&#39;TorsoTopRight&#39;:6,&#39;TorsoTopLeft&#39;:7,&#39;BackCenter&#39;:8,&#39;ElbowRight&#39;:9,&#39;ElbowLeft&#39;:10,&#39;HipRight&#39;:11,&#39;WristRight&#39;:12,&#39;WristLeft&#39;:13,&#39;KneeLeft&#39;:14,&#39;AnkleRight&#39;:16,&#39;AnkleLeft&#39;:15}
            if source==&#39;UR1&#39; :
                dirname = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,&#39;11-06-2014&#39;,&#39;HIKOB&#39;)
            elif source==&#39;CITI&#39;:
                dirname = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,&#39;11-06-2014&#39;,&#39;HIKOB&#39;,&#39;CITI&#39;)
        if day==12:
            self.dHKB= {&#39;AP1&#39;:1,&#39;AP2&#39;:2,&#39;AP3&#39;:3,&#39;AP4&#39;:4,&#39;Jihad:TorsoTopRight&#39;:10,&#39;Jihad:TorsoTopLeft&#39;:9,&#39;Jihad:BackCenter&#39;:11,&#39;JihadShoulderLeft&#39;:12,
             &#39;Nicolas:TorsoTopRight&#39;:6,&#39;Nicolas:TorsoTopLeft&#39;:5,&#39;Nicolas:BackCenter&#39;:7,&#39;Nicolas:ShoulderLeft&#39;:8,
             &#39;Eric:TooTopRight&#39;:15,&#39;Eric:TorsoTopLeft&#39;:13,&#39;Eric:BackCenter&#39;:16,&#39;Eric:ShoulderLeft&#39;:14}
            #if source==&#39;UR1&#39;:
            dirname = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,&#39;12-06-2014&#39;,&#39;HIKOB&#39;)

        files = os.listdir(dirname)

        self.idHKB={}
        for k in self.dHKB:
            self.idHKB[self.dHKB[k]]=k

        if serie != &#39;&#39;:
            self._filehkb = [ x for x in files if &#39;S&#39;+str(serie) in x][0]
            tt = self._filehkb.split(&#39;_&#39;)
            if source == &#39;UR1&#39;:
                self.scenario=tt[0].replace(&#39;Sc&#39;,&#39;&#39;)
                self.run = tt[2].replace(&#39;R&#39;,&#39;&#39;)
                self.typ = tt[3]
                self.video = tt[4].replace(&#39;.mat&#39;,&#39;&#39;)
            elif source == &#39;CITI&#39;:
                self.scenario=tt[0].replace(&#39;Sc&#39;,&#39;&#39;)+tt[1]

                self.run = tt[3].replace(&#39;r&#39;,&#39;&#39;)
                self.typ = tt[4]
                if self.typ == &#39;HKB&#39;:
                    self.typ = &#39;HKBS&#39;
                self.video = tt[5].replace(&#39;.mat&#39;,&#39;&#39;)

        else:
            filesc = [ x for x in files if x in &#39;Sc&#39;+scenario  ][0]
            if source==&#39;UR1&#39;:
                self._filehkb = [ x for x in filesc if x in &#39;R&#39;+str(run)][0]
            else:
                self._filehkb = [ x for x in filesc if x in &#39;r&#39;+str(run)][0]


        data = io.loadmat(os.path.join(dirname,self._filehkb))
        if source==&#39;UR1&#39;:
            self.rssi = data[&#39;rssi&#39;]
            self.thkb = data[&#39;t&#39;]
        else:
            self.rssi = data[&#39;val&#39;]
            self.thkb = np.arange(np.shape(self.rssi)[2])*25.832e-3

        def topandas():
            try:
                self.hkb = pd.DataFrame(index=self.thkb[0])
            except:
                self.hkb = pd.DataFrame(index=self.thkb)
            for k in self.idHKB:
                for l in self.idHKB:
                    if k!=l:
                        col  = self.idHKB[k]+&#39;-&#39;+self.idHKB[l]
                        rcol = self.idHKB[l]+&#39;-&#39;+self.idHKB[k]
                        if rcol not in self.hkb.columns:
                            rssi  = self.rssi[k-1,l-1,:]
                            self.hkb[col] = rssi

        topandas()
        self.hkb = self.hkb[self.hkb!=0]

<div class="viewcode-block" id="CorSer.compute_visibility"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.compute_visibility">[docs]</a>    def compute_visibility(self,techno=&#39;HKB&#39;,square_mda=True,all_links=True):
        &quot;&quot;&quot; determine visibility of links for a given techno


            Parameters
            ----------

            techno  string
                select the given radio technology of the nodes to determine
                    the visibility matrix

            square_mda  boolean
                select ouput format
                    True : (device x device x timestamp)
                    False : (link x timestamp)

            all_links : bool
                compute all links or just those for which data is available

            Return
            ------

            if square_mda = True

            intersection : (ndevice x nbdevice x nb_timestamp)
                matrice of intersection (1 if link is cut 0 otherwise)
            links : (nbdevice)
                name of the links


            if square_mda = False

            intersection : (nblink x nb_timestamp)
                matrice of intersection (1 if link is cut 0 otherwise)
            links : (nblink x2)
                name of the links

            Example
            -------

            &gt;&gt;&gt; from pylayers.measures.cormoran import *
            &gt;&gt;&gt; import matplotlib.pyplot as plt
            &gt;&gt;&gt; C=CorSer(serie=14,day=12)
            &gt;&gt;&gt; inter,links=C.compute_visibility(techno=&#39;TCR&#39;,square_mda=True)
            &gt;&gt;&gt; inter.shape
                (15, 15, 12473)
            &gt;&gt;&gt;C.imshowvisibility_i(inter,links)


        &quot;&quot;&quot;



        if techno == &#39;TCR&#39;:
            if not ((self.typ == &#39;TCR&#39;) or  (self.typ == &#39;FULL&#39;)):
                raise AttributeError(&#39;Serie has not data for techno: &#39;,techno)
            hname = self.tcr.keys()
            dnode=copy.copy(self.dTCR)
            dnode.pop(&#39;COORD&#39;)
            prefix = &#39;TCR:&#39;
        elif techno==&#39;HKB&#39;:
            if not ((self.typ == &#39;HKBS&#39;) or  (self.typ == &#39;FULL&#39;)):
                raise AttributeError(&#39;Serie has not data for techno: &#39;+techno)
            hname = self.hkb.keys()
            dnode=self.dHKB
            prefix = &#39;HKB:&#39;
        # get link list
        if all_links:
            import itertools
            links =[l for l in itertools.combinations(dnode.keys(),2)]
        else:
            links=[n.split(&#39;-&#39;) for n in hname]
            links = [l for l in links if (&#39;COORD&#39; not in l[0]) and (&#39;COORD&#39; not in l[1])]
        #mapping between device name in self.hkb and on body/in self.devdf
        dev_bid = [self.devmapper(k,techno=techno)[2] for k in dnode.keys()]

        nb_totaldev=len(np.unique(self.devdf[&#39;id&#39;]))
        # extract all dev position on body
        # Mpdev : (3 x (nb devices and nb infra nodes) x nb_timestamp)
        Mpdev = np.empty((3,len(dev_bid),len(self.devdf.index)/nb_totaldev))

        # get all positions
        for ik,i in enumerate(dev_bid) :
            if i in self.din:
                Mpdev[:,ik,:] = self.din[i][&#39;p&#39;][:,np.newaxis]
            else:
                pts = self.devdf[self.devdf[&#39;id&#39;]==i][[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]].values.T
                if np.prod(pts.shape)!=0:
                    Mpdev[:,ik,:] = pts

        # create A and B from links
        nA = np.array([prefix+ str(dnode[l[0]]) for l in links])
        nB = np.array([prefix+ str(dnode[l[1]]) for l in links])

        dma = dict(zip(dev_bid,range(len(dev_bid))))
        mnA = [dma[n] for n in nA]
        mnB = [dma[n] for n in nB]

        A=Mpdev[:,mnA]
        B=Mpdev[:,mnB]


        # intersect2D matrix is
        # d_0: nb links
        #d_1: (cylinder number) * nb body + 1 * nb  cylinder_object
        # d_2 : nb frame
        intersect2D = np.zeros((len(links),
                                11*len(self.subject) + len(self.interf),
                                Mpdev.shape[-1]))
        # usub : index axes subject
        usub_start=0
        usub_stop=0
        # C-D correspond to bodies segments
        #C or D : 3 x 11 body segments x time
        # radius of cylinders are (nb_cylinder x time)
        for b in self.B:
            print( &#39;processing shadowing from &#39;,b)
            # if b is a body not a cylinder
            if not &#39;Cylindre&#39; in b:
                uta = self.B[b].sl[:,0].astype(&#39;int&#39;)
                uhe = self.B[b].sl[:,1].astype(&#39;int&#39;)
                rad = self.B[b].sl[:,2]

                C = self.B[b].d[:,uta,:]
                D = self.B[b].d[:,uhe,:]
                try:
                    radius = np.concatenate((radius,rad[:,np.newaxis]*np.ones((1,C.shape[2]))),axis=0)
                except:
                    radius = rad[:,np.newaxis]*np.ones((1,C.shape[2]))
                usub_start=usub_stop
                usub_stop=usub_stop+11
            else:

                cyl = self.B[b]
                # top of cylinder
                top = cyl.d[:,cyl.topnode,:]
                # bottom of cylinder =top with z =0
                bottom = copy.copy(cyl.d[:,cyl.topnode,:])
                bottom[2,:]=0.02
                #top 3 x 1 X time
                C=top[:,np.newaxis,:]
                D=bottom[:,np.newaxis,:]
                radius = np.concatenate((radius,cyl.radius[np.newaxis]))
                usub_start=usub_stop
                usub_stop=usub_stop+1

            f,g,X,Y,alpha,beta,dmin=seg.segdist(A,B,C,D,hard=True)

            intersect2D[:,usub_start:usub_stop,:]=g
            # import ipdb
            # ipdb.set_trace()
            #USEFUL Lines for debug
            #########################

            # def plt3d(ndev=53,ncyl=0,kl=11499):
            #     fig=plt.figure()
            #     ax=fig.add_subplot(111,projection=&#39;3d&#39;)
            #     if not isinstance(kl,list):
            #         kl=[kl]

            #     for ktime in kl:
            #         ax.plot([A[0,ndev,ktime],B[0,ndev,ktime]],[A[1,ndev,ktime],B[1,ndev,ktime]],[A[2,ndev,ktime],B[2,ndev,ktime]])
            #         [ax.plot([C[0,k,ktime],D[0,k,ktime]],[C[1,k,ktime],D[1,k,ktime]],[C[2,k,ktime],D[2,k,ktime]],&#39;k&#39;) for k in range(11) ]
            #         ax.plot([X[0,ndev,ncyl,ktime],Y[0,ndev,ncyl,ktime]],[X[1,ndev,ncyl,ktime],Y[1,ndev,ncyl,ktime]],[X[2,ndev,ncyl,ktime],Y[2,ndev,ncyl,ktime]])
            #     ax.auto_scale_xyz([-5, 5], [-5, 5], [0, 2])
            #     plt.show()
            # import ipdb
            # ipdb.set_trace()




        uinter1 = np.where((intersect2D&lt;=(radius-0.01)))
        uinter0 = np.where((intersect2D&gt;(radius-0.01)))
        # intersect2D_=copy.copy(intersect2D)

        intersect2D[uinter1[0],uinter1[1],uinter1[2]]=1
        intersect2D[uinter0[0],uinter0[1],uinter0[2]]=0
        # #integrate the effect of all bodies by summing on axis 1
        intersect = np.sum(intersect2D,axis=1)&gt;0

        if square_mda:
            dev= np.unique(links)
            ddev = dict(zip(dev,range(len(dev))))
            lmap = np.array(map(lambda x: (ddev[x[0]],ddev[x[1]]),links))
            M = np.nan*np.ones((len(dev),len(dev),intersect.shape[-1]))
            for i in range(len(intersect)):
                id1 = lmap[i][0]
                id2 = lmap[i][1]
                M[id1,id2,:]=intersect[i,:]
                M[id2,id1,:]=intersect[i,:]
            intersect=M
            links = dev

        self._visilinks = links
        self._visiintersect = intersect

        return intersect,links</div>

<div class="viewcode-block" id="CorSer.imshowvisibility"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.imshowvisibility">[docs]</a>    def imshowvisibility(self,techno=&#39;HKB&#39;,t=0,**kwargs):
        &quot;&quot;&quot;  imshow visibility mda


        Parameters
        ----------

        techno : (HKB|TCR)
        t : float
            time in second

        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; C=CorSer(serie=6,day=12)
        &gt;&gt;&gt; inter,links=C.compute_visibility(techno=&#39;TCR&#39;,square_mda=True)
        &gt;&gt;&gt; i,l=C.imshowvisibility_i(inter,links)

        See Also
        --------

        pylayers.measures.CorSer.compute_visibility()

        &quot;&quot;&quot;
        defaults = { &#39;grid&#39;:True,
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        if &#39;fig&#39; not in kwargs:
           fig = plt.figure()
        else:
           fig = kwargs.pop(&#39;fig&#39;)

        if &#39;ax&#39; not in kwargs:
            ax = fig.add_subplot(111)
        else:
            ax = kwargs.pop(&#39;ax&#39;)

        if not &#39;_visiintersect&#39; in dir(self):
            print( &#39;Visibility computed only once&#39;)
            self.compute_visibility(techno=techno)


        links = self._visilinks
        inter = self._visiintersect



        kt=np.where(self.tmocap &lt;= t)[0][-1]
        plt.xticks(np.arange(0, len(links), 1.0))
        plt.yticks(np.arange(0, len(links), 1.0))
        ax.set_xlim([-0.5,len(links)-0.5])
        ax.set_ylim([len(links)-0.5,-0.5])
        ax.xaxis.set_ticks_position(&#39;top&#39;) 
        xtickNames = plt.setp(ax, xticklabels=links)
        ytickNames = plt.setp(ax, yticklabels=links)
        plt.setp(xtickNames, rotation=90, fontsize=8)
        plt.setp(ytickNames, rotation=0, fontsize=8)
        ims=[]
        ax.imshow(inter[:,:,kt],interpolation=&#39;nearest&#39;)
        if kwargs[&#39;grid&#39;]:
            ax.grid()
        return fig,ax</div>

    def _show3i(self,t=0,**kwargs):
        &quot;&quot;&quot; show3 interactive
        &quot;&quot;&quot;

        fig =plt.figure(num=&#39;Jog&#39;,figsize=(5,1.5))
        

        #set time to -10 is a trick to make appear interferers cylinder
        #because __refreshshow3i only update the data of the cylinder.
        # if cylinder is not present in the first _show3, they are not displayed
        # later.
        time=self.B[self.subject[0]].time

        fId = np.where(time&lt;= t)[0][-1]

        kwargs[&#39;bodytime&#39;]=[self.tmocap[-10]]
        kwargs[&#39;returnfig&#39;]=True
        kwargs[&#39;tagtraj&#39;]=False
        mayafig = self._show3(**kwargs)
        self.__refreshshow3i(fId)
        # ax.grid()


        # matplotlib Widgets 

        slax=plt.axes([0.1, 0.5, 0.8, 0.3])
        slax.set_title(&#39;t=&#39;+str(time[fId]),loc=&#39;left&#39;)
        sliderx = Slider(slax, &quot;time&quot;, 0, len(time),
                        valinit=fId, color=&#39;#AAAAAA&#39;)


        def update_x(val):
            value = int(sliderx.val)
            self.__refreshshow3i(val)
            slax.set_title(&#39;t=&#39;+str(time[val]),loc=&#39;left&#39;)
            fig.canvas.draw_idle()
        sliderx.on_changed(update_x)


        def plus(event):
            sliderx.set_val(sliderx.val +1)
            fig.canvas.draw_idle()

        def minus(event):
            sliderx.set_val(sliderx.val -1)
            fig.canvas.draw_idle()

        def pplus(event):
            sliderx.set_val(sliderx.val +10)
            fig.canvas.draw_idle()


        def mminus(event):
            sliderx.set_val(sliderx.val -10)
            fig.canvas.draw_idle()

        #QUIT by pressing &#39;q&#39;
        def press(event):
            if event.key == &#39;q&#39;:
                mlab.close(mayafig)
                plt.close(fig)
        fig.canvas.mpl_connect(&#39;key_press_event&#39;, press)


        #-1 frame axes
        axm = plt.axes([0.2, 0.05, 0.1, 0.15])
        bm = Button(axm, &#39;-1&#39;)
        bm.on_clicked(minus)
                #+1 frame axes
        axp = plt.axes([0.7, 0.05, 0.1, 0.15])
        bp = Button(axp, &#39;+1&#39;)
        bp.on_clicked(plus)

        #-10 frames axes
        axmm = plt.axes([0.1, 0.05, 0.1, 0.15])
        bmm = Button(axmm, &#39;-10&#39;)
        bmm.on_clicked(mminus)


        #+10 frames axes
        axpp = plt.axes([0.8, 0.05, 0.1, 0.15])
        bpp = Button(axpp, &#39;+10&#39;)
        bpp.on_clicked(pplus)



        plt.show()


    def _show3idemo(self,t=0,**kwargs):
        &quot;&quot;&quot; show3 interactive
        &quot;&quot;&quot;

        defaults={&#39;nodename&#39;:&#39;TorsoTopLeft&#39;}


        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        fig =plt.figure(num=&#39;Jog&#39;,figsize=(5,1.5))
        

        #set time to -10 is a trick to make appear interferers cylinder
        #because __refreshshow3i only update the data of the cylinder.
        # if cylinder is not present in the first _show3, they are not displayed
        # later.
        time=self.B[self.subject[0]].time

        fId = np.where(time&lt;= t)[0][-1]

        kwargs[&#39;bodytime&#39;]=[self.tmocap[-10]]
        kwargs[&#39;returnfig&#39;]=True
        kwargs[&#39;tagtraj&#39;]=False
        mayafig = self._show3(**kwargs)
        self.__refreshshow3i(fId)
        # ax.grid()


        # matplotlib Widgets 

        slax=plt.axes([0.1, 0.5, 0.8, 0.3])
        slax.set_title(&#39;t=&#39;+str(time[fId]),loc=&#39;left&#39;)
        sliderx = Slider(slax, &quot;time&quot;, 0, len(time),
                        valinit=fId, color=&#39;#AAAAAA&#39;)


        def update_x(val):
            value = int(sliderx.val)
            self.__refreshshow3i(val)
            slax.set_title(&#39;t=&#39;+str(time[val]),loc=&#39;left&#39;)
            vline0.set_data(([time[value],time[value]],[0,1]))
            vline1.set_data(([time[value],time[value]],[0,1]))
            vline2.set_data(([time[value],time[value]],[0,1]))
            vline3.set_data(([time[value],time[value]],[0,1]))
            fig.canvas.draw_idle()
            fig2.canvas.draw_idle()
        sliderx.on_changed(update_x)


        def plus(event):
            sliderx.set_val(sliderx.val +1)
            fig.canvas.draw_idle()

        def minus(event):
            sliderx.set_val(sliderx.val -1)
            fig.canvas.draw_idle()

        def pplus(event):
            sliderx.set_val(sliderx.val +10)
            fig.canvas.draw_idle()


        def mminus(event):
            sliderx.set_val(sliderx.val -10)
            fig.canvas.draw_idle()

        #QUIT by pressing &#39;q&#39;
        def press(event):
            if event.key == &#39;q&#39;:
                mlab.close(mayafig)
                plt.close(fig)
                plt.close(fig2)
        fig.canvas.mpl_connect(&#39;key_press_event&#39;, press)


        #-1 frame axes
        axm = plt.axes([0.2, 0.05, 0.1, 0.15])
        bm = Button(axm, &#39;-1&#39;)
        bm.on_clicked(minus)
                #+1 frame axes
        axp = plt.axes([0.7, 0.05, 0.1, 0.15])
        bp = Button(axp, &#39;+1&#39;)
        bp.on_clicked(plus)

        #-10 frames axes
        axmm = plt.axes([0.1, 0.05, 0.1, 0.15])
        bmm = Button(axmm, &#39;-10&#39;)
        bmm.on_clicked(mminus)


        #+10 frames axes
        axpp = plt.axes([0.8, 0.05, 0.1, 0.15])
        bpp = Button(axpp, &#39;+10&#39;)
        bpp.on_clicked(pplus)



        fig2,ax2 = plt.subplots(4,1,figsize=(12,6))
        ax2=ax2.ravel()

        df0 = self.getlink(kwargs[&#39;nodename&#39;],&#39;AP1&#39;,techno=&#39;HKB&#39;)
        df0.plot(ax=ax2[0],fig=fig2)
        
        df1 = self.getlink(kwargs[&#39;nodename&#39;],&#39;AP2&#39;,techno=&#39;HKB&#39;)
        df1.plot(ax=ax2[1],fig=fig2)

        df2 = self.getlink(kwargs[&#39;nodename&#39;],&#39;AP3&#39;,techno=&#39;HKB&#39;)
        df2.plot(ax=ax2[2],fig=fig2)

        df3 = self.getlink(kwargs[&#39;nodename&#39;],&#39;AP4&#39;,techno=&#39;HKB&#39;)
        df3.plot(ax=ax2[3],fig=fig2)

        ax2[0].set_ylabel(&#39;AP1&#39;)
        ax2[1].set_ylabel(&#39;AP2&#39;)
        ax2[2].set_ylabel(&#39;AP3&#39;)
        ax2[3].set_ylabel(&#39;AP4&#39;)

        vline0 = ax2[0].axvline(x=time[fId], color=&#39;red&#39;)
        vline1 = ax2[1].axvline(x=time[fId], color=&#39;red&#39;)
        vline2 = ax2[2].axvline(x=time[fId], color=&#39;red&#39;)
        vline3 = ax2[3].axvline(x=time[fId], color=&#39;red&#39;)

        fig2.suptitle(kwargs[&#39;nodename&#39;])


        plt.show()


    def __refreshshow3i(self,kt):
        &quot;&quot;&quot; show3 update for interactive mode
            USED in imshowvisibility_i
        &quot;&quot;&quot;
        t=self.tmocap[kt]

        for ib,b in enumerate(self.B):
            self.B[b].settopos(t=t,cs=True)

            try:
                # body
                X=np.hstack((self.B[b]._pta,self.B[b]._phe))
                self.B[b]._mayapts.mlab_source.set(x=X[0,:], y=X[1,:], z=X[2,:])
                # device
                udev = [self.B[b].dev[i][&#39;uc3d&#39;][0] for i in self.B[b].dev]
                Xd=self.B[b]._f[kt,udev,:].T
                self.B[b]._mayadev.mlab_source.set(x=Xd[0,:], y=Xd[1,:], z=Xd[2,:])
                # name
                uupper = np.where(X[2]==X[2].max())[0]
                self.B[b]._mayaname.actors.pop()
                self.B[b]._mayaname = mlab.text3d(X[0,uupper][0],X[1,uupper][0],X[2,uupper][0],self.B[b].name,scale=0.05,color=(1,0,0))
                # s = np.hstack((cylrad,cylrad))
            except:
                # cylinder
                X=np.vstack((self.B[b].top,self.B[b].bottom))
                self.B[b]._mayapts.mlab_source.set(x=X[:,0], y=X[:,1], z=X[:,2])
                # name
                self.B[b]._mayaname.actors.pop()
                self.B[b]._mayaname = mlab.text3d(self.B[b].top[0],self.B[b].top[1],self.B[b].top[2],self.B[b].name,scale=0.05,color=(1,0,0))
                #vdict
                V = self.B[b].traj[[&#39;vx&#39;,&#39;vy&#39;,&#39;vz&#39;]].iloc[self.B[b].toposFrameId].values

                self.B[b]._mayavdic.mlab_source.set(x= self.B[b].top[0],y=self.B[b].top[1],z=self.B[b].top[2],u=V[ 0],v=V[ 1],w=V[ 2])


<div class="viewcode-block" id="CorSer.imshowvisibility_i"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.imshowvisibility_i">[docs]</a>    def imshowvisibility_i(self,techno=&#39;HKB&#39;,t=0,**kwargs):
        &quot;&quot;&quot;  imshow visibility mda interactive

        Parameters
        ----------

        inter : (nb link x nb link x timestamps)
        links : (nblinks)
        time : intial time (s)


        Example
        -------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; C=CorSer(serie=6,day=12)
        &gt;&gt;&gt; inter,links=C.visimda(techno=&#39;TCR&#39;,square_mda=True)
        &gt;&gt;&gt; i,l=C.imshowvisibility_i(inter,links)

        &quot;&quot;&quot;


        # if in_ipynb():
        #     notebook = False #program launch in ipyhon notebook
        #     from IPython.html import widgets # Widget definitions
        #     from IPython.display import display, clear_output# Used to display widgets in the notebook
        # else :
        #     notebook = False

        if not &#39;_visiintersect&#39; in dir(self):
            print( &#39;Visibility is computed only once, Please wait\n&#39;)
            self.compute_visibility(techno=techno)


        links = self._visilinks
        inter = self._visiintersect


        fig, ax = plt.subplots()
        fig.subplots_adjust(bottom=0.3)


        time=self.tmocap

        fId = np.where(time&lt;=t)[0][-1]

        vertc = [(0,-10),(0,-10),(0,10),(0,-10)]
        poly = plt.Polygon(vertc)
        pp = ax.add_patch(poly)

        plt.xticks(np.arange(0, len(links), 1.0))
        plt.yticks(np.arange(0, len(links), 1.0))
        ax.set_xlim([-0.5,len(links)-0.5])
        ax.set_ylim([len(links)-0.5,-0.5])
        ax.xaxis.set_ticks_position(&#39;top&#39;) 
        xtickNames = plt.setp(ax, xticklabels=links)
        ytickNames = plt.setp(ax, yticklabels=links)
        plt.setp(xtickNames, rotation=90, fontsize=8)
        plt.setp(ytickNames, rotation=0, fontsize=8)
        ims=[]
        l=ax.imshow(inter[:,:,fId],interpolation=&#39;nearest&#39;)
        #set time to -10 is a trick to make appear interferers cylinder
        #because __refreshshow3i only update the data of the cylinder.
        # if cylinder is not present in the first _show3, they are not displayed
        # later.
        kwargs[&#39;bodytime&#39;]=[self.tmocap[-10]]
        kwargs[&#39;returnfig&#39;]=True
        kwargs[&#39;tagtraj&#39;]=False
        mayafig = self._show3(**kwargs)
        self.__refreshshow3i(fId)
        # ax.grid()


        # matplotlib Widgets 
        slax=plt.axes([0.1, 0.15, 0.8, 0.05])
        slax.set_title(&#39;t=&#39;+str(time[fId]),loc=&#39;left&#39;)
        sliderx = Slider(slax, &quot;time&quot;, 0, inter.shape[-1],
                        valinit=fId, color=&#39;#AAAAAA&#39;)

        # else :
        #     int_range = widgets.IntSliderWidget(min=0,max=inter.shape[-1],step=1,value=fId)
        #     display(int_range)


        def update_x(val):
            value = int(sliderx.val)
            sliderx.valtext.set_text(&#39;{}&#39;.format(value))
            l.set_data(inter[:,:,value])
            self.__refreshshow3i(val)
            slax.set_title(&#39;t=&#39;+str(time[val]),loc=&#39;left&#39;)
            fig.canvas.draw_idle()
        sliderx.on_changed(update_x)
        # else:
        #     def update_x(name,value):

        #         clear_output(wait=True)
        #         display(plt.gcf())
        #         plt.imshow(inter[:,:,value],interpolation=&#39;nearest&#39;)
        #         # l.set_data(inter[:,:,value])
        #         kwargs[&#39;bodytime&#39;]=[self.tmocap[value]]
        #         self._show3(**kwargs)
        #         myu.inotshow(&#39;fig1&#39;,width=200,height=200,magnification=1)
        #         # slax.set_title(&#39;t=&#39;+str(time[val]),loc=&#39;left&#39;)
        #         # fig.canvas.draw_idle()
        #     int_range.on_trait_change(update_x, &#39;value&#39;)



        def plus(event):
            sliderx.set_val(sliderx.val +1)
            fig.canvas.draw_idle()
        # if not notebook:
        sliderx.on_changed(update_x)


        def minus(event):
            sliderx.set_val(sliderx.val -1)
            fig.canvas.draw_idle()
        # if not notebook:
        sliderx.on_changed(update_x)

        def pplus(event):
            sliderx.set_val(sliderx.val +10)
            fig.canvas.draw_idle()
        # if not notebook:
        sliderx.on_changed(update_x)


        def mminus(event):
            sliderx.set_val(sliderx.val -10)
            fig.canvas.draw_idle()
        # if not notebook:
        sliderx.on_changed(update_x)

        # #QUIT by pressing &#39;q&#39;
        # def press(event):
        #     if event.key == &#39;q&#39;:
        #         mlab.close(mayafig)
        #         plt.close(fig)
        # fig.canvas.mpl_connect(&#39;key_press_event&#39;, press)

        # if not notebook:
        #-1 frame axes
        axm = plt.axes([0.3, 0.05, 0.1, 0.075])
        bm = Button(axm, &#39;-1&#39;)
        bm.on_clicked(minus)

        #+1 frame axes
        axp = plt.axes([0.7, 0.05, 0.1, 0.075])
        bp = Button(axp, &#39;+1&#39;)
        bp.on_clicked(plus)

        #-10 frames axes
        axmm = plt.axes([0.1, 0.05, 0.1, 0.075])
        bmm = Button(axmm, &#39;-10&#39;)
        bmm.on_clicked(mminus)

        #+10 frames axes
        axpp = plt.axes([0.9, 0.05, 0.1, 0.075])
        bpp = Button(axpp, &#39;+10&#39;)
        bpp.on_clicked(pplus)



        plt.show()</div>




    def _distancematrix(self):
        &quot;&quot;&quot;Compute the ditance matrix between the nodes

            self.dist : (nb frame x nb_node x nb_node)
            self.dist_nodesmap : list of used nodes (useful to make the association ;) )
        &quot;&quot;&quot;

        if not isinstance(self.B,dict):
            B={self.subject[0]:self.B}
        else :
            B=self.B


        bn= []

        for b in B:
            if &#39;dev&#39; in dir(B[b]):
                tdev=[]
                for k in B[b].dev:
                    bn.append(k)
                    tdev.append(B[b].dev[k][&#39;uc3d&#39;][0])
                tdev=np.array(tdev)
                try:
                    pnb = np.concatenate((pnb,B[b]._f[:,tdev,:]),axis=1)
                except:
                    pnb = B[b]._f[:,tdev,:]
        ln = []
        uin = []

        # infrastructure nodes
        if (&#39;HK&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
            uin.extend([&#39;HKB:1&#39;,&#39;HKB:2&#39;,&#39;HKB:3&#39;,&#39;HKB:4&#39;])
        if (&#39;TCR&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
            # TCR:31 is the coordinator (1.7719,-3.26)
            uin.extend([&#39;TCR:32&#39;,&#39;TCR:24&#39;,&#39;TCR:27&#39;,&#39;TCR:28&#39;,&#39;TCR:31&#39;])
        if self.day == 12:
            if (&#39;BS&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
                uin.extend([&#39;BS:74&#39;,&#39;BS:157&#39;])
        ln = uin + bn
        pin = np.array([self.din[d][&#39;p&#39;] for d in uin])
        pin2 = np.empty((pnb.shape[0],pin.shape[0],pin.shape[1]))
        pin2[:,:,:] = pin
        p = np.concatenate((pin2,pnb),axis=1)
        self.points = p
        self.dist = np.sqrt(np.sum((p[:,:,np.newaxis,:]-p[:,np.newaxis,:,:])**2,axis=3))
        self.dist_nodesmap = ln


    def _computedistdf(self):
        &quot;&quot;&quot;Compute the distance dataframe from distance matrix
        &quot;&quot;&quot;

        # HIKOB
        if (&#39;HK&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
            devmap = {self.devmapper(k,&#39;hkb&#39;)[0]:self.devmapper(k,&#39;hkb&#39;)[2] for k in self.dHKB}
            udev = np.array([[self.dist_nodesmap.index(devmap[k.split(&#39;-&#39;)[0]]),self.dist_nodesmap.index(devmap[k.split(&#39;-&#39;)[1]])] for k in self.hkb.keys()])
            iudev =np.array([(self.dist_nodesmap[u[0]]+&#39;-&#39;+self.dist_nodesmap[u[1]]) for u in udev])
            df = pd.DataFrame(self.dist[:,udev[:,0],udev[:,1]],columns=iudev,index=self.tmocap)

        # BE Spoon
        if (&#39;BS&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
            devmap = {self.devmapper(k,&#39;BS&#39;)[0]:self.devmapper(k,&#39;BS&#39;)[2] for k in self.dBS}
            udev = np.array([[self.dist_nodesmap.index(devmap[k.split(&#39;-&#39;)[0]]),self.dist_nodesmap.index(devmap[k.split(&#39;-&#39;)[1]])] for k in self.bespo.keys()])
            iudev =np.array([(self.dist_nodesmap[u[0]]+&#39;-&#39;+self.dist_nodesmap[u[1]]) for u in udev])
            dfb = pd.DataFrame(self.dist[:,udev[:,0],udev[:,1]],columns=iudev,index=self.tmocap)
            df = df.join(dfb)
            del dfb

        if (&#39;TCR&#39; in self.typ) or (&#39;FULL&#39; in self.typ):
            devmap = {self.devmapper(k,&#39;tcr&#39;)[0]:self.devmapper(k,&#39;tcr&#39;)[2] for k in self.dTCR}
            udev = np.array([[self.dist_nodesmap.index(devmap[k.split(&#39;-&#39;)[0]]),
                              self.dist_nodesmap.index(devmap[k.split(&#39;-&#39;)[1]])]
                             for k in self.tcr.keys() ])
            #                 for k in self.tcr.keys() if not &#39;COORD&#39; in k])
            iudev =np.array([(self.dist_nodesmap[u[0]]+&#39;-&#39;+self.dist_nodesmap[u[1]]) for u in udev])
            dft = pd.DataFrame(self.dist[:,udev[:,0],udev[:,1]],columns=iudev,index=self.tmocap)
            if (&#39;FULL&#39; in self.typ):
                df = df.join(dft)
            else :
                df = dft
            del dft

        self.distdf=df

    # def accessdm(self,a,b,techno=&#39;&#39;):
    #     &quot;&quot;&quot; access to the distance matrix

    #         give name|id of node a and b and a given techno. retrun Groung truth
    #         distance between the 2 nodes
    #     # &quot;&quot;&quot;

    #     # a,ia,bia,subja=self.devmapper(a,techno)
    #     # b,ib,bib,subjb=self.devmapper(b,techno)

    #     if &#39;HKB&#39; in techno :
    #         if isinstance(a,str):
    #             ia = self.dHKB[a]
    #         else:
    #             ia = a
    #             a = self.idHKB[a]

    #         if isinstance(b,str):
    #             ib = self.dHKB[b]
    #         else:
    #             ib = b
    #             b = self.idHKB[b]

    #     elif &#39;TCR&#39; in techno :
    #         if isinstance(a,str):
    #             ia = self.dTCR[a]
    #         else:
    #             ia = a
    #             a = self.idTCR[a]

    #         if isinstance(b,str):
    #             ib = self.dTCR[b]
    #         else:
    #             ib = b
    #             b = self.idTCR[b]

    #     else :
    #         raise AttributeError(&#39;please give only 1 techno or radio node&#39;)

    #     ka = techno+&#39;:&#39;+str(ia)
    #     kb = techno+&#39;:&#39;+str(ib)

    #     ua = self.dist_nodesmap.index(ka)
    #     ub = self.dist_nodesmap.index(kb)

    #     return(ua,ub)





        # c3ds = self.B._f.shape
        # if &#39;Full&#39; in self.typ:
        #     pdev= np.empty((c3ds[0],len(self.dHKB)+len(self.tcr)+len(bs),3))
        # elif &#39;HK&#39; in self.typ:
        #     pdev= np.empty((c3ds[0],len(self.dHKB)+len(bs),3))
        # elif &#39;TCR&#39; in self.typ:
        #     pdev= np.empty((c3ds[0],len(self.tcr),3))
        # else:
        #     raise AttributeError(&#39;invalid self.typ&#39;)

        # self.B.network()
        # DB = self.B.D2

        # ludev = np.array([[i,self.B.dev[i][&#39;uc3d&#39;][0]] for i in self.B.dev])
        # for i in ludev:
        #     pdev[:,eval(i[0])-1,:] = self.B._f[:,i[1],:]
        # # self.dist = np.sqrt(np.sum((mpts[:,np.newaxis,:]-mpts[np.newaxis,:])**2,axis=2))


<div class="viewcode-block" id="CorSer.vlc"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.vlc">[docs]</a>    def vlc(self):
        &quot;&quot;&quot; play video of the associated serie
        &quot;&quot;&quot;
        videofile = os.path.join(self.rootdir,&#39;POST-TREATED&#39;, str(self.day)+&#39;-06-2014&#39;,&#39;Videos&#39;)
        ldir = os.listdir(videofile)
        luldir = map(lambda x : self._filename in x,ldir)

        try:
            uldir = luldir.index(True)
            _filename = ldir[uldir]
            filename = os.path.join(videofile,_filename)
            os.system(&#39;vlc &#39;+filename +&#39;&amp;&#39; )
        except:
            raise AttributeError(&#39;file &#39;+ self._filename + &#39; not found&#39;)</div>


<div class="viewcode-block" id="CorSer.snapshot"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.snapshot">[docs]</a>    def snapshot(self,t0=0,offset=15.5,title=True,save=False,fig=[],ax=[],figsize=(10,10)):
        &quot;&quot;&quot; single snapshot plot

        Parameters
        ----------

        t0: float
        offset : float
        title : boolean
        save : boolean
        fig
        ax
        figsize : tuple

        Examples
        --------


        &quot;&quot;&quot;

        if fig ==[]:
            fig=plt.figure(figsize=figsize)
        if ax == []:
            ax = fig.add_subplot(111)

        if &#39;video_sec&#39; in self.offset[self._filename]:
            offset = self.offset[self._filename][&#39;video_sec&#39;]
        elif offset != &#39;&#39;:
            offset = offset
        else:
            offset=0

        videofile = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,str(self.day)+&#39;-06-2014&#39;,&#39;Videos&#39;)
        ldir = os.listdir(videofile)
        luldir = map(lambda x : self._filename in x,ldir)
        uldir = luldir.index(True)
        _filename = ldir[uldir]
        filename = os.path.join(videofile,_filename)
        vc = VideoFileClip(filename)
        F0 = vc.get_frame(t0+offset)
        I0 = img_as_ubyte(F0)
        ax.imshow(F0)
        if title:
            ax.set_title(&#39;t = &#39;+str(t0)+&#39;s&#39;)
        if save :
            plt.savefig(self._filename +&#39;_&#39;+str(t0) + &#39;_snap.png&#39;,format=&#39;png&#39;)

        return fig,ax</div>


<div class="viewcode-block" id="CorSer.snapshots"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.snapshots">[docs]</a>    def snapshots(self,t0=0,t1=10,offset=15.5):
        &quot;&quot;&quot; take snapshots 

        Parameters
        ----------

        t0 : float
        t1 : float

        &quot;&quot;&quot;

        if &#39;video_sec&#39; in self.offset[self._filename]:
            offset = self.offset[self._filename][&#39;video_sec&#39;]
        elif offset != &#39;&#39;:
            offset = offset
        else:
            offset=0


        videofile = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,str(self.day)+&#39;-06-2014&#39;,&#39;Videos&#39;)
        ldir = os.listdir(videofile)
        luldir = [ self._filename in x for x in ldir ] 
        uldir = luldir.index(True)
        _filename = ldir[uldir]
        filename = os.path.join(videofile,_filename)
        vc = VideoFileClip(filename)
        F0 = vc.get_frame(t0+offset)
        F1 = vc.get_frame(t1+offset)
        I0 = img_as_ubyte(F0)
        I1 = img_as_ubyte(F1)
        plt.subplot(121)
        plt.imshow(F0)
        plt.title(&#39;t = &#39;+str(t0)+&#39;s&#39;)
        plt.subplot(122)
        plt.imshow(F1)
        plt.title(&#39;t = &#39;+str(t1)+&#39;s&#39;)</div>


    def _show3(self,**kwargs):
        &quot;&quot;&quot; mayavi 3d show of scenario

        Parameters
        ----------

        L : boolean
            display layout (True)

        body :boolean
            display bodytime(True)
        bodyname : boolean
            display body name
        bodytime: list
            list of time instant where body topos has to be shown


        devsize : float
            device on body size (100)
        devlist : list
            list of device name to show on body
        pattern : boolean
            display devices pattern

        trajectory : boolean
            display trajectory  (True)
        tagtraj : boolean
            tag on trajectory at the &#39;bodytime&#39; instants (True)
        tagname : list
            name of the tagtrajs
        tagpoffset : ndarray
            offset of the tag positions (nb_of_tags x 3)
        fontsizetag : float
            size of the tag names


        inodes : boolean
            display infrastructure nodes
        inname : boolean
            display infra strucutre node name
        innamesize : float,
            size of name of infrastructure nodes (0.1)
        incolor: str
            color of infrastructure nodes (&#39;r&#39;)
        insize
            size of infrastructure nodes (0.1)


        camera : boolean
            display Vicon camera position (True)
        cameracolor : str
            color of camera nodes (&#39;b&#39;)
        camerasize  : float
            size of camera nodes (0.1)

        Examples
        --------

            &gt;&gt;&gt; S  = Corser(6)
            &gt;&gt;&gt; S._show3()



        &quot;&quot;&quot;
        defaults = { &#39;L&#39;:True,
                     &#39;body&#39;:True,
                     &#39;bodyname&#39;:True,
                     &#39;subject&#39;:[],
                     &#39;interf&#39;:True,
                     &#39;trajectory&#39; :False,
                     &#39;trajectory_list&#39; :[],
                     &#39;devsize&#39;:100,
                     &#39;devlist&#39;:[],
                     &#39;pattern&#39;:False,
                     &#39;inodes&#39; : True,
                     &#39;inname&#39; : True,
                     &#39;innamesize&#39; : 0.1,
                     &#39;incolor&#39; : &#39;r&#39;,
                     &#39;insize&#39; : 0.1,
                     &#39;camera&#39;:True,
                     &#39;cameracolor&#39; :&#39;k&#39;,
                     &#39;camerasize&#39; :0.1,
                     &#39;bodytime&#39;:[],
                     &#39;tagtraj&#39;:True,
                     &#39;tagname&#39;:[],
                     &#39;tagpoffset&#39;:[],
                     &#39;fontsizetag&#39;:0.1,
                     &#39;trajectory_color_range&#39;:True,
                     &#39;trajectory_linewidth&#39;:0.01
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        cold = pyu.coldict()
        camhex = cold[kwargs[&#39;cameracolor&#39;]]
        cam_color = tuple(pyu.rgb(camhex)/255.)
        inhex = cold[kwargs[&#39;incolor&#39;]]
        in_color = tuple(pyu.rgb(inhex)/255.)

        if kwargs[&#39;subject&#39;] == []:
            subject = self.subject
        else:
            subject = kwargs[&#39;subject&#39;]

        if kwargs[&#39;L&#39;]:
            self.L._show3(opacity=0.5)
        v = self.din.items()
        if kwargs[&#39;inodes&#39;]:
            X= np.array([v[i][1][&#39;p&#39;] for i in range(len(v))])
            mlab.points3d(X[:,0],X[:,1], X[:,2],scale_factor=kwargs[&#39;insize&#39;],color=in_color)
            if kwargs[&#39;pattern&#39;]:
                for i in range(len(v)):
                    if not hasattr(self.din[v[i][0]][&#39;ant&#39;],&#39;SqG&#39;):
                        self.din[v[i][0]][&#39;ant&#39;].eval()
                    self.din[v[i][0]][&#39;ant&#39;]._show3(po=v[i][1][&#39;p&#39;],
                           T=self.din[v[i][0]][&#39;T&#39;],
                           ilog=False,
                           minr=0.01,
                           maxr=0.2,
                           newfig=False,
                           title=False,
                           colorbar=False,
                           )

        if kwargs[&#39;inname&#39;]:
            [mlab.text3d(v[i][1][&#39;p&#39;][0],
                        v[i][1][&#39;p&#39;][1],
                        v[i][1][&#39;p&#39;][2]+v[i][1][&#39;s3off&#39;],
                        v[i][0],
                        scale=kwargs[&#39;innamesize&#39;],color=in_color) for i in range(len(v))]
        if kwargs[&#39;body&#39;]:

            if kwargs[&#39;bodytime&#39;]==[]:
                time =np.linspace(0,self.B[subject[0]].time[-1],5).astype(int)
                # time=range(10,100,20)
            else :
                time=kwargs[&#39;bodytime&#39;]

            for ki, i in enumerate(time):
                for ib,b in enumerate(subject):
                    self.B[b].settopos(t=i,cs=True)
                    self.B[b]._show3(dev=True,
                                    name = kwargs[&#39;bodyname&#39;],
                                    devlist=kwargs[&#39;devlist&#39;],
                                    devsize=kwargs[&#39;devsize&#39;],
                                    tube_sides=12,
                                    pattern=kwargs[&#39;pattern&#39;])
                    if kwargs[&#39;tagtraj&#39;]:
                        X=self.B[b].traj[[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]].values[self.B[b].toposFrameId]
                        if kwargs[&#39;tagpoffset&#39;]==[]:
                            X[2]=X[2]+0.2
                        else :
                            X=X+kwargs[&#39;tagpoffset&#39;][ki]
                        if kwargs[&#39;tagname&#39;]==[]:
                            name = &#39;t=&#39;+str(i)+&#39;s&#39;
                        else :
                            name = str(kwargs[&#39;tagname&#39;][ki])
                        mlab.text3d(X[0],X[1],X[2],name,scale=kwargs[&#39;fontsizetag&#39;])
                if kwargs[&#39;interf&#39;]:
                    for ib,b in enumerate(self.interf):
                        self.B[b].settopos(t=i,cs=True)
                        self.B[b]._show3(name=kwargs[&#39;bodyname&#39;],tube_sides=12)

        if kwargs[&#39;trajectory&#39;]:
            if kwargs[&#39;trajectory_list&#39;]==[]:
                tr_subject = subject
            else:
                tr_subject = kwargs[&#39;trajectory_list&#39;]

            for b in tr_subject:
                self.B[b].traj._show3(color_range=kwargs[&#39;trajectory_color_range&#39;],
                                      linewidth=kwargs[&#39;trajectory_linewidth&#39;])
        if kwargs[&#39;camera&#39;] :
            mlab.points3d(self.cam[:,0],self.cam[:,1], self.cam[:,2],scale_factor=kwargs[&#39;camerasize&#39;],color=cam_color)
        mlab.view(-111.44127634143871,
                    60.40674368088245,
                    24.492297713984197,
                    array([-0.07235499,  0.04868631, -0.00314969]))
        mlab.view(-128.66519195313163,
                   50.708933839573511,
                   24.492297713984247,
                   np.array([-0.07235499,  0.04868631, -0.00314969]))

<div class="viewcode-block" id="CorSer.anim"><a class="viewcode-back" href="../../../api/pylayers.measures.cormoran.CorSer.html#pylayers.measures.cormoran.CorSer.anim">[docs]</a>    def anim(self):

        self._show3(body=False,inname=False,trajectory=False)
        [self.B[b].anim() for b in self.B]

        mlab.view(-43.413544538477254,
                    74.048193730704611,
                    11.425837641867618,
                    array([ 0.48298163,  0.67806043,  0.0987967 ]))</div>


<div class="viewcode-block" id="CorSer.imshow"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.imshow">[docs]</a>    def imshow(self,time=100,kind=&#39;time&#39;):
        &quot;&quot;&quot; DEPRECATED

        Parameters
        ----------

        kind : string

            &#39;mean&#39;,&#39;std&#39;
        &quot;&quot;&quot;
        fig = plt.figure(figsize=(10,10))
        self.D = self.rssi-self.rssi.swapaxes(0,1)

        try:
            timeindex = np.where(self.thkb[0]-time&gt;0)[0][0]
        except:
            timeindex = np.where(self.thkb-time&gt;0)[0][0]
        if kind==&#39;time&#39;:
            dt1 = self.rssi[:,:,timeindex]
            dt2 = self.D[:,:,timeindex]

        if kind == &#39;mean&#39;:
            dt1 = ma.masked_invalid(self.rssi).mean(axis=2)
            dt2 = ma.masked_invalid(self.D).mean(axis=2)

        if kind == &#39;std&#39;:
            dt1 = ma.masked_invalid(self.rssi).std(axis=2)
            dt2 = ma.masked_invalid(self.D).std(axis=2)

        ax1 = fig.add_subplot(121)
        #img1 = ax1.imshow(self.rssi[:,:,timeindex],interpolation=&#39;nearest&#39;,origin=&#39;lower&#39;)
        img1 = ax1.imshow(dt1,interpolation=&#39;nearest&#39;)
        labels = [ self.idHKB[x] for x in range(1,17)] 
        plt.xticks(range(16),labels,rotation=80,fontsize=14)
        plt.yticks(range(16),labels,fontsize=14)
        if kind==&#39;time&#39;:
            plt.title(&#39;t = &#39;+str(time)+ &#39; s&#39;)
        if kind==&#39;mean&#39;:
            plt.title(u&#39;$mean(\mathbf{L})$&#39;)
        if kind==&#39;std&#39;:
            plt.title(u&#39;$std(\mathbf{L})$&#39;)
        divider = make_axes_locatable(ax1)
        cax1 = divider.append_axes(&quot;right&quot;, size=&quot;5%&quot;, pad=0.05)
        clb1 = fig.colorbar(img1,cax1)
        clb1.set_label(&#39;level dBm&#39;,fontsize=14)
        ax2 = fig.add_subplot(122)
        #img2 = ax2.imshow(self.D[:,:,timeindex],interpolation=&#39;nearest&#39;,origin=&#39;lower&#39;)
        img2 = ax2.imshow(dt2,interpolation=&#39;nearest&#39;)
        plt.title(u&#39;$\mathbf{L}-\mathbf{L}^T$&#39;)
        divider = make_axes_locatable(ax2)
        plt.xticks(range(16),labels,rotation=80,fontsize=14)
        plt.yticks(range(16),labels,fontsize=14)
        cax2 = divider.append_axes(&quot;right&quot;, size=&quot;5%&quot;, pad=0.05)
        clb2 = fig.colorbar(img2,cax2)
        clb2.set_label(&#39;level dBm&#39;,fontsize=14)
        plt.tight_layout()
        plt.show()
        #for k in range(1,17):
        #    for l in range(1,17):
        #        self.dHKB[(k,l)]=iHKB[k]+&#39; - &#39;+iHKB[l]
        #        cpt = cpt + 1
        return fig,(ax1,ax2)</div>

<div class="viewcode-block" id="CorSer.lk2nd"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.lk2nd">[docs]</a>    def lk2nd(self,lk):
        &quot;&quot;&quot; transcode a lk from Id to real name

        Parameters
        ----------

        lk : string

        Examples
        --------

            &gt;&gt;&gt; C=Corser(6)
            &gt;&gt;&gt; lk = &#39;HKB:15-HKB:7&#39;
            &gt;&gt;&gt; C.lk2nd(lk)
        &quot;&quot;&quot;
        u = lk.replace(&#39;HKB:&#39;,&#39;&#39;).split(&#39;-&#39;)
        v = [ self.idHKB[int(x)] for x in u ]
        return(v)</div>

    def _load_offset_dict(self):
        &quot;&quot;&quot; load offset_dictionnary.bin

        Returns
        -------

        d : dict

        {&#39;Sc20_S5_R1_HKBS&#39;: {&#39;hkb_index&#39;: -148, &#39;video_sec&#39;: 32.622087273809527},
        &#39;Sc20_S6_R2_HKBS&#39;: {&#39;bs_index&#39;: -124, &#39;hkb_index&#39;: -157},
        &#39;Sc21a_S13_R1_HKBS&#39;: {&#39;hkb_index&#39;: 537},
        &#39;Sc21a_S14_R2_HKBS&#39;: {&#39;hkb_index&#39;: 752},
        &#39;Sc21a_S15_R3_HKBS&#39;: {&#39;hkb_index&#39;: 438},
        &#39;Sc21a_S16_R4_HKBS&#39;: {&#39;hkb_index&#39;: 224},
        &#39;Sc21b_S21_R1_HKBS&#39;: {&#39;hkb_index&#39;: 368},
        &#39;Sc21b_S22_R2_HKBS&#39;: {&#39;hkb_index&#39;: -333},
        &#39;Sc21b_S23_R3_HKBS&#39;: {&#39;hkb_index&#39;: 136},
        &#39;Sc22a_S9_R1_Full&#39;: {&#39;hkb_index&#39;: 678}}

        Notes
        -----

        This is used for synchronization purpose

        &quot;&quot;&quot;

        path = os.path.join(os.environ[&#39;CORMORAN&#39;],&#39;POST-TREATED&#39;)
        d = pickle.load( open( os.path.join(path,&#39;offset_dictionnary.bin&#39;), &quot;rb&quot; ) )

        return d

    def _save_offset_dict(self,d):

        path = os.path.join(os.environ[&#39;CORMORAN&#39;],&#39;POST-TREATED&#39;)
        d = pickle.dump( d, open( os.path.join(path,&#39;offset_dictionnary.bin&#39;), &quot;wb&quot; ) )

    def _save_data_off_dict(self,filename,typ,value):
        &quot;&quot;&quot; save
                - a given &quot;value&quot; of an for,
                - a serie/run &quot;filename&quot;,
                - of a given typ (video|hkb|tcr|...)
        &quot;&quot;&quot;

        d = self._load_offset_dict()
        try:
            d[filename].update({typ:value})
        except:
            d[filename]={}
            d[filename][typ]=value
        self._save_offset_dict(d)


<div class="viewcode-block" id="CorSer.offset_setter_video"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.offset_setter_video">[docs]</a>    def offset_setter_video(self,a=&#39;AP1&#39;,b=&#39;WristRight&#39;,**kwargs):
        &quot;&quot;&quot; video offset setter
        &quot;&quot;&quot;
        defaults = { &#39;inverse&#39;:True
                    }


        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]


        fig, axs = plt.subplots(nrows=2,ncols=1)
        fig.subplots_adjust(bottom=0.3)

        if isinstance(a,str):
            ia = self.dHKB[a]
        else:
            ia = a
            a = self.idHKB[a]

        if isinstance(b,str):
            ib = self.dHKB[b]
        else:
            ib = bq
            b = self.idHKB[b]


        time = self.thkb
        if len(time) == 1:
            time=time[0]


        sab = self.hkb[a+&#39;-&#39;+b].values
        sabt = self.hkb[a+&#39;-&#39;+b].index
        hkb = axs[1].plot(sabt,sab,label = a+&#39;-&#39;+b)
        axs[1].legend()


        try : 
            init = self.offset[self._filename][&#39;video_sec&#39;]
        except:
            init=time[0]


        videofile = os.path.join(self.rootdir,&#39;POST-TREATED&#39;,str(self.day)+&#39;-06-2014&#39;,&#39;Videos&#39;)
        ldir = os.listdir(videofile)
        luldir = [ self._filename in x for x in ldir ]
        uldir = luldir.index(True)
        _filename = ldir[uldir]
        filename = os.path.join(videofile,_filename)
        vc = VideoFileClip(filename)
        F0 = vc.get_frame(init)
        I0 = img_as_ubyte(F0)
        axs[0].imshow(F0)



        ########
        # slider
        ########
        slide_xoffset_ax = plt.axes([0.1, 0.15, 0.8, 0.05])
        sliderx = Slider(slide_xoffset_ax, &quot;video offset&quot;, 0, self.hkb.index[-1],
                        valinit=init, color=&#39;#AAAAAA&#39;)


        # vertc = [(0,-10),(0,-10),(0,10),(0,-10)]
        # poly = plt.Polygon(vertc)
        # pp = axs[1].add_patch(poly)


        def update_x(val):
            F0 = vc.get_frame(val)
            I0 = img_as_ubyte(F0)
            axs[0].imshow(F0)
            fig.canvas.draw_idle()
        sliderx.on_changed(update_x)

        # def cursor(val):
        #     try :
        #         pp.remove()
        #     except:
        #         pass
        #     vertc = [(sabt[0]+val,min(sab)-10),(sabt[0]+val,min(sab)-10),(sabt[0]+val,max(sab)+10),(sabt[0]+val,max(sab)-10)]
        #     poly = plt.Polygon(vertc)
        #     pp = axs[1].add_patch(poly)
        # sliderx.on_changed(cursor)

        def plus(event):
            sliderx.set_val(sliderx.val +0.2)
            fig.canvas.draw_idle()
        sliderx.on_changed(update_x)


        def minus(event):
            sliderx.set_val(sliderx.val -0.2)
            fig.canvas.draw_idle()
        sliderx.on_changed(update_x)


        def setter(event):
            self._save_data_off_dict(self._filename,&#39;video_sec&#39;,sliderx.val)
            self.offset= self._load_offset_dict()
        axp = plt.axes([0.3, 0.05, 0.1, 0.075])
        axset = plt.axes([0.5, 0.05, 0.1, 0.075])
        axm = plt.axes([0.7, 0.05, 0.1, 0.075])

        bp = Button(axp, &#39;&lt;-&#39;)
        bp.on_clicked(minus)

        bset = Button(axset, &#39;SET offs.&#39;)
        bset.on_clicked(setter)

        bm = Button(axm, &#39;-&gt;&#39;)
        bm.on_clicked(plus)

        plt.show()</div>


<div class="viewcode-block" id="CorSer.offset_setter"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.offset_setter">[docs]</a>    def offset_setter(self,a=&#39;HKB:1&#39;,b=&#39;HKB:12&#39;,techno=&#39;&#39;,**kwargs):
        &quot;&quot;&quot; offset setter
        &quot;&quot;&quot;
        defaults = { &#39;inverse&#39;:True
                    }


        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]


        if plt.isinteractive():
            interactive = True
            plt.ioff()
        else :
            interactive = False

        fig, ax = plt.subplots()
        fig.subplots_adjust(bottom=0.2, left=0.3)

        a,ia,bia,subja,techno=self.devmapper(a,techno)
        b,ib,bib,subjb,techno=self.devmapper(b,techno)


        time = self.tmocap
        if len(time.shape) == 2:
            time = time[0,:]


        try : 
            init = time[0]#self.offset[self._filename][&#39;hkb_index&#39;]
        except:
            init=time[0]


        var = self.getlinkd(ia,ib,techno).values
        if kwargs[&#39;inverse&#39;]:
            var = 10*np.log10(1./(var)**2)
        gt = ax.plot(time,var)


        ab = self.getlink(ia,ib,techno)
        sab = ab.values
        sabt = ab.index.values
        technoval = ax.plot(sabt,sab)


        ########
        # slider
        ########
        slide_xoffset_ax = plt.axes([0.1, 0.15, 0.8, 0.02])
        sliderx = Slider(slide_xoffset_ax, techno + &quot; offset&quot;, -(len(sabt)/16), (len(sabt)/16),
                        valinit=init, color=&#39;#AAAAAA&#39;)

        slide_yoffset_ax = plt.axes([0.1, 0.10, 0.8, 0.02])
        slidery = Slider(slide_yoffset_ax, &quot;gt_yoff&quot;, -100, 0,
                        valinit=0, color=&#39;#AAAAAA&#39;)

        slide_alpha_ax = plt.axes([0.1, 0.05, 0.8, 0.02])
        slideralpha = Slider(slide_alpha_ax, &quot;gt_alpha&quot;, 0, 60,
                        valinit=30, color=&#39;#AAAAAA&#39;)

        def update_x(val):
            value = int(sliderx.val)
            rtechnoval = np.roll(sab,value)
            sliderx.valtext.set_text(&#39;{}&#39;.format(value))
            technoval[0].set_xdata(sabt)
            technoval[0].set_ydata(rtechnoval)
            fig.canvas.draw_idle()
        sliderx.on_changed(update_x)
        sliderx.drawon = False


        def update_y(val):
            yoff = slidery.val
            alpha = slideralpha.val
            gt[0].set_ydata(alpha*var + yoff)
            fig.canvas.draw_idle()
        #initpurpose
        update_y(5)
        slidery.on_changed(update_y)
        slideralpha.on_changed(update_y)


        def setter(event):
            value = int(sliderx.val)
            try :
                nval = self.offset[self._filename][techno.lower()+&#39;_index&#39;] + value
            except : 
                nval = value
            self._save_data_off_dict(self._filename,techno.lower()+&#39;_index&#39;,nval)
            self.offset= self._load_offset_dict()
            ax.set_title(&#39;WARNING : Please Reload serie to Valide offset change&#39;,color=&#39;r&#39;,weight=&#39;bold&#39;)

        axset = plt.axes([0.0, 0.5, 0.2, 0.05])
        bset = Button(axset, &#39;SET &#39; +techno+&#39; offs.&#39;)
        bset.on_clicked(setter)

        plt.show()
        if interactive :
            plt.ion()</div>


    # def offset_setter_hkb(self,a=&#39;AP1&#39;,b=&#39;WristRight&#39;,**kwargs):
    #     &quot;&quot;&quot; offset setter
    #     &quot;&quot;&quot;
    #     defaults = { &#39;inverse&#39;:True
    #                 }


    #     for k in defaults:
    #         if k not in kwargs:
    #             kwargs[k] = defaults[k]

    #     if plt.isinteractive():
    #         interactive = True
    #         plt.ioff()
    #     else :
    #         interactive = False

    #     fig, ax = plt.subplots()
    #     fig.subplots_adjust(bottom=0.2, left=0.3)

    #     a,ia,bia,subja,techno=self.devmapper(a,&#39;HKB&#39;)
    #     b,ib,bib,subjb,techno=self.devmapper(b,&#39;HKB&#39;)


    #     time = self.thkb
    #     if len(time.shape) == 2:
    #         time = time[0,:]


    #     try : 
    #         init = time[0]#self.offset[self._filename][&#39;hkb_index&#39;]
    #     except:
    #         init=time[0]


    #     var = self.getlinkd(ia,ib,&#39;HKB&#39;).values
    #     if kwargs[&#39;inverse&#39;]:
    #         var = 10*np.log10(1./(var)**2)
    #     gt = ax.plot(self.B[self.B.keys()[0]].time,var)

    #     sab = self.hkb[a+&#39;-&#39;+b].values
    #     sabt = self.hkb[a+&#39;-&#39;+b].index
    #     hkb = ax.plot(sabt,sab)


    #     ########
    #     # slider
    #     ########
    #     slide_xoffset_ax = plt.axes([0.1, 0.15, 0.8, 0.02])
    #     sliderx = Slider(slide_xoffset_ax, &quot;hkb offset&quot;, -(len(sabt)/16), (len(sabt)/16),
    #                     valinit=init, color=&#39;#AAAAAA&#39;)

    #     slide_yoffset_ax = plt.axes([0.1, 0.10, 0.8, 0.02])
    #     slidery = Slider(slide_yoffset_ax, &quot;gt_yoff&quot;, -100, 0,
    #                     valinit=0, color=&#39;#AAAAAA&#39;)

    #     slide_alpha_ax = plt.axes([0.1, 0.05, 0.8, 0.02])
    #     slideralpha = Slider(slide_alpha_ax, &quot;gt_alpha&quot;, 0, 10,
    #                     valinit=5, color=&#39;#AAAAAA&#39;)

    #     def update_x(val):
    #         value = int(sliderx.val)
    #         rhkb = np.roll(sab,value)
    #         sliderx.valtext.set_text(&#39;{}&#39;.format(value))
    #         hkb[0].set_xdata(sabt)
    #         hkb[0].set_ydata(rhkb)
    #         fig.canvas.draw_idle()
    #     sliderx.on_changed(update_x)
    #     sliderx.drawon = False


    #     def update_y(val):
    #         yoff = slidery.val
    #         alpha = slideralpha.val
    #         gt[0].set_ydata(alpha*var + yoff)
    #         fig.canvas.draw_idle()
    #     #initpurpose
    #     update_y(5)
    #     slidery.on_changed(update_y)
    #     slideralpha.on_changed(update_y)


    #     def setter(event):
    #         value = int(sliderx.val)
    #         try :
    #             nval = self.offset[self._filename][&#39;hkb_index&#39;] + value
    #         except : 
    #             nval = value
    #         self._save_data_off_dict(self._filename,&#39;hkb_index&#39;,nval)
    #         self.offset= self._load_offset_dict()
    #         ax.set_title(&#39;WARNING : Please Reload serie to Valide offset change&#39;,color=&#39;r&#39;,weight=&#39;bold&#39;)
    #     axset = plt.axes([0.0, 0.5, 0.2, 0.05])

    #     bset = Button(axset, &#39;SET offs.&#39;)
    #     bset.on_clicked(setter)


    #     plt.show()
    #     if interactive:
    #         plt.ion()


<div class="viewcode-block" id="CorSer.mtlbsave"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.mtlbsave">[docs]</a>    def mtlbsave(self):
        &quot;&quot;&quot; Matlab format save


        S{day}_{serie}
            node_name
            node_place
            node_coord

            HKB.{linkname}.tr
            HKB.{linkname}.rssi
            HKB.{linkname}.td
            HKB.{linkname}.dist
            HKB.{linkname}.sh
            HKB.{linkname}.dsh

            TCR.{linkname}.tr
            HKB.{linkname}.range
            HKB.{linkname}.td
            HKB.{linkname}.dist
            HKB.{linkname}.sh

        &quot;&quot;&quot;
        key = &#39;S&#39;+str(self.day)+&#39;_&#39;+str(self.serie)
        filemat = key+&#39;.mat&#39;
        d = {}
        d[key]={}
        d[key][&#39;node_name&#39;] = self.dist_nodesmap
        d[key][&#39;node_place&#39;] = [ self.devmapper(x)[0] for x in self.dist_nodesmap ]
        d[key][&#39;node_coord&#39;] = self.points

        for subject in self.interf:
            sub = subject.replace(&#39;:&#39;,&#39;&#39;)
            d[key][sub]=np.mean(self.B[subject].d,axis=1)

        if (&#39;HKB&#39; in self.typ.upper()) or (&#39;FULL&#39; in self.typ.upper()):
            d[key][&#39;HKB&#39;]={}
            links = list(self.hkb.columns)
            inter,lks = self.compute_visibility(techno=&#39;HKB&#39;)

            for l in links:
                ls   = l.split(&#39;-&#39;)
                nl = ls[0]+&#39;_&#39;+ls[1]
                nl=nl.replace(&#39;Jihad&#39;,&#39;J&#39;).replace(&#39;Nicolas&#39;,&#39;N&#39;).replace(&#39;Eric&#39;,&#39;E&#39;)
                d[key][&#39;HKB&#39;][nl] = {}
                ix0 = np.where(lks==ls[0])[0]
                ix1 = np.where(lks==ls[1])[0]
                Ssh = inter[ix0,ix1,:]
                Srssi= self.getlink(ls[0],ls[1],techno=&#39;HKB&#39;)
                # get distances between nodes
                Sdist = self.getlinkd(ls[0],ls[1],techno=&#39;HKB&#39;)
                dsh = dist_sh2rssi(Sdist,Ssh,15)
                # rssi
                d[key][&#39;HKB&#39;][nl][&#39;rssi&#39;] = Srssi.values
                # dsh
                d[key][&#39;HKB&#39;][nl][&#39;dsh&#39;] = dsh
                #d[&#39;S6&#39;][nl][&#39;rssi_dec&#39;] = np.roll(Srssi.values,-dec)
                d[key][&#39;HKB&#39;][nl][&#39;sh&#39;] = Ssh
                # time rssi
                #d[key][&#39;HKB&#39;][nl][&#39;trh&#39;] = np.array(Srssi.index)
                d[key][&#39;trh&#39;] = np.array(Srssi.index)
                # distance
                d[key][&#39;HKB&#39;][nl][&#39;dist&#39;] = Sdist.values
                # time mocap
                #d[key][&#39;HKB&#39;][nl][&#39;td&#39;] = np.array(Sdist.index)
                d[key][&#39;tm&#39;] = np.array(Sdist.index)

        if (&#39;TCR&#39; in self.typ.upper()) or (&#39;FULL&#39; in self.typ.upper()):
            d[key][&#39;TCR&#39;]={}
            links = list(self.tcr.columns)
            inter,lks = self.compute_visibility(techno=&#39;TCR&#39;)
            for l in links:
                ls   = l.split(&#39;-&#39;)
                # to shorten matlab keys surname are replaced by first letter
                nl = ls[0]+&#39;_&#39;+ls[1]
                nl=nl.replace(&#39;Jihad&#39;,&#39;J&#39;).replace(&#39;Nicolas&#39;,&#39;N&#39;).replace(&#39;Eric&#39;,&#39;E&#39;)
                d[key][&#39;TCR&#39;][nl] = {}
                ix0 = np.where(lks==ls[0])[0]
                ix1 = np.where(lks==ls[1])[0]
                # intersection on the link
                Ssh = inter[ix0,ix1,:]
                Srange= self.getlink(ls[0],ls[1],techno=&#39;TCR&#39;)
                # get distances between nodes
                Sdist = self.getlinkd(ls[0],ls[1],techno=&#39;TCR&#39;)
                # rssi
                d[key][&#39;TCR&#39;][nl][&#39;range&#39;] = Srange.values
                # dsh
                #d[&#39;S6&#39;][nl][&#39;rssi_dec&#39;] = np.roll(Srssi.values,-dec)
                d[key][&#39;TCR&#39;][nl][&#39;sh&#39;] = Ssh
                # time rssi
                #d[key][&#39;TCR&#39;][nl][&#39;tr&#39;] = np.array(Srange.index)
                d[key][&#39;trt&#39;] = np.array(Srange.index)
                # distance
                d[key][&#39;TCR&#39;][nl][&#39;dist&#39;] = Sdist.values
                # time mocap
                #d[key][&#39;TCR&#39;][nl][&#39;td&#39;] = np.array(Sdist.index)
                d[key][&#39;tm&#39;] = np.array(Sdist.index)

        self.matlab = d
        io.savemat(filemat,d)</div>





<div class="viewcode-block" id="CorSer.pltvisi"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.pltvisi">[docs]</a>    def pltvisi(self,a,b,techno=&#39;&#39;,**kwargs):
        &quot;&quot;&quot; plot visibility between link a and b


        Attributes
        ----------
        color:
            fill color
        hatch:
            hatch type
        label_pos: (&#39;top&#39;|&#39;bottom&#39;|&#39;&#39;)
            postion of the label
        label_pos_off: float
            offset of postion of the label
        label_mob: str
            prefix of label in mobility
        label_stat: str
            prefix of label static


        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S = CorSer(6)
        &gt;&gt;&gt; f,ax = S.plthkb(&#39;AP1&#39;,&#39;TorsoTopLeft&#39;,techno=&#39;HKB&#39;)
        &gt;&gt;&gt; f,ax = S.pltvisi(&#39;AP1&#39;,&#39;TorsoTopLeft&#39;,techno=&#39;HKB&#39;,fig=f,ax=ax)
        &gt;&gt;&gt; f,ax = S.pltmob(fig=f,ax=ax)
        &gt;&gt;&gt; plt.title(&#39;hatch = visibility / gray= mobility&#39;)
        &gt;&gt;&gt; plt.show()
        &quot;&quot;&quot;


        defaults = { &#39;fig&#39;:[],
                     &#39;figsize&#39;:(10,10),
                     &#39;ax&#39;:[],
                     &#39;color&#39;:&#39;&#39;,
                     &#39;hatch&#39;:&#39;//&#39;,
                     &#39;label_pos&#39;:&#39;&#39;,
                     &#39;label_pos_off&#39;:5,
                     &#39;label_vis&#39;:&#39;V&#39;,
                     &#39;label_hide&#39;:&#39;H&#39;
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        if kwargs[&#39;fig&#39;]==[]:
            fig = plt.figure(figsize=kwargs[&#39;figsize&#39;])
        else :
            fig=kwargs[&#39;fig&#39;]

        if kwargs[&#39;ax&#39;] ==[]:
            ax = fig.add_subplot(111)
        else :
            ax = kwargs[&#39;ax&#39;]



        aa= ax.axis()

        a,ia,nna,subjecta,technoa = self.devmapper(a,techno)
        b,ib,nnb,subjectb,technob = self.devmapper(b,techno)
        vv,tv,tseg,itseg = self._visiarray(nna,nnb)
        # vv.any : it exist NLOS regions
        if vv.any():
            if kwargs[&#39;color&#39;]==&#39;&#39;:
                fig,ax=plu.rectplot(tv,tseg,ylim=aa[2:],
                                    fill=False,
                                    hatch=kwargs[&#39;hatch&#39;],
                                    fig=fig,ax=ax)

            else :
                fig,ax=plu.rectplot(tv,tseg,ylim=aa[2:],
                                    color=kwargs[&#39;color&#39;],
                                    hatch=kwargs[&#39;hatch&#39;],
                                    fig=fig,ax=ax)

            if kwargs[&#39;label_pos&#39;]!=&#39;&#39;:
                if kwargs[&#39;label_pos&#39;] == &#39;top&#39;:
                    yposV = aa[3]-kwargs[&#39;label_pos_off&#39;]+0.5
                    yposH = aa[3]-kwargs[&#39;label_pos_off&#39;]-0.5

                elif kwargs[&#39;label_pos&#39;] == &#39;bottom&#39;:
                    yposV = aa[2]+kwargs[&#39;label_pos_off&#39;]+0.5
                    yposH = aa[2]+kwargs[&#39;label_pos_off&#39;]+0.5
                xposV= tv[tseg.mean(axis=1).astype(int)]
                xposH= tv[itseg.mean(axis=1).astype(int)]
                [ax.text(x,yposV,kwargs[&#39;label_vis&#39;]+str(ix+1)) for ix,x in enumerate(xposV)]
                [ax.text(x,yposH,kwargs[&#39;label_hide&#39;]+str(ix+1)) for ix,x in enumerate(xposH)]

        return fig,ax</div>

<div class="viewcode-block" id="CorSer.pltmob"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.pltmob">[docs]</a>    def pltmob(self,**kwargs):
        &quot;&quot;&quot; plot mobility

        Parameters
        ----------
        subject: str
            subject to display () if &#39;&#39;, take the fist one from self.subject)
        showvel :  boolean
            display filtered velocity
        velth: float (0.7)
            velocity threshold
        fo : int (5)
            filter order
        fw: float (0.02)
            0 &lt; fw &lt; 1  (fN &lt;=&gt; 1)
        time_offset : int
            add time_offset to start later

        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S = CorSer(6)
        &gt;&gt;&gt; f,ax = S.plthkb(&#39;AP1&#39;,&#39;TorsoTopLeft&#39;,techno=&#39;HKB&#39;)
        &gt;&gt;&gt; #f,ax = S.pltvisi(&#39;AP1&#39;,&#39;TorsoTopLeft&#39;,techno=&#39;HKB&#39;,fig=f,ax=ax)
        &gt;&gt;&gt; f,ax = S.pltmob(fig=f,ax=ax)
        &gt;&gt;&gt; plt.title(&#39;hatch = visibility / gray= mobility&#39;)
        &gt;&gt;&gt; plt.show()
        &quot;&quot;&quot;
        defaults = { &#39;subject&#39;:&#39;&#39;,
                    &#39;fig&#39;:[],
                    &#39;figsize&#39;:(10,10),
                     &#39;ax&#39;:[],
                     &#39;showvel&#39;:False,
                     &#39;velth&#39;:0.07,
                     &#39;fo&#39;:5,
                     &#39;fw&#39;:0.02,
                     &#39;ylim&#39;:(),
                     &#39;time_offset&#39;:0,
                     &#39;color&#39;:&#39;gray&#39;,
                     &#39;hatch&#39;:&#39;&#39;,
                     &#39;label_pos&#39;:&#39;top&#39;,
                     &#39;label_pos_off&#39;:2,
                     &#39;label_mob&#39;:&#39;M&#39;,
                     &#39;label_stat&#39;:&#39;S&#39;
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        if kwargs[&#39;fig&#39;]==[]:
            fig = plt.figure(figsize=kwargs[&#39;figsize&#39;])
        else :
            fig=kwargs[&#39;fig&#39;]

        if kwargs[&#39;ax&#39;] ==[]:
            ax = fig.add_subplot(111)
        else :
            ax = kwargs[&#39;ax&#39;]

        if kwargs[&#39;subject&#39;]==&#39;&#39;:
            subject=self.B.keys()[0]
        else:
            subject=kwargs[&#39;subject&#39;]

        V=self.B[subject].traj[[&#39;vx&#39;,&#39;vy&#39;]].values
        Vi=np.sqrt((V[:,0]**2+V[:,1]**2))
        f=DF()
        f.butter(kwargs[&#39;fo&#39;],kwargs[&#39;fw&#39;],&#39;lowpass&#39;)
        Vif=f.filter(Vi)

        if kwargs[&#39;time_offset&#39;]&gt;=0:
            zmo = np.zeros(kwargs[&#39;time_offset&#39;])
            tmp = np.insert(Vif,zmo,0)
            Vif = tmp[:len(Vif)]
        else:
            zmo = np.zeros(-kwargs[&#39;time_offset&#39;])
            tmp = np.concatenate((Vif,zmo))
            Vif = tmp[-kwargs[&#39;time_offset&#39;]:len(Vif)-kwargs[&#39;time_offset&#39;]]


        if kwargs[&#39;showvel&#39;]:
            fig2 = plt.figure()
            ax2=fig2.add_subplot(111)
            ax2.plot(self.B[subject].time[:-2],Vif)
            ax2.plot(Vif)
            cursor2 = Cursor(ax2, useblit=True, color=&#39;gray&#39;, linewidth=1)

        null = np.where(Vif&lt;kwargs[&#39;velth&#39;])[0]
        unu1 = np.where(np.diff(null)!=1)[0]
        unu2 = np.where(np.diff(null[::-1])!=-1)[0]
        unu2 = len(null)-unu2
        unu = np.concatenate((unu1,unu2))
        unu = np.sort(unu)
        sunu = unu.shape
        if sunu[0]%2:
            unu=np.insert(unu,-1,len(null)-1)
            sunu = unu.shape
        nullr=null[unu].reshape(sunu[0]/2,2)

        if kwargs[&#39;ylim&#39;] != ():
            ylim = kwargs[&#39;ylim&#39;]
        else :
            axlim = ax.axis()
            ylim = [axlim[2],axlim[3]]


        fig , ax =plu.rectplot(self.B[subject].time,nullr,ylim=ylim,
                                color=kwargs[&#39;color&#39;],
                                hatch=kwargs[&#39;hatch&#39;],
                                fig=fig,ax=ax)


        inullr = copy.copy(nullr)
        bb = np.insert(inullr[:,1],0,0)
        ee = np.hstack((inullr[:,0],null[-1]))
        inullr = np.array((bb,ee)).T
        # remove last
        inullr = inullr[:-1,:]

        if kwargs[&#39;label_pos&#39;]!=&#39;&#39;:
            if kwargs[&#39;label_pos&#39;] == &#39;top&#39;:
                yposM = ylim[1]-kwargs[&#39;label_pos_off&#39;]+0.5
                yposS = ylim[1]-kwargs[&#39;label_pos_off&#39;]-0.5

            elif kwargs[&#39;label_pos&#39;] == &#39;bottom&#39;:
                yposM = ylim[0]+kwargs[&#39;label_pos_off&#39;]+0.5
                yposS = ylim[0]+kwargs[&#39;label_pos_off&#39;]+0.5
            xposM= self.B[subject].time[nullr.mean(axis=1).astype(int)]
            xposS= self.B[subject].time[inullr.mean(axis=1).astype(int)]
            [ax.text(x,yposM,kwargs[&#39;label_mob&#39;]+str(ix+1),
                        horizontalalignment=&#39;center&#39;,
                        verticalalignment=&#39;center&#39;)
                        for ix,x in enumerate(xposM)]
            [ax.text(x,yposS,kwargs[&#39;label_stat&#39;]+str(ix+1),
                        horizontalalignment=&#39;center&#39;,
                        verticalalignment=&#39;center&#39;)
                        for ix,x in enumerate(xposS)]

        return fig,ax</div>

<div class="viewcode-block" id="CorSer.animhkb"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.animhkb">[docs]</a>    def animhkb(self,a,b,interval=10,save=False):
        &quot;&quot;&quot;
        Parameters
        ----------

        a : node name |number
        b : node name | number
        save : bool
        &quot;&quot;&quot;

        import matplotlib.animation as animation

        x = self.hkb.index
        link = a+&#39;-&#39;+b
        y = self.hkb[link].values

        fig, ax = plt.subplots()
        plt.xlim(0,x[-1])
        line = [ax.plot(x, y, animated=True)[0]]

        def animate(i):
            line[0].set_ydata(y[:i])
            line[0].set_xdata(x[:i])
            return line

        ani = animation.FuncAnimation(fig, animate, xrange(1, len(x)),
                                      interval=interval, blit=True)
        if save:
            ani.save(link+&#39;.mp4&#39;)
        plt.title(link)
        plt.xlabel(&#39;time (s)&#39;)
        plt.ylabel(&#39;RSS (dBm)&#39;)
        plt.show()</div>


<div class="viewcode-block" id="CorSer.animhkbAP"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.animhkbAP">[docs]</a>    def animhkbAP(self,a,AP_list,interval=1,save=False,**kwargs):
        &quot;&quot;&quot;
        Parameters
        ----------

        a : node name
        AP_nb=[]
        save : bool

        Example
        -------
            &gt;&gt;&gt; from pylayers.measures.cormoran import *
            &gt;&gt;&gt; S = CorSer(6)
            &gt;&gt;&gt; S.animhkbAP(&#39;TorsoTopLeft&#39;,[&#39;AP1&#39;,&#39;AP2&#39;,&#39;AP3&#39;,&#39;AP4&#39;],interval=100,xstart=58,figsize=(20,2))

        &quot;&quot;&quot;
        import matplotlib.animation as animation

        defaults = {   &#39;fig&#39;:[],
                       &#39;figsize&#39;:(10,10),
                        &#39;ax&#39;:[],
                        &#39;label&#39;:&#39;&#39;,
                        &#39;xstart&#39;:0
        }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        if kwargs[&#39;fig&#39;]==[]:
            fig = plt.figure(figsize=kwargs[&#39;figsize&#39;])
        else :
            fig=kwargs[&#39;fig&#39;]

        if kwargs[&#39;ax&#39;] ==[]:
            ax = fig.add_subplot(111)
        else :
            ax = kwargs[&#39;ax&#39;]


        ust = np.where(self.hkb.index&gt;=kwargs[&#39;xstart&#39;])[0][0]

        x = self.hkb.index[ust:]
        links = [l+&#39;-&#39;+a for l in AP_list]
        ly = [self.hkb[l].values[ust:] for l in links]

        color=[&#39;k&#39;,&#39;b&#39;,&#39;g&#39;,&#39;r&#39;]
        plt.xlim(kwargs[&#39;xstart&#39;],x[-1]+3)
        line = [ax.plot(x, y, animated=True,
                        color=color[iy],
                        label=AP_list[iy]+&#39;-&#39;+kwargs[&#39;label&#39;])[0] for iy,y in enumerate(ly)]

        def animate(i):
            for iy,y in enumerate(ly):
                line[iy].set_ydata(y[:i])
                line[iy].set_xdata(x[:i])

            return line
        plt.legend()
        plt.xlabel(&#39;time (s)&#39;)
        plt.ylabel(&#39;RSS (dBm)&#39;)
        ani = animation.FuncAnimation(fig, animate, xrange(0, len(x)),
                                      interval=interval, blit=True)
        if save:
            ani.save(a+&#39;.mp4&#39;)
        #plt.title(links)
        plt.show()</div>


<div class="viewcode-block" id="CorSer.plot"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.plot">[docs]</a>    def plot(self,a,b,techno=&#39;&#39;,t=&#39;&#39;,**kwargs):
        &quot;&quot;&quot; ploting 

        Parameters
        ----------

        a : str | int
            name |id
        b : str | int
            name |id
        techno : str (optional)
            radio techno
        t : float | list (optional)
            given time
            or [start,stop] time

        color : color
        distance : boolean (False)
            plot distance instead of value
        lin : boolean (False)
            display linear value instead of dB
        sqrtinv : boolean (False)
            apply : &quot;sqrt (1/ dataset)&quot;
        xoffset : float (0)
            add an offset on x axis
        yoffset :  float (1|1e3|1e6)
            add an offset on y axis
        
        title : boolean (True)
            display title
        shortlabel : boolean (True)
            enable short labelling
        fontsize : int (18)
            font size

        returnlines : boolean
            if True return the matplotlib ploted lines

        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S = CorSer(6)
        &gt;&gt;&gt; f,ax = S.plot(&#39;AP1&#39;,&#39;TorsoTopLeft&#39;,techno=&#39;HKB&#39;)
        &gt;&gt;&gt; f,ax = S.pltvisi(&#39;AP1&#39;,&#39;TorsoTopLeft&#39;,techno=&#39;HKB&#39;,fig=f,ax=ax)
        &gt;&gt;&gt; #f,ax = S.pltmob(fig=f,ax=ax)
        &gt;&gt;&gt; #plt.title(&#39;hatch = visibility / gray= mobility&#39;)
        &gt;&gt;&gt; plt.show()

        &quot;&quot;&quot;

        defaults = { &#39;fig&#39;:[],
                     &#39;ax&#39;:[],
                     &#39;figsize&#39;:(6,4),
                     &#39;color&#39;:&#39;g&#39;,
                     &#39;distance&#39;:False,
                     &#39;lin&#39;:False,
                     &#39;xoffset&#39;:0,
                     &#39;yoffset&#39;: 1e6,
                     &#39;sqrtinv&#39;:False,
                     &#39;title&#39;:True,
                     &#39;shortlabel&#39;:True,
                     &#39;fontsize&#39;:18,
                     &#39;returnlines&#39;:False
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]


        a,ia,bia,subja,techno=self.devmapper(a,techno)
        b,ib,bib,subjb,techno=self.devmapper(b,techno)

        ###create a short labeling
        if kwargs[&#39;shortlabel&#39;]:

            #find uppercase position
            uu =  np.nonzero([l.isupper() or l.isdigit() for l in a])[0]
            #cretae string from list
            labela = &#39;&#39;.join([a[i] for i in uu])

            uu =  np.nonzero([l.isupper() or l.isdigit() for l in b])[0]
            #cretae string from list
            labelb = &#39;&#39;.join([b[i] for i in uu])
            label = labela +&#39;-&#39;+labelb

            
        else:
            label = a+&#39;-&#39;+b

        if kwargs[&#39;distance&#39;]:
            label = &#39;dist &#39; + label

        if kwargs[&#39;fig&#39;]==[]:
            fig = plt.figure(figsize=kwargs[&#39;figsize&#39;])
        else :
            fig=kwargs[&#39;fig&#39;]

        if kwargs[&#39;ax&#39;] ==[]:
                ax = fig.add_subplot(111)
        else :
            ax = kwargs[&#39;ax&#39;]


        # get dataframe
        if not kwargs[&#39;distance&#39;]:
            df = self.getlink(a,b,techno,t)
            title = &#39;Received Power between &#39; + label
            ylabel = &#39;Received Power dBm&#39;
        else :
            df = self.getlinkd(a,b,techno,t)
            title = &#39;Distance  between &#39; + label
            ylabel = &#39;distance (m)&#39;


        #post processing on dataframe
        if kwargs[&#39;lin&#39;]:
            df = 10**(df/10) * kwargs[&#39;yoffset&#39;]
            
        if kwargs[&#39;sqrtinv&#39;]:
            df = np.sqrt(1./df)
            ylabel = u&#39;$ (mW)^{-1/2} linear scale$&#39;

        lines = df.plot(ax=ax,color=kwargs[&#39;color&#39;],label=label)

        # Managing labelling
        if kwargs[&#39;title&#39;]:
            ax.set_title(label=title,fontsize=kwargs[&#39;fontsize&#39;])
        if kwargs[&#39;lin&#39;]:
            if kwargs[&#39;yoffset&#39;]==1:
                ylabel = &#39;mW&#39;
            if kwargs[&#39;yoffset&#39;]==1e3:
                ylabel = u&#39;$\micro$W&#39;
            if kwargs[&#39;yoffset&#39;]==1e6:
                ylabel = u&#39;nW&#39;

        ax.set_ylabel(ylabel)
        # if kwargs[&#39;data&#39;]==True:
        #     #ax.plot(self.thkb[0],self.rssi[ia,ib,:])
        #     #ax.plot(self.thkb[0],self.rssi[ib,ia,:])
        #     sab = self.hkb[a+&#39;-&#39;+b]

        #     if not(kwargs[&#39;dB&#39;]):
        #         sab = 10**(sab/10) * kwargs[&#39;yoffset&#39;]
        #         if kwargs[&#39;distance&#39;]:
        #             sab = np.sqrt(1/sab)
        #         if kwargs[&#39;reciprocal&#39;]:
        #             sba = 10**(sba/10 ) * kwargs[&#39;yoffset&#39;]
        #             sba = np.sqrt(1/sba)
        #     sab[t0:t1].plot(ax=ax,color=kwargs[&#39;colorab&#39;],label=label,xlim=(t0,t1))
        #     if kwargs[&#39;reciprocal&#39;]:
        #         sba[t0:t1].plot(ax=ax,color=kwargs[&#39;colorba&#39;],label=label)

        #     #title = &#39;Received Power   &#39; + self.title1
        #     if kwargs[&#39;dis_title&#39;]:
        #         #title = self.title1+kwargs[&#39;tit&#39;]
        #         title = kwargs[&#39;tit&#39;]
        #         ax.set_title(label=title,fontsize=kwargs[&#39;fontsize&#39;])
        #     if not kwargs[&#39;distance&#39;]:
        #         if kwargs[&#39;dB&#39;]:
        #             ax.set_ylabel(&#39;Received Power dBm&#39;)
        #         else:
        #             if kwargs[&#39;yoffset&#39;]==1:
        #                 ax.set_ylabel(&#39;mW&#39;)
        #             if kwargs[&#39;yoffset&#39;]==1e3:
        #                 ax.set_ylabel(u&#39;$\micro$W&#39;)
        #             if kwargs[&#39;yoffset&#39;]==1e6:
        #                 ax.set_ylabel(u&#39;nW&#39;)

        #     else:
        #         ax.set_ylabel(u&#39;$\prop (mW)^{-1/2} linear scale$&#39;)

        # if kwargs[&#39;reciprocal&#39;]==True:
        #     # if kwargs[&#39;data&#39;]==True:
        #     #     ax2=fig.add_subplot(212)
        #     r = self.hkb[a+&#39;-&#39;+b][self.hkb[a+&#39;-&#39;+b]!=0]- self.hkb[b+&#39;-&#39;+a][self.hkb[b+&#39;-&#39;+a]!=0]
        #     r[t0:t1].plot(ax=ax2)
        #     ax2.set_title(&#39;Reciprocity offset&#39;,fontsize=kwargs[&#39;fontsize&#39;])
        if not kwargs[&#39;returnlines&#39;]:
            return fig,ax
        else:
            return fig,ax,lines</div>


<div class="viewcode-block" id="CorSer.plthkb"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.plthkb">[docs]</a>    def plthkb(self,a,b,techno=&#39;HKB&#39;,**kwargs):
        &quot;&quot;&quot; plot Hikob devices 

        DEPRECATED

        Parameters
        ----------

        a : node name |number
        b : node name | number
        t0 : start time
        t1 : stop time


        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S = CorSer(6)
        &gt;&gt;&gt; f,ax = S.plthkb(&#39;AP1&#39;,&#39;TorsoTopLeft&#39;,techno=&#39;HKB&#39;)
        &gt;&gt;&gt; f,ax = S.pltvisi(&#39;AP1&#39;,&#39;TorsoTopLeft&#39;,techno=&#39;HKB&#39;,fig=f,ax=ax)
        &gt;&gt;&gt; f,ax = S.pltmob(fig=f,ax=ax)
        &gt;&gt;&gt; plt.title(&#39;hatch = visibility / gray= mobility&#39;)
        &gt;&gt;&gt; plt.show()

        &quot;&quot;&quot;

        defaults = { &#39;t0&#39;:0,
                     &#39;t1&#39;:-1,
                     &#39;fig&#39;:[],
                     &#39;ax&#39;:[],
                     &#39;figsize&#39;:(8,8),
                     &#39;xoffset&#39;:0,
                     &#39;yoffset&#39;: 1e6,
                     &#39;reciprocal&#39;:False,
                     &#39;dB&#39;:True,
                     &#39;data&#39;:True,
                     &#39;colorab&#39;:&#39;g&#39;,
                     &#39;colorba&#39;:&#39;b&#39;,
                     &#39;distance&#39;:False,
                    &#39;fontsize&#39;:18,
                    &#39;shortlabel&#39;:True,
                    &#39;dis_title&#39;:True,
                    &#39;xlim&#39;:(),
                    &#39;tit&#39;:&#39;&#39;
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]


        t0 =kwargs[&#39;t0&#39;]
        t1 =kwargs[&#39;t1&#39;]
        if t1 ==-1:
            try:
                t1=self.thkb[0][-1]
            except:
                t1=self.thkb[-1]

        a,ia,bia,subja,technoa=self.devmapper(a,techno)
        b,ib,bib,subjb,technob=self.devmapper(b,techno)

        if kwargs[&#39;shortlabel&#39;]:

            #find uppercase position
            uu =  np.nonzero([l.isupper() or l.isdigit() for l in a])[0]
            #cretae string from list
            labela = &#39;&#39;.join([a[i] for i in uu])

            uu =  np.nonzero([l.isupper() or l.isdigit() for l in b])[0]
            #cretae string from list
            labelb = &#39;&#39;.join([b[i] for i in uu])

            label = labela +&#39;-&#39;+labelb
        else:
            label = a+&#39;-&#39;+b

        if kwargs[&#39;fig&#39;]==[]:
            fig = plt.figure(figsize=kwargs[&#39;figsize&#39;])
        else :
            fig=kwargs[&#39;fig&#39;]

        if kwargs[&#39;ax&#39;] ==[]:
            if kwargs[&#39;reciprocal&#39;]:
                ax = fig.add_subplot(211)
                ax2 = fig.add_subplot(212)
            else :
                ax = fig.add_subplot(111)
        else :
            ax = kwargs[&#39;ax&#39;]


        if kwargs[&#39;data&#39;]==True:
            #ax.plot(self.thkb[0],self.rssi[ia,ib,:])
            #ax.plot(self.thkb[0],self.rssi[ib,ia,:])
            sab = self.hkb[a+&#39;-&#39;+b]

            if not(kwargs[&#39;dB&#39;]):
                sab = 10**(sab/10) * kwargs[&#39;yoffset&#39;]
                if kwargs[&#39;distance&#39;]:
                    sab = np.sqrt(1/sab)
                if kwargs[&#39;reciprocal&#39;]:
                    sba = 10**(sba/10 ) * kwargs[&#39;yoffset&#39;]
                    sba = np.sqrt(1/sba)
            sab[t0:t1].plot(ax=ax,color=kwargs[&#39;colorab&#39;],label=label,xlim=(t0,t1))
            if kwargs[&#39;reciprocal&#39;]:
                sba[t0:t1].plot(ax=ax,color=kwargs[&#39;colorba&#39;],label=label)

            #title = &#39;Received Power   &#39; + self.title1
            if kwargs[&#39;dis_title&#39;]:
                #title = self.title1+kwargs[&#39;tit&#39;]
                title = kwargs[&#39;tit&#39;]
                ax.set_title(label=title,fontsize=kwargs[&#39;fontsize&#39;])
            if not kwargs[&#39;distance&#39;]:
                if kwargs[&#39;dB&#39;]:
                    ax.set_ylabel(&#39;Received Power dBm&#39;)
                else:
                    if kwargs[&#39;yoffset&#39;]==1:
                        ax.set_ylabel(&#39;mW&#39;)
                    if kwargs[&#39;yoffset&#39;]==1e3:
                        ax.set_ylabel(u&#39;$\micro$W&#39;)
                    if kwargs[&#39;yoffset&#39;]==1e6:
                        ax.set_ylabel(u&#39;nW&#39;)

            else:
                ax.set_ylabel(u&#39;$\prop (mW)^{-1/2} linear scale$&#39;)

        if kwargs[&#39;reciprocal&#39;]==True:
            # if kwargs[&#39;data&#39;]==True:
            #     ax2=fig.add_subplot(212)
            r = self.hkb[a+&#39;-&#39;+b][self.hkb[a+&#39;-&#39;+b]!=0]- self.hkb[b+&#39;-&#39;+a][self.hkb[b+&#39;-&#39;+a]!=0]
            r[t0:t1].plot(ax=ax2)
            ax2.set_title(&#39;Reciprocity offset&#39;,fontsize=kwargs[&#39;fontsize&#39;])

        return fig,ax</div>

<div class="viewcode-block" id="CorSer.plttcr"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.plttcr">[docs]</a>    def plttcr(self,a,b,**kwargs):
        &quot;&quot;&quot; plot TCR devices 

        Parameters
        ----------

        a : node name |number
        b : node name | number
        t0 : start time
        t1 : stop time

        &quot;&quot;&quot;

        defaults = { &#39;t0&#39;:0,
                     &#39;t1&#39;:-1,
                     &#39;fig&#39;:[],
                     &#39;ax&#39;:[],
                     &#39;figsize&#39;:(8,8),
                     &#39;data&#39;:True,
                     &#39;colorab&#39;:&#39;g&#39;,
                     &#39;colorba&#39;:&#39;b&#39;,
                     &#39;linestyle&#39;:&#39;default&#39;,
                     &#39;inverse&#39;:False
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]


        t0 =kwargs[&#39;t0&#39;]
        t1 =kwargs[&#39;t1&#39;]
        if t1 ==-1:
            t1=self.ttcr[-1]

        if isinstance(a,str):
            ia = self.dTCR[a]
        else:
            ia = a
            a = self.idTCR[a]

        if isinstance(b,str):
            ib = self.dTCR[b]
        else:
            ib = b
            b = self.idTCR[b]


        if kwargs[&#39;fig&#39;]==[]:
            fig = plt.figure(figsize=kwargs[&#39;figsize&#39;])
        else:
            fig = kwargs[&#39;fig&#39;]

        if kwargs[&#39;ax&#39;] ==[]:
            ax = fig.add_subplot(111)
        else :
            ax=kwargs[&#39;ax&#39;]

        if kwargs[&#39;data&#39;]==True:
            #ax.plot(self.thkb[0],self.rssi[ia,ib,:])
            #ax.plot(self.thkb[0],self.rssi[ib,ia,:])
            if kwargs[&#39;inverse&#39;]:
                sab = 1./(self.tcr[a+&#39;-&#39;+b])**2
                sba = 1./(self.tcr[b+&#39;-&#39;+a])**2
            else:
                sab = self.tcr[a+&#39;-&#39;+b]
                sba = self.tcr[b+&#39;-&#39;+a]
            sab[t0:t1].plot(ax=ax,color=kwargs[&#39;colorab&#39;],marker=&#39;o&#39;,linestyle=kwargs[&#39;linestyle&#39;])
            sba[t0:t1].plot(ax=ax,color=kwargs[&#39;colorba&#39;],marker=&#39;o&#39;,linestyle=kwargs[&#39;linestyle&#39;])
            ax.set_title(a+&#39;-&#39;+b)

        return fig,ax</div>


<div class="viewcode-block" id="CorSer.pltgt"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.pltgt">[docs]</a>    def pltgt(self,a,b,**kwargs):
        &quot;&quot;&quot; plt ground truth

        Parameters
        ----------

        t0
        t1
        fig
        ax
        figsize: tuple
        linestyle&#39;
        inverse :False,
            display 1/distance  instead of distance
        log : boolean
            display log for distance intead of distance
        gammma&#39;:1.,
            mulitplication factor for log : gamma*log(distance)
            this can be used to fit RSS
        mode : string
            &#39;HKB&#39; | &#39;TCR&#39; | &#39;FULL&#39;
        visi : boolean,
            display visibility
        color: string color (&#39;k&#39;|&#39;m&#39;|&#39;g&#39;),
            color to display the visibility area
        hatch&#39;: strin hatch type (&#39;//&#39;)
            hatch type to hatch visibility area
        fontsize: int
            title fontsize

        Example
        -------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S=CorSer(6)
        &gt;&gt;&gt; S.pltgt(&#39;AP1&#39;,&#39;TorsoTopLeft&#39;)


        &quot;&quot;&quot;

        defaults = { &#39;subject&#39;:&#39;&#39;,
                     &#39;t0&#39;:0,
                     &#39;t1&#39;:-1,
                     &#39;fig&#39;:[],
                     &#39;ax&#39;:[],
                     &#39;figsize&#39;:(8,8),
                     &#39;linestyle&#39;:&#39;default&#39;,
                     &#39;inverse&#39;:False,
                     &#39;log&#39;:True,
                     &#39;gamma&#39;:-40,
                     &#39;mode&#39;:&#39;HKB&#39;,
                     &#39;visi&#39;: True,
                     &#39;fontsize&#39;: 14,
                     &#39;color&#39;:&#39;k&#39;,
                    &#39;hatch&#39;:&#39;&#39;
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]




        #t0 =kwargs.pop(&#39;t0&#39;)
        #t1 =kwargs.pop(&#39;t1&#39;)
        #if t1 ==-1:
            #t1=self.thkb[-1]
        #    t1=self.ttcr[-1]


        label = a+&#39;-&#39;+b

        mode = kwargs.pop(&#39;mode&#39;)
        inverse = kwargs.pop(&#39;inverse&#39;)
        log = kwargs.pop(&#39;log&#39;)
        gamma = kwargs.pop(&#39;gamma&#39;)
        visibility = kwargs.pop(&#39;visi&#39;)
        fontsize = kwargs.pop(&#39;fontsize&#39;)
        hatch = kwargs.pop(&#39;hatch&#39;)
        subject = kwargs.pop(&#39;subject&#39;)


        if subject==&#39;&#39;:
            subject=self.B.keys()[0]
        else:
            subject=subject

        if kwargs[&#39;fig&#39;]==[]:
            figsize = kwargs.pop(&#39;figsize&#39;)
            kwargs.pop(&#39;fig&#39;)
            fig = plt.figure(figsize=figsize)
        else:
            kwargs.pop(&#39;figsize&#39;)
            fig = kwargs.pop(&#39;fig&#39;)
        if kwargs[&#39;ax&#39;] ==[]:
            kwargs.pop(&#39;ax&#39;)
            ax = fig.add_subplot(111)
        else :
            ax=kwargs.pop(&#39;ax&#39;)



        if mode == &#39;HKB&#39; or mode == &#39;FULL&#39;:

            if isinstance(a,str):
                iahk = self.dHKB[a]
            else:
                iahk = a
                a = self.idHKB[a]

            if isinstance(b,str):
                ibhk = self.dHKB[b]
            else:
                ibhk = b
                b = self.idHKB[b]

            var = self.getlink(iahk,ibhk,&#39;HKB&#39;)
            #var = U.values
            #time = U.index
            #pdb.set_trace()

            if inverse:
                var = 1./(var)
                ax.set_ylabel(u&#39;$m^{-2}$&#39;,fontsize=fontsize)
                if log :
                    #var = gamma*10*np.log10(var)
                    var = 20*np.log10(var)+gamma
                    ax.set_ylabel(u&#39;$- 20 \log_{10}(d)&#39;+str(gamma)+&#39;$  (dB)&#39;,fontsize=fontsize)
                    plt.ylim(-65,-40)
            else:
                ax.set_ylabel(u&#39;meters&#39;,fontsize=fontsize)
                if log :
                    var = gamma*10*np.log10(var)+gamma
                    ax.set_ylabel(u&#39;$10log_{10}m^{-2}$&#39;,fontsize=fontsize)

            #ax.plot(self.B[subject].time,var,label=label,**kwargs)
            var.plot()
        #
        # TCR |Full
        #
        if mode == &#39;TCR&#39; or mode == &#39;FULL&#39;:

            if isinstance(a,str):
                iatcr = self.dTCR[a]
            else:
                iatcr = a
                a = self.idTCR[a]

            if isinstance(b,str):
                ibtcr = self.dTCR[b]
            else:
                ibtcr = b
                b = self.idTCR[b]

            var = self.getlink(iatcr,ibtcr,&#39;TCR&#39;).values

            #if inverse:
            #    var = 1./(var)**2
            #    if log :
            #        var = gamma*10*np.log10(var)
            #else:
            #    if log :
            #        var = gamma*10*np.log10(var)

            #pdb.set_trace()
            #ax.plot(self.B[subject].time,var,**kwargs)
            ax.plot(self.B[subject].ttcr,var,**kwargs)


        if visibility:
            aa= ax.axis()
            vv,tv,tseg,itseg = self._visiarray(a,b)
            # vv.any : it exist NLOS regions
            if vv.any():
                fig,ax=plu.rectplot(tv,tseg,ylim=aa[2:],color=kwargs[&#39;color&#39;],hatch=hatch,fig=fig,ax=ax)
                # for t in tseg:


        #axs[cptax].plot(visi.index.values,visi.values,&#39;r&#39;)


        #if inverse:
        #    ax.set_title(u&#39;Motion Capture Ground Truth :  inverse of squared distance&#39;,fontsize=fontsize+1)
        #else:
        #    ax.set_title(&#39;Motion Capture Ground Truth : evolution of distance (m)&#39;,fontsize=fontsize+1)

        ax.set_xlabel(&#39;Time (s)&#39;,fontsize=fontsize)
        plt.tight_layout()

        return fig, ax</div>


<div class="viewcode-block" id="CorSer.pltlk"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.pltlk">[docs]</a>    def pltlk(self,a,b,**kwargs):
        &quot;&quot;&quot; plot links

        Parameters
        ----------

        a : string
            node a name
        b : string
            node b name

        display: list
            techno to be displayed
        figsize
        t0: float
            time start
        t1 : float
            time stop
        colhk: plt.color

            color of hk curve
        colhk2:plt.color
            color of hk curve2 ( if recirpocal)
        linestylehk:
            linestyle hk

        coltcr:
            color tcr curve
        coltcr2:
            color of tcr curve2 ( if recirpocal)
        linestyletcr:
            linestyle tcr
        colgt:
            color ground truth
        inversegt:
            invert ground truth
        loggt: bool
            apply a log10 factor to ground truth
        gammagt:
            applly a gamma factor to ground truth (if loggt ! )
        fontsize:
            font size of legend
        visi:
            display visibility indicator
        axs :
            list of matplotlib axes

        Example
        -------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S=CorSer(6)
        &gt;&gt;&gt; S.pltlk(&#39;AP1&#39;,&#39;TorsoTopLeft&#39;)
        &quot;&quot;&quot;

        defaults = { &#39;display&#39;:[],
                     &#39;figsize&#39;:(8,8),
                     &#39;t0&#39;:0,
                     &#39;t1&#39;:-1,
                     &#39;colhk&#39;:&#39;g&#39;,
                     &#39;colhk2&#39;:&#39;b&#39;,
                     &#39;linestylehk&#39;:&#39;default&#39;,
                     &#39;coltcr&#39;:&#39;g&#39;,
                     &#39;coltcr2&#39;:&#39;b&#39;,
                     &#39;linestyletcr&#39;:&#39;step&#39;,
                     &#39;colgt&#39;: &#39;k&#39;,
                     &#39;inversegt&#39;:True,
                     &#39;loggt&#39;:True,
                     &#39;gammagt&#39;:-40,
                     &#39;fontsize&#39;:14,
                     &#39;visi&#39;:True,
                     &#39;axs&#39; :[],
                     &#39;gt&#39;:True,
                     &#39;tit&#39;:&#39;&#39;
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        display = kwargs.pop(&#39;display&#39;)

        if not isinstance(display,list):
            display=[display]


        if display == []:
            if (&#39;tcr&#39; in dir(self)) and (&#39;hkb&#39; in dir(self)):
                display.append(&#39;FULL&#39;)
            elif &#39;tcr&#39; in dir(self):
                display.append(&#39;TCR&#39;)
            elif &#39;hkb&#39; in dir(self):
                display.append(&#39;HKB&#39;)

        display = [t.upper() for t in display]

        if &#39;FULL&#39; in display:
            ld = 2
        elif &#39;TCR&#39; in display or &#39;HKB&#39; in display:
            ld = 2

        #Axes management
        if kwargs[&#39;axs&#39;] == []:
            kwargs.pop(&#39;axs&#39;)
            fig,axs = plt.subplots(nrows=ld,ncols=1,figsize=kwargs[&#39;figsize&#39;],sharex=True)
        else :
            fig =plt.gcf()
            axs = kwargs.pop(&#39;axs&#39;)


        cptax= 0


        # HKB plot
        if &#39;HKB&#39; in display or &#39;FULL&#39; in display:
            if (&#39;HKB&#39; in self.typ.upper()) or (&#39;FULL&#39; in self.typ.upper()):
                if isinstance(a,str):
                    iahk = self.dHKB[a]
                else :
                    raise AttributeError(&#39;in self.pltlk, nodes id must be a string&#39;)
                if isinstance(b,str):
                    ibhk = self.dHKB[b]
                else :
                    raise AttributeError(&#39;in self.pltlk, nodes id must be a string&#39;)

            else :
                raise AttributeError(&#39;HK not available for the given scenario&#39;)






            kwargs[&#39;fig&#39;]=fig
            kwargs[&#39;ax&#39;]=axs[cptax]
            kwargs[&#39;colorab&#39;]=kwargs.pop(&#39;colhk&#39;)
            kwargs[&#39;colorba&#39;]=kwargs.pop(&#39;colhk2&#39;)
            kwargs[&#39;linestyle&#39;]=kwargs.pop(&#39;linestylehk&#39;)
            kwargs[&#39;tit&#39;]=kwargs.pop(&#39;tit&#39;)

            fig,axs[cptax]=self.plthkb(a,b,reciprocal=False,**kwargs)


            cptax+=1
        else :
            kwargs.pop(&#39;colhk&#39;)
            kwargs.pop(&#39;colhk2&#39;)
            kwargs.pop(&#39;linestylehk&#39;)


        #TCR plot
        if &#39;TCR&#39; in display or &#39;FULL&#39; in display:
            if (&#39;TCR&#39; in self.typ.upper()) or (&#39;FULL&#39; in self.typ.upper()):
                if isinstance(a,str):
                    iatcr = self.dTCR[a]
                else :
                    raise AttributeError(&#39;in self.pltlk, nodes id must be a string&#39;)
                if isinstance(b,str):
                    ibtcr = self.dTCR[b]
                else :
                    raise AttributeError(&#39;in self.pltlk, nodes id must be a string&#39;)
            else :
                raise AttributeError(&#39;TCR not available for the given scenario&#39;)

            kwargs[&#39;fig&#39;]=fig
            kwargs[&#39;ax&#39;]=axs[cptax]
            kwargs[&#39;colorab&#39;]=kwargs.pop(&#39;coltcr&#39;)
            kwargs[&#39;colorba&#39;]=kwargs.pop(&#39;coltcr2&#39;)
            kwargs[&#39;linestyle&#39;]=kwargs.pop(&#39;linestyletcr&#39;)
            tcrlink = a+&#39;-&#39;+b
            #plot only if link exist
            if tcrlink in self.tcr:
                fig,axs[cptax]=self.plttcr(a,b,**kwargs)
        else :
            kwargs.pop(&#39;coltcr&#39;)
            kwargs.pop(&#39;coltcr2&#39;)
            kwargs.pop(&#39;linestyletcr&#39;)
            #cptax+=1

        #
        # Ground Truth
        #
        #
        # HKB |Full
        #
        if kwargs.pop(&#39;gt&#39;):
            kwargs[&#39;color&#39;] = kwargs.pop(&#39;colgt&#39;)
            kwargs.pop(&#39;colorab&#39;)
            kwargs.pop(&#39;colorba&#39;)
            kwargs[&#39;ax&#39;]=axs[cptax]
            kwargs[&#39;inverse&#39;]=kwargs.pop(&#39;inversegt&#39;)
            kwargs[&#39;log&#39;]=kwargs.pop(&#39;loggt&#39;)
            kwargs[&#39;gamma&#39;]=kwargs.pop(&#39;gammagt&#39;)
            kwargs.pop(&#39;tit&#39;)

            if &#39;HKB&#39; in display or &#39;FULL&#39; in display:
                kwargs[&#39;mode&#39;]= &#39;HKB&#39;
                fig,axs[cptax] = self.pltgt(a,b,**kwargs)
            elif &#39;TCR&#39; in display or &#39;FULL&#39; in display:
                kwargs[&#39;mode&#39;]= &#39;TCR&#39;
                fig,axs[cptax] = self.pltgt(a,b,**kwargs)

        return fig,axs</div>
        # aa = axs[cptax].axis()
        #
        # calculates visibility and display NLOS region
        # as a yellow patch over the shadowed region
        #


<div class="viewcode-block" id="CorSer.showpattern"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.showpattern">[docs]</a>    def showpattern(self,a,techno=&#39;HKB&#39;,**kwargs):
        &quot;&quot;&quot; show pattern configuation for a given link and frame

        Parameters
        ----------

        a : int
            link index
        technoa : string
            &#39;HKB&#39;|&#39;TCR&#39;|&#39;BS&#39;
        technob
            default &#39;HKB&#39;|&#39;TCR&#39;|&#39;BS&#39;
        phi : float
            antenna elevation in rad
        fig :
        ax  :
        t   : float
        phi : float
            pi/2
        ap  : boolean
        &quot;&quot;&quot;

        defaults = { &#39;fig&#39;:[],
                     &#39;ax&#39;:[],
                     &#39;t&#39;:0,
                     &#39;phi&#39;:np.pi/2.,
                     &#39;ap&#39;:False
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        if kwargs[&#39;fig&#39;] == []:
            fig=plt.figure()
        else :
            fig = kwargs[&#39;fig&#39;]

        if kwargs[&#39;ax&#39;] == []:
            ax=fig.add_subplot(111)
        else :
            ax = kwargs[&#39;ax&#39;]

        # display nodes
        #
        #
        #
        a,ia,ba,subjecta,techno = self.devmapper(a,techno)
        pa = self.getdevp(a,techno=techno,t=kwargs[&#39;t&#39;]).values


        if len(pa.shape) &gt;1:
            pa=pa[0]
        ax.plot(pa[0],pa[1],&#39;ob&#39;)
        ax.text(pa[0],pa[1],ba)

        if subjecta != &#39;&#39;:
            self.B[subjecta].settopos(t=kwargs[&#39;t&#39;])
            self.B[subjecta].dev[ba][&#39;ant&#39;].eval()
            xa,ya,z,sa,v = self.B[subjecta].dev[ba][&#39;ant&#39;]._computemesh(po=pa,T=self.B[subjecta].acs[ba],minr=0.01,maxr=0.1,ilog=False)
            p2 = np.where(self.B[subjecta].dev[ba][&#39;ant&#39;].phi&lt;=kwargs[&#39;phi&#39;])[0][-1]

            # ax.plot(xa[:,p2],ya[:,p2])
            ax.plot(xa[p2,:],ya[p2,:])

        else:
            self.din[ba][&#39;ant&#39;].eval()
            xa,ya,z,sa,v = self.din[ba][&#39;ant&#39;]._computemesh(po=self.din[ba][&#39;p&#39;],T=self.din[ba][&#39;T&#39;],minr=0.01,maxr=0.1,ilog=False)
            p2 = np.where(self.din[ba][&#39;ant&#39;].phi&lt;=kwargs[&#39;phi&#39;])[0][-1]
            ax.plot(xa[:,p2],ya[:,p2])

        return fig,ax</div>

<div class="viewcode-block" id="CorSer.showlink"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.showlink">[docs]</a>    def showlink(self,a=&#39;AP1&#39;,b=&#39;BackCenter&#39;,technoa=&#39;HKB&#39;,technob=&#39;HKB&#39;,**kwargs):
        &quot;&quot;&quot; show link configuation for a given frame

        Parameters
        ----------

        a : int
            link index
        b : int
            link index
        technoa : string
            default &#39;HKB&#39;|&#39;TCR&#39;|&#39;BS&#39;
        technob
            default &#39;HKB&#39;|&#39;TCR&#39;|&#39;BS&#39;
        phi : float
            antenna elevation in rad

        &quot;&quot;&quot;

        defaults = { &#39;fig&#39;:[],
                     &#39;ax&#39;:[],
                     &#39;t&#39;:0,
                     &#39;phi&#39;:np.pi/2.,
                     &#39;ap&#39;:False
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        if kwargs[&#39;fig&#39;] == []:
            fig=plt.figure()
        else :
            fig = kwargs[&#39;fig&#39;]

        if kwargs[&#39;ax&#39;] == []:
            ax=fig.add_subplot(111)
        else :
            ax = kwargs[&#39;ax&#39;]

        # display nodes

        fig,ax=self.showpattern(a=a,techno=technoa,fig=fig,ax=ax)
        fig,ax=self.showpattern(a=b,techno=technob,fig=fig,ax=ax)

        plt.axis(&#39;equal&#39;)


        p1 = self.din[&#39;HKB:1&#39;][&#39;p&#39;]
        p2 = self.din[&#39;HKB:2&#39;][&#39;p&#39;]
        p3 = self.din[&#39;HKB:3&#39;][&#39;p&#39;]
        p4 = self.din[&#39;HKB:4&#39;][&#39;p&#39;]
        plt.plot(p1[0],p1[1],&#39;og&#39;)
        plt.plot(p2[0],p2[1],&#39;ob&#39;)
        plt.plot(p3[0],p3[1],&#39;or&#39;)
        plt.plot(p4[0],p4[1],&#39;ok&#39;)
        plt.axis(&#39;equal&#39;)</div>
        
        # if A.ndim==2:
        #     plt.plot(A[iframe,0],A[iframe,1],&#39;ob&#39;)
        #     plt.text(A[iframe,0],A[iframe,1],a)
        # else:
        #     plt.plot(A[0],A[1],&#39;or&#39;)
        #     #plt.text(A[0],A[1],a)

        # if B.ndim==2:
        #     plt.plot(B[iframe,0],B[iframe,1],style)
        #     plt.text(B[iframe,0]+0.1,B[iframe,1]+0.1,b)
        # else:
        #     plt.plot(B[0],B[1],&#39;ob&#39;)
        #     plt.text(B[0],B[1],b)
        # plt.xlim(-6,6)
        # plt.ylim(-5,5)


        # self.B[subjecta].settopos(t=t)
        # self.B[subjectb].settopos(t=t)

        # 

        
        # # display body

        # #pc = self.B.d[:,2,iframe] + self.B.pg[:,iframe].T
        # pc0 = self.B[subjecta].d[:,0,iframe] + self.B[subjecta].pg[:,iframe].T
        # pc1 = self.B[subjecta].d[:,1,iframe] + self.B[subjecta].pg[:,iframe].T
        # pc15 = self.B[subjecta].d[:,15,iframe] + self.B[subjecta].pg[:,iframe].T
        # #plt.plot(pc0[0],pc0[1],&#39;og&#39;)
        # #plt.text(pc0[0]+0.1,pc0[1],str(iframe))
        # #plt.plot(pc1[0],pc1[1],&#39;og&#39;)
        # #plt.plot(pc15[0],pc15[1],&#39;og&#39;)
        # #ci00   = plt.Circle((pc0[0],pc0[1]),self.B[subjecta].sl[0,2],color=&#39;green&#39;,alpha=0.6)
        # #ci01   = plt.Circle((pc1[0],pc1[1]),self.B[subjecta].sl[0,2],color=&#39;green&#39;,alpha=0.1)
        # #ci100 = plt.Circle((pc0[0],pc0[1]),self.B[subjecta].sl[10,2],color=&#39;red&#39;,alpha=0.1)
        # ci1015 = plt.Circle((pc15[0],pc15[1]),self.B[subjecta].sl[10,2],color=&#39;green&#39;,alpha=0.5)
        # plt.axis(&#39;equal&#39;)
        # ax = plt.gca()
        # ax.add_patch(ci1015)
        # #ax.add_patch(ci01)
        # #ax.add_patch(ci100)
        # #ax.add_patch(ci1015)
        # #its = self.B[subjecta].intersectBody(A[iframe,:],B[iframe,:],topos=False,frameId=iframe)
        # #x.set_title(&#39;frameId :&#39;+str(iframe)+&#39; &#39;+str(its.T))



<div class="viewcode-block" id="CorSer.visidev"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.visidev">[docs]</a>    def visidev(self,a,b,technoa=&#39;HKB&#39;,technob=&#39;HKB&#39;,dsf=10):
        &quot;&quot;&quot; get link visibility status

        Returns
        -------

        visi : pandas Series
            0  : LOS
            1  : NLOS

        &quot;&quot;&quot;

        A,B = self.getlinkp(a,b,technoa=technoa,technob=technob)
        A=A.values
        B=B.values
        aa,ia,ba,subjecta,technoa= self.devmapper(a,technoa)
        ab,ib,bb,subjectb,technob= self.devmapper(b,technob)


        if &#39;AP&#39; not in aa:
            Nframe = A.shape[0]
        if &#39;AP&#39; not in ab:
            Nframe = B.shape[0]
        else: 
            Nframe = len(self.B[self.B.keys()[0]].time)
        iframe = np.arange(0,Nframe-1,dsf)
        tvisi = []
        #
        # A : Nframe x 3
        # B : Nframe x 3
        # B.pg : 3 x Nframe
        #
        if subjecta != &#39;&#39;:
            subject = subjecta
        elif subjectb != &#39;&#39;:
            subject = subjectb
        else :
            raise AttributeError(&#39;Visibility can only be determine on a body for now&#39;)
        if self.B[subject].centered:
            A = A-self.B[subject].pg.T
            B = B-self.B[subject].pg.T


        for k in iframe:
            if len(np.shape(A))&lt;2:
                A=A[np.newaxis,:]*np.ones((len(B),3))
            if len(np.shape(B))&lt;2:
                B=B[np.newaxis,:]*np.ones((len(A),3))

            its = self.B[subject].intersectBody(A[k,:],B[k,:],topos=False,frameId=k)
            tvisi.append(its.any())
        visi = pd.Series(tvisi,index=iframe/100.)
        #return(visi,iframe)
        return(visi)</div>

<div class="viewcode-block" id="CorSer.visidev2"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.visidev2">[docs]</a>    def visidev2(self,a,b,technoa=&#39;HKB&#39;,technob=&#39;HKB&#39;,trange=[]):
        &quot;&quot;&quot; get link visibility status

        Returns
        -------
        trange : nd array
            time range
        visi : pandas Series
            0  : LOS
            1  : NLOS

        &quot;&quot;&quot;

        A,B = self.getlinkp(a,b,technoa,technob)
        A=A.values
        B=B.values
        aa,ia,ba,subjecta,technoa= self.devmapper(a,technoa)
        ab,ib,bb,subjectb,technob= self.devmapper(b,technob)

        if &#39;AP&#39; not in a:
            Nframe = A.shape[0]
        if &#39;AP&#39; not in b:
            Nframe = B.shape[0]
        # iframe = np.arange(0,Nframe-1,dsf)
        tvisi = []
        #
        # A : Nframe x 3
        # B : Nframe x 3
        # B.pg : 3 x Nframe
        #
        if subjecta != &#39;&#39;:
            subject = subjecta
        elif subjectb != &#39;&#39;:
            subject = subjectb
        else :
            raise AttributeError(&#39;Visibility can only be determine on a body for now&#39;)

        if self.B[subject].centered:
            A = A-self.B[subject].pg.T
            B = B-self.B[subject].pg.T

        for t in trange:
            fid = self.B[subject].posvel(self.B[subjecta].traj,t)[0]
            its = self.B[subject].intersectBody(A[fid,:],B[fid,:],topos=False,frameId=fid)
            tvisi.append(its.any())
        visi = pd.Series(tvisi,index=trange)
        #return(visi,iframe)
        return(visi)</div>



    def _visiarray(self,a,b,technoa=&#39;HKB&#39;,technob=&#39;HKB&#39;):
        &quot;&quot;&quot; create entries for plu.rectplot
        &quot;&quot;&quot;

        visi = self.visidev(a,b,technoa=technoa,technob=technob)
        tv = visi.index.values
        vv = visi.values.astype(int)
        if (not(vv.all()) and vv.any()):
            df = vv[1:]-vv[0:-1]

            um = np.where(df==1)[0]
            ud = np.where(df==-1)[0]
            lum = len(um)
            lud = len(ud)

            #
            # impose same size and starting
            # on leading edge um and endinf on
            # falling edge ud
            #
            if lum==lud:
                if ud[0]&lt;um[0]:
                    um = np.hstack((np.array([0]),um))
                    ud = np.hstack((ud,np.array([len(vv)-1])))
            else:
                if ((lum&lt;lud) &amp; (vv[0]==1)):
                    um = np.hstack((np.array([0]),um))

                if ((lud&lt;lum) &amp; (vv[len(vv)-1]==1)):
                    ud = np.hstack((ud,np.array([len(vv)-1])))


            tseg = np.array(zip(um,ud))
            #else:
            #    tseg = np.array(zip(ud,um))
        else:
            if vv.all():
                tseg = np.array(zip(np.array([0]),np.array([len(vv)-1])))
            else :
                tseg = np.array([[0,0]])
        itseg = copy.copy(tseg)
        bb = np.insert(itseg[:,1],0,0)
        ee = np.hstack((itseg[:,0],len(vv)))
        itseg = np.array((bb,ee)).T
        # bb = np.hstack((bb,len(vv)))

        return vv,tv,tseg,itseg


    # def _computedevpdf(self):
    #     &quot;&quot;&quot; create a timestamped data frame
    #         with all positions of devices
    #     &quot;&quot;&quot;
    #     t=self.B.traj.time()
    #     pos = np.empty((len(t),12,3))
    #     for ik,k in enumerate(t):
    #         self.B.settopos(t=k)
    #         pos[ik,:,:]=self.B.getlinkp()
    #     df=[]
    #     for d in range(pos.shape[1]):
    #         df_tmp=pd.DataFrame(pos[:,d,:],columns=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;],index=t)
    #         df_tmp[&#39;id&#39;]=self.B.dev.keys()[d]
    #         try :
    #             df = pd.concat([df,df_tmp])
    #         except:
    #             df = df_tmp
    #     df = df.sort_index()
    #     cols=[&#39;id&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]
    #     self.devdf=df[cols]

    def _computedevpdf(self):
        &quot;&quot;&quot; create a timestamped data frame
            with positions of all devices


        &quot;&quot;&quot;


        if not isinstance(self.B,dict):
            B={self.subject[0]:self.B}
        else :
            B=self.B

        for b in B:
            if &#39;dev&#39; in dir(B[b]):
                dev = B[b].dev.keys()
                udev=[B[b].dev[d][&#39;uc3d&#39;] for d in dev]

                postmp = np.array([np.mean(B[b]._f[:,u,:],axis=1) for u in udev])
                pos = postmp.swapaxes(0,1)
                t = B[b].time
                for d in range(len(dev)):
                    df_tmp=pd.DataFrame(pos[:,d,:],columns=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;],index=t)
                    df_tmp[[&#39;vx&#39;,&#39;vy&#39;,&#39;vz&#39;]]=df_tmp.diff()/(t[1]-t[0])
                    df_tmp[&#39;v&#39;]=np.sqrt(np.sum(df_tmp[[&#39;vx&#39;,&#39;vy&#39;,&#39;vz&#39;]]**2,axis=1))
                    df_tmp[[&#39;ax&#39;,&#39;ay&#39;,&#39;az&#39;]]=df_tmp[[&#39;vx&#39;,&#39;vy&#39;,&#39;vz&#39;]].diff()/(t[1]-t[0])
                    df_tmp[&#39;a&#39;]=np.sqrt(np.sum(df_tmp[[&#39;ax&#39;,&#39;ay&#39;,&#39;az&#39;]]**2,axis=1))
                    df_tmp[&#39;id&#39;] = list(B[b].dev.keys())[d]
                    df_tmp[&#39;subject&#39;]=B[b].name
                    try :
                        df = pd.concat([df,df_tmp])
                    except:
                        df = df_tmp

        for i in self.din:
            pos = self.din[i][&#39;p&#39;]
            pos2 = pos[:,np.newaxis]*np.ones(len(t))
            df_tmp=pd.DataFrame(pos2.T,columns=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;],index=t)
            df_tmp[&#39;v&#39;]=0.
            df_tmp[&#39;vx&#39;]=0.
            df_tmp[&#39;vy&#39;]=0.
            df_tmp[&#39;vz&#39;]=0.
            df_tmp[&#39;a&#39;]=0.
            df_tmp[&#39;ax&#39;]=0.
            df_tmp[&#39;ay&#39;]=0.
            df_tmp[&#39;az&#39;]=0.
            df_tmp[&#39;subject&#39;]=&#39;&#39;
            df_tmp[&#39;id&#39;]=i
            df = pd.concat([df,df_tmp])

        df = df.sort_index()
        cols=[&#39;id&#39;,&#39;subject&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;v&#39;,&#39;vx&#39;,&#39;vy&#39;,&#39;vz&#39;,&#39;a&#39;,&#39;ax&#39;,&#39;ay&#39;,&#39;az&#39;]
        self.devdf=df[cols]

        # if (&#39;HKB&#39; in self.typ) or (&#39;FULL&#39; in selftyp):
        #     self.devdf=self._align_devdf_on_hkb(self.devdf,self.hkb)


<div class="viewcode-block" id="CorSer.export_csv"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.export_csv">[docs]</a>    def export_csv(self,**kwargs):
        &quot;&quot;&quot; export to csv devices positions

        Parameters
        ----------
            unit : string (&#39;mm&#39;|&#39;cm&#39;|&#39;m&#39;),
                unit of positions in csv(default mm)
            tunit: string
                time unit in csv (default &#39;ns&#39;)
            &#39;alias&#39;: dict
                dictionnary to replace name of the devices into the csv .
                example : if you want to replace a device id named &#39;TCR:34&#39;
                to an id = 5, you have to add an entry in the alias dictionnary as :
                alias.update({&#39;TCR34&#39;:5})
            offset : np.array
                apply an offset on positions

        Return
        ------

            a csv file into the folder &lt;PylayersProject&gt;/netsave

        &quot;&quot;&quot;

        defaults={&#39;unit&#39; :&#39;mm&#39;,
                  &#39;tunit&#39;:&#39;ns&#39;,
                  &#39;offset&#39;:np.array(([0,0,0])),
                  &#39;alias&#39;:{}}

        for key, value in defaults.items():
            if key not in kwargs:
                kwargs[key] = value

        unit=kwargs.pop(&#39;unit&#39;)
        tunit=kwargs.pop(&#39;tunit&#39;)
        alias = kwargs.pop(&#39;alias&#39;)

        if alias == {}:

            alias={&#39;TCR:49&#39;:4 #Nicolas TorsoLeft
            ,&#39;TCR:34&#39;:5 #Nicolas TorsoRight
            ,&#39;TCR:48&#39;:6 #Nicolas Back
            ,&#39;TCR:36&#39;:7 #Nicolas Shoulder

            ,&#39;TCR:2&#39;:8 # Jihad TorsoLeft
            ,&#39;TCR:35&#39;:9 #Jihad TorsoRight
            ,&#39;TCR:33&#39;:10 #Jihad Back
            ,&#39;TCR:37&#39;:11 #Jihad Shoulder

            ,&#39;TCR:30&#39;:12 #Eric Torso
            ,&#39;TCR:25&#39;:13 #Eric Back
            ,&#39;TCR:26&#39;:14 # Eric Shoulder
            }

        filename =pyu.getlong(self._filename,pstruc[&#39;DIRNETSAVE&#39;]) + &#39;.csv&#39;

        df = copy.deepcopy(self.devdf)

        ldf = df[[&#39;id&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]]

        #rename devices
        if alias != {}:
            for k in alias:
                u=ldf[&#39;id&#39;] == k
                ldf.iloc[u.values,0]=str(alias[k])

        # fix position unit
        if unit == &#39;m&#39;:
            _unit = 1.
        if unit == &#39;cm&#39;:
            _unit = 1e2
        if unit == &#39;mm&#39;:
            _unit = 1e3

        ldf.loc[:,&#39;x&#39;]=ldf.loc[:,&#39;x&#39;]*_unit-kwargs[&#39;offset&#39;][0]
        ldf.loc[:,&#39;y&#39;]=ldf.loc[:,&#39;y&#39;]*_unit-kwargs[&#39;offset&#39;][1]
        ldf.loc[:,&#39;z&#39;]=ldf.loc[:,&#39;z&#39;]*_unit-kwargs[&#39;offset&#39;][2]

        # fix time unit
        if tunit == &#39;ms&#39;:
            _tunit = 1e3
        if tunit == &#39;us&#39;:
            _tunit = 1e6
        if tunit == &#39;ns&#39;:
            _tunit = 1e9


        # add timestamp column

        ldf[&#39;Timestamp&#39;]=ldf.index*_tunit

        ldf.to_csv(filename, sep = &#39; &#39;,index=False)</div>


<div class="viewcode-block" id="CorSer.savemat"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.savemat">[docs]</a>    def savemat(self):
        &quot;&quot;&quot; save in Matlab Format 
        &quot;&quot;&quot;
        d ={}
        # Access Point Coordinates 

        pAP1 = self.getdevp(1,t=[0,100])
        pAP2 = self.getdevp(2,t=[0,100])
        pAP3 = self.getdevp(3,t=[0,100])
        pAP4 = self.getdevp(4,t=[0,100])

        t = self.hkb.index.values


        AP=np.array([[pAP1[&#39;x&#39;][0],pAP1[&#39;y&#39;][0]],
              [pAP2[&#39;x&#39;][0],pAP2[&#39;y&#39;][0]],
              [pAP3[&#39;x&#39;][0],pAP3[&#39;y&#39;][0]],
              [pAP4[&#39;x&#39;][0],pAP4[&#39;y&#39;][0]]
             ])


        pTTR = self.getdevp(&#39;TorsoTopRight&#39;,techno=&#39;HKB&#39;,t=[0,100])
        pTTL = self.getdevp(&#39;TorsoTopLeft&#39;,techno=&#39;HKB&#39;,t=[0,100])
        pBC  = self.getdevp(&#39;BackCenter&#39;,techno=&#39;HKB&#39;,t=[0,100])


        d[&#39;AP&#39;]=AP
 
        d[&#39;pTTR&#39;] = np.array([pTTR[&#39;x&#39;],pTTR[&#39;y&#39;]])
        d[&#39;pTTL&#39;] = np.array([pTTL[&#39;x&#39;],pTTL[&#39;y&#39;]])
        d[&#39;pBC&#39;]  = np.array([pBC[&#39;x&#39;],pBC[&#39;y&#39;]])
        
        # observables radios TTR/TTL/BC

        TTR_1 = self.hkb[&#39;AP1-TorsoTopRight&#39;].values
        TTL_1 = self.hkb[&#39;AP1-TorsoTopLeft&#39;].values
        BC_1  = self.hkb[&#39;AP1-BackCenter&#39;].values

        Rho1R = BC_1-TTR_1
        Rho1L = BC_1-TTL_1

        RhoM1R = np.nanmax(Rho1R)
        Rhom1R = np.nanmin(Rho1R)
        RhoM1L = np.nanmax(Rho1L)
        Rhom1L = np.nanmin(Rho1L)


        ### AP2 

        TTR_2= self.hkb[&#39;AP2-TorsoTopRight&#39;].values
        TTL_2= self.hkb[&#39;AP2-TorsoTopLeft&#39;].values
        BC_2 = self.hkb[&#39;AP2-BackCenter&#39;].values

        Rho2R = BC_2-TTR_2
        Rho2L = BC_2-TTL_2

        RhoM2R=np.nanmax(Rho2R)
        Rhom2R=np.nanmin(Rho2R)
        RhoM2L=np.nanmax(Rho2L)
        Rhom2L=np.nanmin(Rho2L)


        ### AP3

        TTR_3= self.hkb[&#39;AP3-TorsoTopRight&#39;].values
        TTL_3= self.hkb[&#39;AP3-TorsoTopLeft&#39;].values
        BC_3 = self.hkb[&#39;AP3-BackCenter&#39;].values
        Rho3R = BC_3-TTR_3
        Rho3L = BC_3-TTL_3

        RhoM3R=np.nanmax(Rho3R)
        Rhom3R=np.nanmin(Rho3R)
        RhoM3L=np.nanmax(Rho3L)
        Rhom3L=np.nanmin(Rho3L)

        ### AP4 

        TTR_4= self.hkb[&#39;AP4-TorsoTopRight&#39;].values
        TTL_4= self.hkb[&#39;AP4-TorsoTopLeft&#39;].values
        BC_4 = self.hkb[&#39;AP4-BackCenter&#39;].values

        Rho4R = BC_4-TTR_4
        Rho4L = BC_4-TTL_4

        RhoM4R=np.nanmax(Rho4R)
        Rhom4R=np.nanmin(Rho4R)
        RhoM4L=np.nanmax(Rho4L)
        Rhom4L=np.nanmin(Rho4L)

        
        d[&#39;ttr1&#39;] = TTR_1
        d[&#39;ttr2&#39;] = TTR_2
        d[&#39;ttr3&#39;] = TTR_3
        d[&#39;ttr4&#39;] = TTR_4
        d[&#39;ttl1&#39;] = TTL_1
        d[&#39;ttl2&#39;] = TTL_2
        d[&#39;ttl3&#39;] = TTL_3
        d[&#39;ttl4&#39;] = TTL_4
        d[&#39;bc1&#39;]  = BC_1
        d[&#39;bc2&#39;]  = BC_2
        d[&#39;bc3&#39;]  = BC_3
        d[&#39;bc4&#39;]  = BC_4

        d[&#39;time&#39;]=t[0:10001]
        
        vpRC = (pTTR-pBC)
        vpLC = (pTTL-pBC)
        vp = (pTTR-pBC)+(pTTL-pBC)

        # unitary vectors 
        vpRC = array([vpRC[&#39;x&#39;],vpRC[&#39;y&#39;]])
        vpLC = array([vpLC[&#39;x&#39;],vpLC[&#39;y&#39;]])
        vp = array([vp[&#39;x&#39;],vp[&#39;y&#39;]])

        # unitary vectors 

        vpn = vp/np.sqrt(np.sum(vp*vp,axis=0))
        vpRCn = vpRC/np.sqrt(np.sum(vpRC*vpRC,axis=0))
        vpLCn = vpLC/np.sqrt(np.sum(vpLC*vpLC,axis=0))

        # coord des AP
        p1 = pAP1.ix[0]
        p2 = pAP2.ix[0]
        p3 = pAP3.ix[0]
        p4 = pAP4.ix[0]


        v1C = p1-pBC
        v2C = p2-pBC
        v3C = p3-pBC
        v4C = p4-pBC

        v1C = np.array((v1C.x.values,v1C.y.values))
        v2C = np.array((v2C.x.values,v2C.y.values))
        v3C = np.array((v3C.x.values,v3C.y.values))
        v4C = np.array((v4C.x.values,v4C.y.values))


        v1Cn = v1C/(sqrt(np.sum(v1C*v1C,axis=0)))
        v2Cn = v2C/(sqrt(np.sum(v2C*v2C,axis=0)))
        v3Cn = v3C/(sqrt(np.sum(v3C*v3C,axis=0)))
        v4Cn = v4C/(sqrt(np.sum(v4C*v4C,axis=0)))


        cr1 = np.cross(vpn,v1Cn,axis=0)
        cr2 = np.cross(vpn,v2Cn,axis=0)
        cr3 = np.cross(vpn,v3Cn,axis=0)
        cr4 = np.cross(vpn,v4Cn,axis=0)

        cr1R = np.cross(vpRCn,v1Cn,axis=0)
        cr2R = np.cross(vpRCn,v2Cn,axis=0)
        cr3R = np.cross(vpRCn,v3Cn,axis=0)
        cr4R = np.cross(vpRCn,v4Cn,axis=0)

        cr1L = np.cross(vpLCn,v1Cn,axis=0)
        cr2L = np.cross(vpLCn,v2Cn,axis=0)
        cr3L = np.cross(vpLCn,v3Cn,axis=0)
        cr4L = np.cross(vpLCn,v4Cn,axis=0)


        dvpnv1n = sum(vpn*v1Cn,axis=0)
        dvpnv2n = sum(vpn*v2Cn,axis=0)
        dvpnv3n = sum(vpn*v3Cn,axis=0)
        dvpnv4n = sum(vpn*v4Cn,axis=0)


        dvpnv1Rn = sum(vpRCn*v1Cn,axis=0)
        dvpnv2Rn = sum(vpRCn*v2Cn,axis=0)
        dvpnv3Rn = sum(vpRCn*v3Cn,axis=0)
        dvpnv4Rn = sum(vpRCn*v4Cn,axis=0)


        dvpnv1Ln = sum(vpLCn*v1Cn,axis=0)
        dvpnv2Ln = sum(vpLCn*v2Cn,axis=0)
        dvpnv3Ln = sum(vpLCn*v3Cn,axis=0)
        dvpnv4Ln = sum(vpLCn*v4Cn,axis=0)

    
        alf1R = np.arctan2(cr1R,dvpnv1Rn)
        alf2R = np.arctan2(cr2R,dvpnv2Rn)
        alf3R = np.arctan2(cr3R,dvpnv3Rn)
        alf4R = np.arctan2(cr4R,dvpnv4Rn)


        alf1L = np.arctan2(cr1L,dvpnv1Ln)
        alf2L = np.arctan2(cr2L,dvpnv2Ln)
        alf3L = np.arctan2(cr3L,dvpnv3Ln)
        alf4L = np.arctan2(cr4L,dvpnv4Ln)

    

        d[&#39;al1R_gt&#39;] = alf1R
        d[&#39;al2R_gt&#39;] = alf2R
        d[&#39;al3R_gt&#39;] = alf3R
        d[&#39;al4R_gt&#39;] = alf4R

        d[&#39;al1L_gt&#39;] = alf1L
        d[&#39;al2L_gt&#39;] = alf2L
        d[&#39;al3L_gt&#39;] = alf3L
        d[&#39;al4L_gt&#39;] = alf4L

        d[&#39;al1R_est&#39;]=np.nan_to_num(al1ebR[0:10001])
        d[&#39;al2R_est&#39;]=np.nan_to_num(al2ebR[0:10001])
        d[&#39;al3R_est&#39;]=np.nan_to_num(al3ebR[0:10001])
        d[&#39;al4R_est&#39;]=np.nan_to_num(al4ebR[0:10001])
        d[&#39;al1L_est&#39;]=np.nan_to_num(al1ebL[0:10001])
        d[&#39;al2L_est&#39;]=np.nan_to_num(al2ebL[0:10001])
        d[&#39;al3L_est&#39;]=np.nan_to_num(al3ebL[0:10001])
        d[&#39;al4L_est&#39;]=np.nan_to_num(al4ebL[0:10001])

        _filename = self.filemocap.replace(&#39;.c3d&#39;,&#39;.mat&#39;)
        savemat(_filename,d)</div>


<div class="viewcode-block" id="CorSer.getlinkd"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.getlinkd">[docs]</a>    def getlinkd(self,a,b,techno=&#39;&#39;,t=&#39;&#39;):
        &quot;&quot;&quot;    get the distance for a link between devices

        Parameters
        ----------

        a : str | int
            name |id
        b : str | int
            name |id

        optional

        techno : str
            radio techno

        t : float | list
            given time
            or [start,stop] time


        Returns
        -------

        dist : np.array()
            all distances for all timestamps for the given link

        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S = CorSer(serie=6)
        &gt;&gt;&gt; d = S.getlinkd(&#39;AP1&#39;,&#39;WristLeft&#39;,techno=&#39;HKB&#39;)

        &quot;&quot;&quot;

        ra = a
        rb = b

        a,ia,nna,subjecta,techno = self.devmapper(a,techno)
        b,ib,nnb,subjectb,techno = self.devmapper(b,techno)


        df = self.distdf


        if (nna +&#39;-&#39; + nnb) in self.distdf.keys():
            link = nna +&#39;-&#39; + nnb
        elif (nnb +&#39;-&#39; + nna) in self.distdf.keys():
            link = nnb +&#39;-&#39; + nna
        else :
            raise AttributeError(&#39;Link between &#39; + str(ra) +&#39; and &#39; + str(rb) + &#39; is not available in distdf dataframe&#39;)

        #determine time
        if isinstance(t,list):
            tstart = t[0]
            tstop = t[-1]
            val = df[(df.index &gt;= tstart) &amp; (df.index &lt;= tstop)][link]
        elif t == &#39;&#39;:
            val = df[link]
        else :
            hstep = (df.index[1]-df.index[0])/2.
            val = df[(df.index &gt;= t-hstep) &amp; (df.index &lt;= t+hstep)][link]



        return val</div>



<div class="viewcode-block" id="CorSer.getlinkp"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.getlinkp">[docs]</a>    def getlinkp(self,a,b,technoa=&#39;&#39;,technob=&#39;&#39;,t=&#39;&#39;,fId=&#39;&#39;):
        &quot;&quot;&quot;  get a link devices positions

        Parameters
        ----------

        a : str | int
            name |id
        b : str | int
            name |id


        optional :

        technoa : str
            radio techno
        technob : str
            radio techno

        t : float | list
            given time | [time_start,time_stop]

        OR 

        fId : int
            frame id

        Returns
        -------

        pa,pb : np.array()

        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S=CorSer(serie=34)
        &gt;&gt;&gt; a,b=S.getlinkp(&#39;AP1&#39;,&#39;WristLeft&#39;)

        &quot;&quot;&quot;

        pa = self.getdevp(a,technoa,t,fId)
        pb = self.getdevp(b,technob,t,fId)

        return pa,pb</div>


<div class="viewcode-block" id="CorSer.getlink"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.getlink">[docs]</a>    def getlink(self,a,b,techno=&#39;&#39;,t=&#39;&#39;):
        &quot;&quot;&quot;    get a link value

        Parameters
        ----------

        a : str | int
            name |id
        b : str | int
            name |id


        optional :


        techno : str
            radio techno

        t : float | list
            given time
            or [start,stop] time

        Returns
        -------

        Pandas Serie

        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S=CorSer(serie=34)
        &gt;&gt;&gt; S.getlink(&#39;AP1&#39;,&#39;WristLeft&#39;)
        &quot;&quot;&quot;



        ra = a
        rb = b
        a,ia,nna,subjecta,techno = self.devmapper(a,techno)
        b,ib,nnb,subjectb,techno = self.devmapper(b,techno)

        if (&#39;HK&#39; in techno.upper()) :
            if (a +&#39;-&#39; + b) in self.hkb.keys():
                link = a +&#39;-&#39; + b
            elif (b +&#39;-&#39; + a) in self.hkb.keys():
                link = b +&#39;-&#39; + a
            else :
                raise AttributeError(&#39;Link between &#39; + str(ra) +&#39; and &#39; + str(rb) + &#39; is not available in hkb dataframe&#39;)
            df = self.hkb

        elif (&#39;BS&#39; in techno.upper()):
            if (a +&#39;-&#39; + b) in self.bespo.keys():
                link = a +&#39;-&#39; + b
            elif (b +&#39;-&#39; + a) in self.bespo.keys():
                link = b +&#39;-&#39; + a
            else:
                raise AttributeError(&#39;Link between &#39; + str(ra) +&#39; and &#39; + str(rb) + &#39; is not available in bespo dataframe&#39;)

            df = self.bespo

        elif (&#39;TCR&#39; in techno.upper()):
            if (a +&#39;-&#39; + b) in self.tcr.keys():
                link = a +&#39;-&#39; + b
            elif (b +&#39;-&#39; + a) in self.tcr.keys():
                link = b +&#39;-&#39; + a
            else:
                raise AttributeError(&#39;Link between &#39; + str(ra) +&#39; and &#39; + str(rb) + &#39; is not available in tcr dataframe&#39;)

            df = self.tcr


        #determine time
        if isinstance(t,list):
            tstart = t[0]
            tstop = t[-1]
            val = df[(df.index &gt;= tstart) &amp; (df.index &lt;= tstop)][link]
        elif t == &#39;&#39;:
            val = df[link]
        else :
            hstep = (df.index[1]-df.index[0])/2.
            val = df[(df.index &gt;= t-hstep) &amp; (df.index &lt;= t+hstep)][link]


        return val</div>



<div class="viewcode-block" id="CorSer.getdevp"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.getdevp">[docs]</a>    def getdevp(self,a,techno=&#39;&#39;,t=&#39;&#39;,fId=&#39;&#39;):
        &quot;&quot;&quot; get a  device position

        Parameters
        ----------

        a : str | int
            name |id
        techno : str
            radio techno

        optional :

        t : float | list
            given time |[time_start,time_stop]


        Returns
        -------

        pa : np.array()

        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S=CorSer(serie=34)
        &gt;&gt;&gt; a=S.getdevp(&#39;AP1&#39;,&#39;WristLeft&#39;)

        &quot;&quot;&quot;

        a,ia,nna,subjecta,techno = self.devmapper(a,techno)

        device_select = self.devdf[&#39;id&#39;] == nna


        if isinstance(t,list):
            tstart = t[0]
            tstop = t[-1]
            #findex = np.where((self.tmocap&gt;=tstart) &amp; (self.tmocap&lt;=tstop))[0]


        elif t == &#39;&#39;:
            tstart = 0.0
            tstop = 1000000
        else :
            hstep = (self.devdf[device_select].index[1]-self.devdf[device_select].index[0])/2.
            tstart = t-hstep
            tstop = t+hstep


        pa = self.devdf[(self.devdf.index &gt;= tstart) &amp;
                        (self.devdf.index &lt;= tstop) &amp;
                        device_select][[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]]

        return pa</div>




<div class="viewcode-block" id="CorSer.devmapper"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.devmapper">[docs]</a>    def devmapper(self,a,techno=&#39;&#39;):
        &quot;&quot;&quot;  retrieve name of device if input is number
             or
             retrieve number of device if input is name

        Parameters
        ----------

        a : str | int
            name |id |bodyid
        techno : str
            radio techno


        Returns
        -------

        a : string
            dev name
        ia : int
            dev number
        ba : string
            dev refernce in body
        subject : string
            body owning the device


        &quot;&quot;&quot;
        subject=&#39;&#39;

        #if a is a bodyid (e.g. &#39;HKB:16&#39;) or a body part (e.g. AnkleRight)
        if isinstance(a,str):
            # case where body id is given as input
            if (&#39;HKB&#39; in a) or (&#39;TCR&#39; in a ) or (&#39;BS&#39; in a ) :

                ba = a
                techno, ia = a.split(&#39;:&#39;)
                ia=int(ia)
                try:
                    if techno.upper() == &#39;TCR&#39;:
                        a = self.idTCR[ia]
                    elif (techno.upper() == &#39;HKB&#39;):
                        a = self.idHKB[ia]
                    elif (techno.upper() == &#39;BS&#39;):
                        a = self.idBS[ia]
                except:
                    raise AttributeError(&#39;No device &#39; + a + &#39; for techno &#39; +techno)

                for b in self.B:
                    if not &#39;Cylindre&#39; in b:
                        if ba in self.B[b].dev.keys():
                            subject = b
                            break

            #case where body part (e.g. AnkleRight) is given. Here techno is mandatory
            else :

                if techno == &#39;&#39;:
                    if self.typ != &#39;FULL&#39;:
                        if self.typ == &#39;HKBS&#39;:
                            raise AttributeError(&#39;Please indicate the radio techno in argument : HKB or BS&#39;)
                        else :
                            techno = self.typ
                    else:
                        raise AttributeError(&#39;Please indicate the radio techno in argument : TCR, HKB, BS&#39;)


                try :
                    if techno.upper() == &#39;TCR&#39;:
                        ia = self.dTCR[a]
                        ba=&#39;TCR:&#39;+str(ia)
                    elif (techno.upper() == &#39;HKB&#39;) :
                        ia = self.dHKB[a]
                        ba=&#39;HKB:&#39;+str(ia)
                    elif techno.upper() == &#39;BS&#39;:
                        ia = self.dBS[a]
                        ba=&#39;BS:&#39;+str(ia)
                except:
                    raise AttributeError(&#39;No device on body part: &#39; + a + &#39; for techno &#39; +techno)


                for b in self.B:
                    if not &#39;Cylindre&#39; in b:
                        if ba in self.B[b].dev.keys():
                            subject = b
                            break

        # an id (number) is given
        else:
            # techno autodetection raise an error if conflict and invite to precise radio techno
            if techno == &#39;&#39;:
                if hasattr(self,&#39;idHKB&#39;):
                    if a in self.idHKB.keys() :
                        if techno == &#39;&#39;:
                            techno = &#39;HKB&#39;
                        else :
                            raise AttributeError(&#39;Please indicate the radio techno in argument : TCR, HKB, BS&#39;)
                if hasattr(self,&#39;idBS&#39;):
                    if a in self.idBS.keys():
                        if techno == &#39;&#39;:
                            techno = &#39;BS&#39;
                        else :
                            raise AttributeError(&#39;Please indicate the radio techno in argument : TCR, HKB, BS&#39;)
                if hasattr(self,&#39;idTCR&#39;):
                    if a in self.idTCR.keys():
                        if techno == &#39;&#39;:
                            techno = &#39;TCR&#39;
                        else :
                            raise AttributeError(&#39;Please indicate the radio techno in argument : TCR, HKB, BS&#39;)

            try :
                if techno.upper() == &#39;TCR&#39;:
                    ia = a
                    a = self.idTCR[a]
                    ba=&#39;TCR:&#39;+str(ia)
                elif (techno.upper() == &#39;HKB&#39;) :
                    ia = a
                    a = self.idHKB[a]
                    ba=&#39;HKB:&#39;+str(ia)

                elif (techno.upper() == &#39;BS&#39;) :
                    ia = a
                    a = self.idBS[a]
                    ba=&#39;BS:&#39;+str(ia)
            except:
                raise AttributeError(&#39;No device with ID: &#39; + str(a) + &#39; for techno &#39; +techno)


            for b in self.B:
                if not &#39;Cylindre&#39; in b:
                    if ba in self.B[b].dev.keys():
                        subject = b
                        break

        return a,ia,ba,subject,techno</div>


<div class="viewcode-block" id="CorSer.align"><a class="viewcode-back" href="../../../api/references.html#pylayers.measures.cormoran.CorSer.align">[docs]</a>    def align(self,devdf,hkbdf):

        &quot;&quot;&quot; DEPRECATED align time of 2 data frames:

        the time delta of the second data frame is applyied on the first one
        (e.g. time for devdf donwsampled by hkb data frame time)


        Parameters
        ----------

        devdf : device dataframe
        hkbdf : hkbdataframe

        Return
        ------

        devdfc : 
            aligned copy device dataframe
        hkbdfc : 
            aligned copy hkbdataframe

        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S=CorSer(6)
        &gt;&gt;&gt; devdf = S.devdf[S.devdf[&#39;id&#39;]==&#39;HKB:15&#39;]
        &gt;&gt;&gt; hkbdf = S.hkb[&#39;AP1-AnkleLeft&#39;]
        &gt;&gt;&gt; devdf2,hkbdf2 = S.align(devdf,hkbdf)


        &quot;&quot;&quot;

        print (&#39;warning DEPRECATED&#39;)

        devdfc=copy.deepcopy(devdf)
        hkbdfc=copy.deepcopy(hkbdf)
        idev = devdfc.index
        ihkb = hkbdfc.index

        devdfc.index = pd.to_datetime(idev,unit=&#39;s&#39;)
        hkbdfc.index = pd.to_datetime(ihkb,unit=&#39;s&#39;)
        import ipdb
        ipdb.set_trace()
        sf = (hkbdfc.index[2]-hkbdfc.index[1]).microseconds
        devdfc= devdfc.resample(str(sf)+&#39;U&#39;)

        devdfc.index = pd.Series([val.time() for val in devdfc.index])
        hkbdfc.index = pd.Series([val.time() for val in hkbdfc.index])

        return devdfc,hkbdfc</div>


    def _apply_offset(self,techno):
        &quot;&quot;&quot; apply offset from self.offset[self._filename][techno+&#39;_index&#39;]

            if offset &gt;0
                add np.nan at the begining
            if offset &lt;0
                first values of self.hkb will be dropped
        &quot;&quot;&quot;

        if techno == &#39;HKB&#39;:
            df = self.hkb
        elif techno == &#39;TCR&#39;:
            df = self.tcr
        elif techno == &#39;BS&#39;:
            df = self.bespo
        else :
            raise AttributeError(&#39;Unknown tecnology got applying offset&#39;)


        offset = self.offset[self._filename][techno.lower()+&#39;_index&#39;]
        if offset &lt;= 0 :
            index = df.index
            df = df.iloc[-offset:]
            df.index = index[0:offset]
        else :
            #extract time values
            npahkbi = df.index.values
            step = npahkbi[1]- npahkbi[0]
            nstart = npahkbi[0]+ (step * (offset))
            df.index = pd.Index(npahkbi + nstart)

            #add blank at begining
            df = pd.DataFrame({},columns=df.keys(),index=npahkbi[:offset])
            ndf=pd.concat([df,df])
            df=ndf
        if techno == &#39;HKB&#39;:
            self.thkb = df.index
        elif techno == &#39;TCR&#39;:
            self.ttcr = df.index
        elif techno == &#39;BS&#39;:
            self.tbs = df.index


    def _apply_hkb_offset(self):
        &quot;&quot;&quot; apply offset from self.offset[self._filename][&#39;hkb_index&#39;]

            if offset &gt;0
                add np.nan at the begining
            if offset &lt;0
                first values of self.hkb will be dropped
        &quot;&quot;&quot;


        # offset = self.offset[self._filename][&#39;hkb_index&#39;]
        # if offset &gt;=0:
        #     self.hkb = self.hkb.iloc[offset:]
        # else :
        #     # new length
        #     lhkb = len(self.hkb) + (-offset)
        #     #extract time values
        #     npahkbi = self.hkb.index.values
        #     #calculate new termianl time
        #     step = npahkbi[1]- npahkbi[0]
        #     nstop = npahkbi[-1]+ (step * (-offset))
        #     ni = np.linspace(0,nstop,lhkb)
        #     df = pd.DataFrame({},columns=self.hkb.keys(),index=ni[0:-offset])

        #     self.hkb.index=pd.Index(ni[-offset:])
        #     ndf=pd.concat([df,self.hkb])

        #     self.hkb=ndf

        offset = self.offset[self._filename][&#39;hkb_index&#39;]
        if offset &lt;= 0 :
            index = self.hkb.index
            self.hkb = self.hkb.iloc[-offset:]
            self.hkb.index = index[0:offset]
        else :
            #extract time values
            npahkbi = self.hkb.index.values
            step = npahkbi[1]- npahkbi[0]
            nstart = npahkbi[0]+ (step * (offset))
            self.hkb.index = pd.Index(npahkbi + nstart)

            #add blank at begining
            df = pd.DataFrame({},columns=self.hkb.keys(),index=npahkbi[:offset])
            ndf=pd.concat([df,self.hkb])
            self.hkb=ndf
            self.thkb = self.hkb.index

    def _align_on_devdf(self,typ=&#39;&#39;):
        &quot;&quot;&quot; align hkb or bs time on device data frame (devdf) time index

        In place (a.k.a. replace old self.hkb by the resampled one)

        Parameters
        ----------

        typp : &#39;HKB&#39; |&#39;BS&#39;

        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S = CorSer(6)
        &gt;&gt;&gt; devdf = S.devdf[S.devdf[&#39;id&#39;]==&#39;HKB:15&#39;]
        &gt;&gt;&gt; hkbdf = S.hkb[&#39;AP1-AnkleLeft&#39;]
        &gt;&gt;&gt; devdf2 = S._align_on_hkb(devdf,hkbdf,typ =&#39;HKB&#39;)


        &quot;&quot;&quot;
        if typ == &#39;HKB&#39;:
            idf = self.hkb
        elif typ == &#39;BS&#39;:
            idf = self.bespo
        elif typ == &#39;TCR&#39;:
            idf = self.tcr

        # mocap time
        #
        # 0 0.010001 0.020002
        mocapindex = pd.to_datetime(self.tmocap,unit=&#39;s&#39;)
        # radio time
        # 0  0.023  0.0473
        idf.index = pd.to_datetime(idf.index,unit=&#39;s&#39;)


        sf = (mocapindex[2]-mocapindex[1]).microseconds
        df = idf.resample(str(sf)+&#39;U&#39;,fill_method=&#39;ffill&#39;)

        nindex = time2npa(df.index)
        df.index = pd.Index(nindex)

        if typ == &#39;HKB&#39;:
            self.hkb = df
        elif typ == &#39;BS&#39;:
            self.bespo = df
        elif typ == &#39;TCR&#39;:
            self.tcr = df

    def _align_devdf_on_hkb(self,devdf,hkbdf):
        &quot;&quot;&quot; NOT USED Practically
            align time of 2 data frames:

        the time delta of the second data frame is applyied on the first one
        (e.g. time for devdf donwsampled by hkb data frame time)


        Parameters
        ----------

        devdf : device dataframe
        hkbdf : hkbdataframe

        Return
        ------

        devdfc : 
            aligned copy device dataframe
        hkbdfc : 
            aligned copy hkbdataframe

        Examples
        --------

        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; S=CorSer(6)
        &gt;&gt;&gt; devdf = S.devdf[S.devdf[&#39;id&#39;]==&#39;HKB:15&#39;]
        &gt;&gt;&gt; hkbdf = S.hkb[&#39;AP1-AnkleLeft&#39;]
        &gt;&gt;&gt; devdf2 = S._align_devdf_on_hkb(devdf,hkbdf)


        &quot;&quot;&quot;

        devdfc=copy.deepcopy(devdf)

        hkbdfc=copy.deepcopy(hkbdf)

        idev = devdfc.index
        ihkb = hkbdfc.index

        devdfc.index = pd.to_datetime(idev,unit=&#39;s&#39;)
        hkbdfc.index = pd.to_datetime(ihkb,unit=&#39;s&#39;)
        sf = (hkbdfc.index[2]-hkbdfc.index[1]).microseconds

        # cannot resapmple devdf directly because multiple similar index values
        #need to resampl each groupby separately
        gb = devdfc.groupby([&#39;id&#39;])
        #get device id 
        devid,idevid = np.unique(devdfc[&#39;id&#39;],return_index=True)
        #save corresponding subject to each device
        subject = {devid[i]:devdfc[&#39;subject&#39;].iloc[i] for i in idevid}
        # resample each group separatley
        dgb={d:gb.get_group(d).resample(str(sf)+&#39;U&#39;) for d in devid}
        #re insert subject and device id information in each resampled group
        for d in dgb:
            dgb[d][&#39;subject&#39;]=subject[d]
            dgb[d][&#39;id&#39;]=d

        # create the realigned Dataframe

        lgb = [dgb[d] for d in dgb]
        df = pd.concat(lgb)
        df.sort_index(inplace=True)

        nindex = time2npa(df.index)
        df.index = pd.Index(nindex)
        cols=[&#39;id&#39;,&#39;subject&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;v&#39;,&#39;vx&#39;,&#39;vy&#39;,&#39;vz&#39;,&#39;a&#39;,&#39;ax&#39;,&#39;ay&#39;,&#39;az&#39;]
        df=df[cols]

        return df</div>

<div class="viewcode-block" id="dist_sh2rssi"><a class="viewcode-back" href="../../../api/pylayers.measures.cormoran.dist_sh2rssi.html#pylayers.measures.cormoran.dist_sh2rssi">[docs]</a>def dist_sh2rssi(dist,Ssh,offsetdB=15):
    &quot;&quot;&quot;
    Parameters
    ----------

    dist
    Ssh 
    offsetdB : float

    &quot;&quot;&quot;
    if type(dist)==pd.Series:
        z1 = 10*np.log10((1./dist**2)).values
    else:
        z1 = 10*np.log10((1./dist**2))

    u = np.where(Ssh[0]==1)[0]
    z1[u] = z1[u]-offsetdB
    z1 = z1-np.mean(z1)
    return(z1)</div>

#    z2 = Srssi.values
#    z2m = np.mean(z2[~np.isnan(z2)])
#    z2[np.isnan(z2)]=z2m
#    z2 = z2-np.mean(z2)
#    z1n = z1/np.sqrt(np.sum(z1*z1))
#    z2n = z2/np.sqrt(np.sum(z2*z2))
#    cn,dec,ratio = resync(z1n,z2n)
#    tdec.append(dec)

#tratio.append(ratio)
#if ratio &gt; maxratio:
#    maxratio =  ratio

    # def get_data(self,a,b):


    #     T=self.tcr[a+&#39;-&#39;+b]
    #     T.name=T.name+&#39;-tcr&#39;
    #     H=self.hkb[a+&#39;-&#39;+b]
    #     H.name=H.name+&#39;-hkb&#39;
    #     udhk = self.accessdm(a,b,&#39;HKB&#39;)
    #     udtcr = self.accessdm(a,b,&#39;HKB&#39;)
    #     dist_tcr=self.dist[:,udtcr[0],udtcr[1]]
    #     dist_hkb=self.dist[:,udhk[0],udhk[1]]
    #     tdist=np.linspace(0,self.dist.shape[0]/100.,self.dist.shape[0])
    #     D_tcr=pd.Series(dist_tcr,index=tdist)
    #     D_tcr.name = &#39;dist-tcr&#39;
    #     D_hkb=pd.Series(dist_hkb,index=tdist)
    #     D_hkb.name = &#39;dist-hkb&#39;

    #     return T,H,D_tcr,D_hkb


    # def get_dataframes(self,a,b):
    #     &quot;&quot;&quot; assemble all series in a DataFrame
    #     &quot;&quot;&quot;

    #     T,H,DT,DH = self.get_data(a,b)
    #     NH=(np.sqrt(1/(10**(H/10)))/4e4)
    #     NHc=NH-NH.mean()
    #     DHc=DH-DH.mean()
    #     inh = NHc.index
    #     idh = DHc.index
    #     NHc.index = pd.to_datetime(inh,unit=&#39;m&#39;)
    #     DHc.index = pd.to_datetime(idh,unit=&#39;m&#39;)
    #     sD = (DHc.index[1]-DHc.index[0])
    #     sf= str(int(sD.microseconds*1e-3)) + &#39;ms&#39;
    #     NHcr = NHc.resample(sf,fill_method=&#39;ffill&#39;)
    #     return NHcr,DHc
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team.
      Last updated on Jan 26, 2019.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>