

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.measures.mesmimo &mdash; PyLayers</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_issue314.html">Exemple of issue 314</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction_polar.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html">1&nbsp;&nbsp;&nbsp;pylayers.util.project Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.layout">2&nbsp;&nbsp;&nbsp;pylayers.gis.layout Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.selectl">3&nbsp;&nbsp;&nbsp;pylayers.gis.selectl Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.srtm">4&nbsp;&nbsp;&nbsp;pylayers.gis.srtm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.osmparser">5&nbsp;&nbsp;&nbsp;pylayers.gis.osmparser Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.ezone">6&nbsp;&nbsp;&nbsp;pylayers.gis.ezone Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antenna">7&nbsp;&nbsp;&nbsp;pylayers.antprop.antenna Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.aarray">8&nbsp;&nbsp;&nbsp;pylayers.antprop.aarray Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.spharm">9&nbsp;&nbsp;&nbsp;pylayers.antprop.spharm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antssh">10&nbsp;&nbsp;&nbsp;pylayers.antprop.antssh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antvsh">11&nbsp;&nbsp;&nbsp;pylayers.antprop.antvsh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.slab">12&nbsp;&nbsp;&nbsp;pylayers.antprop.slab Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.signature">13&nbsp;&nbsp;&nbsp;pylayers.antprop.signature Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.interactions">14&nbsp;&nbsp;&nbsp;pylayers.antprop.interactions Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffraction">15&nbsp;&nbsp;&nbsp;pylayers.antprop.diffraction Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffRT">16&nbsp;&nbsp;&nbsp;pylayers.antprop.diffRT Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.rays">17&nbsp;&nbsp;&nbsp;pylayers.antprop.rays Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.loss">18&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.channel">19&nbsp;&nbsp;&nbsp;pylayers.antprop.channel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id39">20&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coverage">21&nbsp;&nbsp;&nbsp;pylayers.antprop.coverage Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coeffModel">22&nbsp;&nbsp;&nbsp;pylayers.antprop.coeffModel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.link">23&nbsp;&nbsp;&nbsp;pylayers.simul.link Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit">24&nbsp;&nbsp;&nbsp;pylayers.simul.exploit Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit_simulnet">25&nbsp;&nbsp;&nbsp;pylayers.simul.exploit_simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simulnet">26&nbsp;&nbsp;&nbsp;pylayers.simul.simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simultraj">27&nbsp;&nbsp;&nbsp;pylayers.simul.simultraj Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.exploit.simnet">28&nbsp;&nbsp;&nbsp;pylayers.exploit.simnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesuwb">29&nbsp;&nbsp;&nbsp;pylayers.measures.mesuwb Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesmimo">30&nbsp;&nbsp;&nbsp;pylayers.measures.mesmimo Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.cormoran">31&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.vna.E5072A">32&nbsp;&nbsp;&nbsp;pylayers.measures.vna.E5072A Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.parker.smparker">33&nbsp;&nbsp;&nbsp;pylayers.measures.parker.smparker Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.bsignal">34&nbsp;&nbsp;&nbsp;pylayers.signal.bsignal Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.standard">35&nbsp;&nbsp;&nbsp;pylayers.signal.standard Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.device">36&nbsp;&nbsp;&nbsp;pylayers.signal.device Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.DF">37&nbsp;&nbsp;&nbsp;pylayers.signal.DF Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.waveform">38&nbsp;&nbsp;&nbsp;pylayers.signal.waveform Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.agent">39&nbsp;&nbsp;&nbsp;pylayers.mobility.agent Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.ban.body">40&nbsp;&nbsp;&nbsp;pylayers.mobility.ban.body Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id138">41&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pylayers.measures.mesmimo</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.measures.mesmimo</h1><div class="highlight"><pre>
<span></span>#!/usr/bin/python
#-*- coding:Utf-8 -*-
from __future__ import print_function
from pylayers.signal.bsignal import *
from pylayers.antprop.aarray import *
from pylayers.util.project import *
from pylayers.antprop.channel import *
from pylayers.gis.readvrml import *
import numpy as np
import matplotlib.pylab as plt
import matplotlib.animation as animation
import scipy as sp
import scipy.special as ss
import numpy.linalg as la
from time import sleep
import math as mt
from pylayers.measures.vna.E5072A import *
&quot;&quot;&quot;
.. curentmodule:: pylayers.antprop.mesmimo

.. autosummary::
    :members:

&quot;&quot;&quot;

<div class="viewcode-block" id="MIMO"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO">[docs]</a>class MIMO(object):
    &quot;&quot;&quot; This class handles the data coming from a MIMO Channel Sounder

    Parameters
    ----------
    H    : raw channel matrix in frequency domain
    Hcal : calibrated channel matrix in frequency domain
    hcal : channel matrix in time domain

    &quot;&quot;&quot;
    def __init__(self,**kwargs):
        &quot;&quot;&quot;

        Parameters
        ----------

        filename : string
        rep : string
        fminGHz : float
        fmaxGHz : float
        Nf
        calibration : Boolean
        Nz : int
            Number of Zeros
        nT : int
            (default = 1)

        Notes
        -----

        Data are placed in the directory mesdir + rep directory

        &quot;&quot;&quot;
        defaults = { &#39;_filename&#39;:&#39;&#39;,
                    &#39;rep&#39;:&#39;&#39;,
                    &#39;Nf&#39;:1601,
                    &#39;fminGHz&#39; : 1.8,
                    &#39;fmaxGHz&#39; :2.2,
                    &#39;calibration&#39;:True,
                    &#39;time&#39;:True,
                    &#39;Nz&#39; : 100,
                    &#39;Nt&#39; : 4,
                    &#39;Nr&#39; : 8,
                    &#39;Aat&#39;: [],
                    &#39;Aar&#39;: [],
                    &#39;snrdB&#39;: np.linspace(0,25,100)
                  }

        for k in defaults:
            if k not in kwargs:
                kwargs[k]=defaults[k]

        _filename = kwargs.pop(&#39;_filename&#39;)
        rep = kwargs.pop(&#39;rep&#39;)
        Nf =  kwargs.pop(&#39;Nf&#39;)
        fminGHz = kwargs.pop(&#39;fminGHz&#39;)
        fmaxGHz = kwargs.pop(&#39;fmaxGHz&#39;)
        calibration = kwargs.pop(&#39;calibration&#39;)
        time = kwargs.pop(&#39;time&#39;)
        Nz = kwargs.pop(&#39;Nz&#39;)
        Nt = kwargs.pop(&#39;Nt&#39;)
        Nr = kwargs.pop(&#39;Nr&#39;)
        self.snrdB = kwargs.pop(&#39;snrdB&#39;)

        self.Aat = kwargs.pop(&#39;Aat&#39;)
        self.Aar = kwargs.pop(&#39;Aar&#39;)
        if self.Aar == []:
            self.Aar = AntArray(N=[8,1,1])
        if self.Aat == []:
            self.Aat = AntArray(N=[4,1,1])


        self.Nf  = Nf
        self.freq = np.linspace(fminGHz,fmaxGHz,Nf)
        self.rep = rep
        self.Nt = Nt
        self.Nr = Nr

        #pdb.set_trace()
        if _filename != &#39;&#39;:
            self.filename = mesdir + rep + _filename
            # load file
            self.loadraw()
            if calibration:
                self.calibration()
                if time:
                    # reshaping for using ift (todo update ift for MDA !!)
                    #Hcal = TChannel(x=self.Hcal.x,y=np.reshape(self.Hcal.y,(Nt*Nr,Nf)))
                    Hcal = Tchannel(self.Hcal.x,np.reshape(self.Hcal.y,(Nt*Nr,Nf)))
                    hcal = Hcal.ift(Nz=Nz,ffts=1)
                    shh = hcal.y.shape
                    self.hcal = TUsignal(hcal.x,np.reshape(hcal.y,(Nr,Nt,shh[-1])))


    def __repr__(self):
        st = &#39;MIMO Object&#39;+&#39;\n&#39;
        st = st + &#39;axe 0  Nr : &#39;+str(self.Nr)+ &#39;\n&#39;
        st = st + &#39;axe 1  Nt : &#39;+str(self.Nt)+ &#39;\n&#39;
        st = st + &#39;axe 2  Nf : &#39;+str(self.Nf)+ &#39;\n&#39;
        return(st)

    def __sub__(self,m):
        N = MIMO()
        N.freq = self.freq
        N.Nt = self.Nt
        N.Nr = self.Nr
        N.Hcal = self.Hcal - m.Hcal
        return(N)

<div class="viewcode-block" id="MIMO.loadraw"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.loadraw">[docs]</a>    def loadraw(self):
        &quot;&quot;&quot; load a MIMO Nr x Nt raw data sounder file


        The sounder output file is a 2 columns ASCII csv file
        Module (dB) ;  Angle (Degree)

        &quot;&quot;&quot;
        fd  = open(self.filename)
        lis = fd.readlines()
        fd.close()
        module   = []
        phasedeg = []

        for l in lis:
            l.replace(&#39;\r\n&#39;,&#39;&#39;)
            g = l.split(&#39;;&#39;)
            module.append(float(g[0]))
            phasedeg.append(float(g[1]))

        m   = np.array(module)
        phi = np.array(phasedeg)*np.pi/180.
        m   = m.reshape(self.Nr*self.Nt,self.Nf)
        phi = phi.reshape(self.Nr*self.Nt,self.Nf)
        y   = 10**(m/20)*np.exp(1j*phi)
        #
        # Nr x Nt x Nf    (8x4x1601)
        #
        y   = y.reshape(self.Nr,self.Nt,self.Nf)

        self.H = Tchannel(x=self.freq,y=y)</div>

<div class="viewcode-block" id="MIMO.calibration"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.calibration">[docs]</a>    def calibration(self):
        &quot;&quot;&quot; Apply calibration files

        &quot;&quot;&quot;
        for iR in range(self.Nr):
            for iT in range(self.Nt):
                _filename = &#39;Calib&#39;+str(iT+1)+&#39;x&#39;+str(iR+1)+&#39;.txt&#39;
                C = MIMO(_filename=_filename,rep=&#39;/calibration/&#39;,calibration=False,Nt=self.Nt)
                try:
                    #tc = np.vstack((tc,C.H.y[iR*4+iT,:]))
                    tc = np.vstack((tc,C.H.y[iR,iT,:]))
                except:
                    #tc = C.H.y[iR*4+iT,:]
                    tc = C.H.y[iR,iT,:]

        #MIMO
        # Nr x Nt x Nf
        tc = tc.reshape(self.Nr,self.Nt,self.Nf)
        # C.freq , Nf
        self.C = Tchannel(x=C.freq,y=tc)
        self.Hcal = self.H/self.C
        del self.H
        del self.C</div>

<div class="viewcode-block" id="MIMO.calHa"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.calHa">[docs]</a>    def  calHa(self,**kwargs):
        &quot;&quot;&quot; calculate the Ha function (angular domain representation)

        fcGHz : float
        duR   : grid step in uR
        duT   : grid step in uT
        time  : boolean
        taumin  : float 0
        taumax  : float
        Nz   : int (20000)

        See : David Tse (7.70 pp 373)

        &quot;&quot;&quot;
        defaults = {&#39;fcGHz&#39;:2,
                    &#39;duR&#39;:0.05,
                    &#39;duT&#39;:0.05,
                    &#39;time&#39;:False,
                    &#39;taumin&#39;:0,
                    &#39;taumax&#39;:80,
                    &#39;Nz&#39;:20000
                    }
        for k in defaults:
            if k not in kwargs:
                kwargs[k]=defaults[k]

        fcGHz = kwargs.pop(&#39;fcGHz&#39;)
        duR = kwargs.pop(&#39;duR&#39;)
        duT = kwargs.pop(&#39;duT&#39;)
        time = kwargs.pop(&#39;time&#39;)
        taumin = kwargs.pop(&#39;taumin&#39;)
        taumax = kwargs.pop(&#39;taumax&#39;)
        Nz = kwargs.pop(&#39;Nz&#39;)

        # f : m x n x uR x f
        fGHz = self.freq[None,None,None,:]
        # m : m x n x  uR x f
        m = np.arange(self.Nr)[:,None,None,None]
        # uR : m x n x uR x f
        uR = np.arange(-1,1,duR)[None,None,:,None]
        # eR : m x n x uR x f
        eR = np.exp(-1j*np.pi*m*uR*fGHz/fcGHz)
        # S : m x n x uR x f
        S  = self.Hcal.y[:,:,None,:] * eR
        #  SR : n x uR x uT x f
        SR = np.sum(S,axis=0)[:,:,None,:]
        # n : n x uR x uT x f
        n = np.arange(self.Nt)[:,None,None,None]
        # uT : n x uR x uT x f
        uT = np.arange(-1,1,duT)[None,None,:,None]
        # eT : n x uR x uT x f
        eT = np.exp(-1j*np.pi*n*uT*fGHz/fcGHz)
        # summation along axix m and n
        self.Ha = np.sum(SR*eT,axis=0)

        self.uR = np.arange(-1,1,duR)
        self.uT = np.arange(-1,1,duT)

        NuR = len(self.uR)
        NuT = len(self.uT)
        Nf  = len(self.freq)

        if time:
            #T = fft.ifft(self.h,axis=2)
            #self.h = abs(fft.fftshift(T,axes=2))
            Ha = FUsignal(self.freq,np.reshape(self.Ha,(NuR*NuT,Nf)))
            ha = Ha.ift(Nz=Nz,ffts=1)
            ut = np.where((h.x&gt;taumin) &amp; (h.x&lt;taumax))[0]
            xlim = ha.x[ut]
            ylim = ha.y[...,ut]
            npts = len(ut)
            self.ha = TUsignal(xlim,np.reshape(ylim,(NuR,NuT,npts)))</div>

<div class="viewcode-block" id="MIMO.normalize"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.normalize">[docs]</a>    def normalize(self):
        &quot;&quot;&quot; Normalization of H

        &quot;&quot;&quot;

        HdH,U,S,V = self.transfer()
        HdH = HdH.swapaxes(0,2)
        self.rg = np.real(np.sqrt(np.trace(HdH)/(self.Nt*self.Nr)))
        self.Hcal.y = self.Hcal.y/self.rg
        self.normalize=True</div>


<div class="viewcode-block" id="MIMO.svd"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.svd">[docs]</a>    def svd(self):
        &quot;&quot;&quot; singular value decomposition of matrix H

        Parameters
        ----------

        The native H matrix is currently (nr x nt x nf ). For applying a
        broadcasted svd a reshaping in (nf x nr x nt ) is required.
        In the future,  it would be a good thing to define the MIMO matrix as

        nf x na x nb structure from the begining

        or

        ns x nf x na x nb

        Returns
        -------

        U  : nf x nr x nr
        D  : nf x min(nr,nt)
        Vh : nf x nt x nt

        &quot;&quot;&quot;
        # H  : nr x nt x nf
        H  = self.Hcal.y
        # H1  : nf x nt x nr
        H1 = H.swapaxes(0,2)
        # H2  : nf x nr x nt
        H2 = H1.swapaxes(1,2)
        U,D,Vh = la.svd(H2)
        return(U,D,Vh)</div>


<div class="viewcode-block" id="MIMO.transfer"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.transfer">[docs]</a>    def transfer(self):
        &quot;&quot;&quot; calculate transfer matrix.
            it involves H and Hd against svd() which acts only over H.

        Returns
        -------

        HdH : Hermitian transfer matrix  (nf x nt x nt )
        U   : Unitary tensor  (nf x nt x nt )
        S   : Singular values (nf x nt)
        V   : = Ud (in that case because HdH Hermitian)  (nf x nt x nt)

        HdH = U L U^{\dagger}
        
        Transfered to Mchannel 
        DONE 
        &quot;&quot;&quot;

        # H  : nr x nt x nf
        H   = self.Hcal.y
        # Hd : nt x nr x nf
        Hd  = np.conj(self.Hcal.y.swapaxes(0,1))
        #HdH : nt x nt x nf
        HdH = np.einsum(&#39;ijk,jlk-&gt;ilk&#39;,Hd,H)
        # HdH : nf x nt x nt
        HdH  = HdH.swapaxes(0,2)
        #U   : nf x nt x nt
        #S   : nf x nt
        #V   : nf x nt x nt
        U,S,V  = la.svd(HdH)

        return (HdH,U,S,V)</div>

<div class="viewcode-block" id="MIMO.Bcapacity"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.Bcapacity">[docs]</a>    def Bcapacity(self,Pt=np.array([1e-3]),Tp=273):
        &quot;&quot;&quot; calculates BLAST deterministic MIMO channel capacity

        Parameters
        ----------

        Pt : np.array (,NPt)
            the total power is assumed uniformaly distributed over the whole bandwidth
        Tp : Receiver Temperature (K)

        Returns
        -------

        C   : spectral efficiency (bit/s/Hz)
            np.array (Nf,NPt)
        rho : SNR
            np.array (Nf,Nt,NPt)

            log_2(det(I+(Et/(N0Nt))HH^{H})
        
        Transferd to Mchannel 

        Done
        
        &quot;&quot;&quot;

        fGHz  = self.Hcal.x
        Nf    = len(fGHz)
        BGHz  = fGHz[-1]-fGHz[0]
        dfGHz = fGHz[1]-fGHz[0]

        if type(Pt)==float:
            Pt=np.array([Pt])

        # White Noise definition
        #
        # Boltzman constantf    = len(fGHz)

        kB = 1.03806488e-23

        # N0 ~ J ~ W/Hz ~ W.s

        N0 = kB*Tp


        # Evaluation of the transfer tensor
        #
        # HdH :

        HdH,U,S,V = self.transfer()

        #singular value decomposition of channel tensor (broadcasted along frequency axis)


        Us,D,Vsh = self.svd()


        # Vsh : nf x nt x nt

        It  = np.eye(self.Nt)
        Ir  = np.eye(self.Nr)

        #Ps = (Pt/Nf)/(self.Nt)
        Ps  = Pt/(self.Nt)
        #Ps1 = Pt/(self.Nt*self.Nf)

        # equi amplitude vector (nf,nt,1)
        #wu  = np.sqrt(Ps[None,None,None,:]*np.ones((self.Nf,self.Nt))[:,:,None,None]/self.Nf)
        # spatial subchanel weights (nf,nt,1)
        #Vshwu = np.einsum(&#39;kijp,kjlp-&gt;kilp&#39;,Vsh[:,:,:,None],wu)
        # nf x nt x 1 x power
        # Ps2   = Vshwu*np.conj(Vshwu)

        Pb  = N0*BGHz*1e9   # Watt

        #Pb2 = N0*dfGHz*1e9*np.ones((self.Nf,self.Nt))


        # rho : nf x nt x power
        #S2 = np.real(D[:,:,None]*np.conj(D[:,:,None]))
        #
        rho  = (Ps[None,None,:]/Pb)*S[:,:,None]
        #rho1 = (Ps1[None,None,:]/Pb2[:,:,None])*S[:,:,None]
        #rho2 = (Ps2[:,:,0,:]/Pb2[:,:,None])*S2
        #pdb.set_trace()
        #coeff = Ps/Pb
        #M     = It[None,...] + coeff*HdH
        #detM  = la.det(M)
        #logdetM = np.real(np.log(detM)/np.log(2))
        #C1  = dfGHz*logdetM

        #CB  = dfGHz*np.sum(np.log(1+rho)/np.log(2),axis=1)
        #CB  = dfGHz*np.sum(np.log(1+rho)/np.log(2))
        CB   = dfGHz*np.sum(np.log(1+rho)/np.log(2),axis=1)
        #CB1  = dfGHz*np.sum(np.log(1+rho1)/np.log(2),axis=1)
        #CB2  = dfGHz*np.sum(np.log(1+rho2)/np.log(2),axis=1)
        #return(M,detM,logdetM,C1,C2,S)
        return(rho,CB)</div>

<div class="viewcode-block" id="MIMO.Scapacity"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.Scapacity">[docs]</a>    def Scapacity(self,Pt=1e-3,Tp=273):
        &quot;&quot;&quot; equivalent SISO capacity
        &quot;&quot;&quot;

        pass</div>



<div class="viewcode-block" id="MIMO.WFcapacity"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.WFcapacity">[docs]</a>    def WFcapacity(self,Pt=np.array([1e-3]),Tp=273):
        &quot;&quot;&quot; calculates deterministic MIMO channel capacity

        Parameters
        ----------

        Pt :  the total power to be distributed over the different spatial
            channels using water filling
        Tp : Receiver Noise Temperature (K)

        Returns
        -------

        C : capacity (bit/s)
        rho : SNR (in linear scale)

            log_2(det(It + HH^{H})

        &quot;&quot;&quot;

        fGHz  = self.Hcal.x
        Nf    = len(fGHz)
        # Bandwidth
        BGHz  = fGHz[-1]-fGHz[0]
        # Frequency step
        dfGHz = fGHz[1]-fGHz[0]

        # White Noise definition
        #
        # Boltzman constant

        kB = 1.03806488e-23

        # N0 ~ J ~ W/Hz ~ W.s

        N0 = kB*Tp


        # Evaluation of the transfer tensor

        HdH,U,ld,V = self.transfer()

        # Identity matrices

        It = np.eye(self.Nt)
        Ir = np.eye(self.Nr)

        #
        # Iterative implementation of Water Filling algorithm
        #

        # pb : (nf,nt)   noise power (Watt)
        pb = N0*dfGHz*1e9*np.ones((self.Nf,self.Nt))
        # pt : (nf,nt,power)  Total power uniformly spread over (nt*nf-1)
        pt = Pt[None,None,:]/((self.Nf-1)*self.Nt)
        mu = pt
        Q0 = np.maximum(0,mu-pb[:,:,None]/ld[:,:,None])
        u  = np.where(Q0&gt;0)[0]

        Peff = np.sum(np.sum(Q0,axis=0),axis=0)
        deltamu = pt
        while (np.abs(Peff-Pt)&gt;1e-16).any():
            mu = mu + deltamu
            Q = np.maximum(0,mu-pb[:,:,None]/ld[:,:,None])
            Peff = np.sum(np.sum(Q,axis=0),axis=0)
            #print &quot;mu , Peff : &quot;,mu,Peff
            usup = np.where(Peff&gt;Pt)[0]
            mu[:,:,usup] = mu[:,:,usup]- deltamu[:,:,usup]
            deltamu[:,:,usup] = deltamu[:,:,usup]/2.
        Qn   = Q/pb[:,:,None]
        rho  = Qn*ld[:,:,None]

        Cwf  = dfGHz*np.sum(np.log(1+rho)/np.log(2),axis=1)


        return(rho,Cwf)</div>

    # def ber(self,cmd=&#39;QPSK&#39;,m = 4, snrdB = np.linspace(0,25,100)):
    #     &quot;&quot;&quot;computation of bit error rate

    #     Parameters
    #     ----------
    #     cmd : &#39;QPSK&#39; or M-QAM

    #     M : number of bit (int) (2 or 4 or 8)
    #     &quot;&quot;&quot;
        
    #     snr = 10**(snrdB/10.)
    #     M = 2**m
    #     eta = np.log(M, 2)

    #     if cmd == &#39;QPSK&#39;:
    #         berqpsk = 0.5 * ss.erfc(sqrt(snr))

    #     if cmd == &#39;M-PSK&#39;:
    #         bermpsk =  1 / eta * ss.erfc(sqrt(snr * eta) * np.sin(np.pi / M))

    #     if cmd == &#39;M-QAM&#39;:
    #         bermqam = 2 / eta * (1 - 1 / sqrt(M)) * ss.erfc(sqrt(3 * snr * eta/(2 * (M - 1)))
        
    #     return(berqpsk,bermpsk,bermqam)

    # def berplot(self):
    #     &quot;&quot;&quot;plot BER functions
    #     &quot;&quot;&quot;

    #     berqpsk,bermpsk,bermqam = self.ber(cmd=&#39;&#39;,m = 4, snrdB = np.linspace(0,25,100))

    #     if cmd == &#39;QPSK&#39;:
    #         plt.semilogy(snrdB,berqpsk,label=&#39;QPSK&#39;)

    #     if cmd == &#39;M-PSK&#39;:
    #         plt.semilogy(snrdB,bermqpsk,label=&#39;QPSK&#39;)

    #     if cmd == &#39;M-QAM&#39;:
    #         plt.semilogy(snrdB,bermqam,label=&#39;4-PSK&#39;)

    #     sns.set_style(&quot;darkgrid&quot;)
    #     plt.ylim([10**-9, 0.5])
    #     plt.figure(figsize=(20,20))
    #     plt.xlabel(&#39;SNR(dB)&#39;,fontsize=15)
    #     plt.ylabel(&#39;Bit Error Rate&#39;,fontsize=15)
    #     plt.legend(loc=&#39;best&#39;)
    #     plt.title(&quot;Digital Modulation Bit Error Rate&quot;)
    #     plt.show()

<div class="viewcode-block" id="MIMO.linear_ZF"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.linear_ZF">[docs]</a>    def linear_ZF(self,cmd=&#39;QPSK&#39;,m = 4, snrdB = np.linspace(0,25,100)):
        &quot;&quot;&quot;linear Zero Forcing precoding
        Parameters
        ----------
        
        &quot;&quot;&quot;

        # H  : nr x nt x nf
        H = self.Hcal.y
        # Hd : nt x nr x nf
        Hd  = np.conj(self.Hcal.y.swapaxes(0,1))
        H_inv = np.linalg.inv(H)
        H_inv_d = np.transpose(H_inv)
        tr_mat = np.matrix.trace(H_inv*H_inv_d)
        beta = sqrt(self.Nt/(tr_mat))
        W_zf = np.dot(beta,H_inv)</div>



<div class="viewcode-block" id="MIMO.linear_MMSE"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.linear_MMSE">[docs]</a>    def linear_MMSE(self,cmd=&#39;QPSK&#39;,m = 4, snrdB = np.linspace(0,25,100)):
        &quot;&quot;&quot;linear MMSE precoding

        Parameters
        ----------
        
        &quot;&quot;&quot;
        # H  : nr x nt x nf
        H = self.Hcal.y
        # Hd : nt x nr x nf
        Hd  = np.conj(self.Hcal.y.swapaxes(0,1))
        HHd =np.einsum(&#39;ijk,jlk-&gt;ilk&#39;,H,Hd)
        Hh = np.transpose(H)
        H_inv = np.linalg.inv(H)
        H_inv_d = np.transpose(H_inv)
        tr_mat = np.matrix.trace(H_inv*H_inv_d)
        beta = sqrt(self.Nt/(tr_mat))
        
        Pt = np.logspace(-3,1,100)
        kB = 1.3806488e-23
        N0 = kB*273
        B  = 400e6
        Pb = N0*B
        A = np.linalg.inv(HHd + snr)
        B = np.dot(Hh,A)
        W_mmse = beta * B</div>



    # def meas(self):
    #     &quot;&quot;&quot; Allows meas from VNA and Scanner
    #     &quot;&quot;&quot;

    #     defaults = { &#39;lavrg&#39;:&#39;[&#39;1&#39;,&#39;999&#39;]&#39;,
    #                  &#39;lif&#39;:&#39;[&#39;1000&#39;,&#39;300000&#39;,&#39;500000&#39;]&#39;,
    #                  &#39;lpoints&#39; : &#39;[201,401,601,801,1601]&#39;,
    #                  &#39;Nf&#39;:1601,
    #                  &#39;fminGHz&#39; : 1.8,
    #                  &#39;fmaxGHz&#39; :2.2,
    #                  &#39;calibration&#39;:True,
    #                  &#39;time&#39;:True,
    #                  &#39;Nmeas&#39; : 100,
    #                  &#39;Nt&#39; : 4,
    #                  &#39;Nr&#39; : 8,
    #                  &#39;Aat&#39;: [],
    #                  &#39;Aar&#39;: []
    #               }

    #     for k in defaults:
    #         if k not in kwargs:
    #             kwargs[k]=defaults[k]

    #     fminGHz = kwargs.pop(&#39;fminGHz&#39;)
    #     fmaxGHz = kwargs.pop(&#39;fmaxGHz&#39;)
    #     lavrg   =  kwargs.pop(&#39;lavrg&#39;)
    #     lif     = kwargs.pop(&#39;lif&#39;)
    #     lpoints = kwargs.pop(&#39;lpoints&#39;)
    #     Nmeas = kwargs.pop(&#39;Nmeas&#39;)


    #     ##################
    #     ### VNA
    #     #################


    #     # FROM MAIN OF E5072A.py
    #     vna = SCPI(&quot;129.20.33.201&quot;,verbose=False)
    #     ident = vna.getIdent()
    #     print &quot;Talking to : &quot;,ident
    #     vna.write(&quot;FORM:DATA REAL&quot;)
    #     #vna.write(&quot;SENS:AVER:ON&quot;)
    #     vna.select(param=&#39;S21&#39;,chan=1)
    #     print &quot;channel &quot;+str(chan)+ &quot; selected&quot;
    #     vna.setf(startGHz=1.8,stopGHz=2.2)
    #     print &quot;fstart (GHz) : &quot;,startGHz
    #     print &quot;fstop (fGHz) : &quot;,stopGHz


    #     ######
    #     vna.setf(fminGHz,fmaxGHz)
    #     prefix = &#39;cal_&#39;
    #     S = []
    #     lt = []

    #     tic = time.time()

    #     for i in lif:
    #         vna.write(&quot;:SENS1:BAND &quot; + str(i))
    #         for n in lpoints:
    #             fGHz = np.linspace(startGHz,stopGHz,n)
    #             vna.setnpoint(n)
    #             com = &quot;:CALC1:DATA:SDAT?\n&quot;
    #             npts = vna.getnpoints()
    #             print &quot;Nbrs of points : &quot;,npts
    #             S = vna.getdata(n)
    #             lt.append(time.time())
    #             try:
    #                 S21.append(S)
    #             except:
    #                 S21=S
    #             S.save(prefix+str(n))
    #             #for k in range(Nmeas):
    #                 #S = vna.getdata(Npoints=Npoints)
    #                 #lt.append(time.time())
    #                 #try:
    #                     #S21.append(S)
    #                 #except:
    #                     #S21=S
    #     toc = time.time()
    #     print toc-tic
    #     #lt.append(toc-tic)
    #     #lS.append(S21)
    #     #del S21
    #     #vna.close()
    #     #S21.save(&#39;calibration.mat&#39;)


<div class="viewcode-block" id="MIMO.mulcplot"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.mulcplot">[docs]</a>    def mulcplot(self,mode,**kwargs):
        &quot;&quot;&quot;
        &quot;&quot;&quot;

        defaults = { &#39;types&#39; : [&#39;m&#39;],
                   &#39;titles&#39; : np.array([[&#39;11&#39;,&#39;12&#39;,&#39;13&#39;,&#39;14&#39;],
                 [&#39;21&#39;,&#39;22&#39;,&#39;23&#39;,&#39;34&#39;],
                 [&#39;31&#39;,&#39;32&#39;,&#39;33&#39;,&#39;34&#39;],
                 [&#39;41&#39;,&#39;42&#39;,&#39;43&#39;,&#39;44&#39;],
                 [&#39;51&#39;,&#39;52&#39;,&#39;53&#39;,&#39;54&#39;],
                 [&#39;61&#39;,&#39;62&#39;,&#39;63&#39;,&#39;64&#39;],
                 [&#39;71&#39;,&#39;72&#39;,&#39;73&#39;,&#39;74&#39;],
                 [&#39;81&#39;,&#39;82&#39;,&#39;83&#39;,&#39;84&#39;]]),
                   &#39;ylabels&#39;:np.array([[&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;]]),
                   &#39;xlabels&#39;:np.array([[&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;fGHz&#39;,&#39;fGHz&#39;,&#39;fGHz&#39;,&#39;fGHz&#39;]]),
                   &#39;labels&#39;:np.array([[&#39;calibrated&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;]])
                 }

        for key, value in defaults.items():
            if key not in kwargs:
                kwargs[key] = value

        if mode==&#39;f&#39;:
            fig,ax = self.Hcal.plot(**kwargs)
        else:
            kwargs[&#39;xlabels&#39;] = np.array([[&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;],
                 [&#39;t(ns)&#39;,&#39;t(ns)&#39;,&#39;t(ns)&#39;,&#39;t(ns)&#39;]]),
            fig,ax = self.hcal.plot(**kwargs)

        return(fig,ax)

        return fig,ax</div>


<div class="viewcode-block" id="MIMO.grid"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.grid">[docs]</a>    def grid(self,M,
             OR=np.array([3.4,0.73]),
             OT=np.array([5.29,6.65]),
             cT=np.array([-0.07,0]),
             cR=np.array([0.07,0])):
        &quot;&quot;&quot; Evaluate the data on a grid in the plane

            Parameters
            ----------

            M : np.array() (Nx x Ny)
            OR : np.array (,2)
                Origin of receiver [3.4,0.73]
            OT : np.array (,2)
                Origin of transmitter [5.29,6.65]
            cR : np.array (,2)
                array receiving vector [0.07,0]
            cT : np.array (,2)
                array transmitting vector [-0.07,0]

            Notes
            -----

           Updated object members

            self.grid : M  (Nx x Ny x 2)
            self.gloc : TUsignal (x (,ntau) y (Nx x Ny,ntau) )

        &quot;&quot;&quot;

        aR = cR[0]/np.sqrt(cR[0]**2+cR[1]**2)
        bR = cR[1]/np.sqrt(cR[0]**2+cR[1]**2)

        aT = cT[0]/np.sqrt(cT[0]**2+cT[1]**2)
        bT = cT[1]/np.sqrt(cT[0]**2+cT[1]**2)
        # mapping
        uT = (aT*(M[...,0]-OT[0])+bT*(M[...,1]-OT[1]))/np.sqrt((M[...,0]-OT[0])**2+(M[...,1]-OT[1])**2)
        uR = (aR*(M[...,0]-OR[0])+bR*(M[...,1]-OR[1]))/np.sqrt((M[...,0]-OR[0])**2+(M[...,1]-OR[1])**2)
        # sampling in uR and uT
        uuR = self.uR
        uuT = self.uT
        # index in uR and uT
        iUr=np.array(map(lambda x : np.where(abs(uuR-x)==(abs(uuR-x)).min())[0][0], np.ravel(uR)))
        iUt=np.array(map(lambda x : np.where(abs(uuT-x)==(abs(uuT-x)).min())[0][0], np.ravel(uT)))

        self.grid = M
        shM = M.shape
        self.gloc = TUsignal(self.h.x,self.h.y[iUr,iUt,:])</div>
        #self.gloc = self.h[iUr,iUt,:]
        #shL =  gloc.shape
        #assert(shL[0]==shM[0]*shM[1])
        #self.gloc = np.reshape(gloc,(shM[0],shM[1],shL[1]))


    def plot(self,**kwargs):
        &quot;&quot;&quot; plot channel

        Pramaters
        ---------

        frequency:True
        phase:True
        dB:True
        cal:True
        fig:[]
        ax:[]
        color&#39;:&#39;k&#39;

        &quot;&quot;&quot;
        defaults = {&#39;frequency&#39;:True,
                    &#39;phase&#39;:False,
                    &#39;dB&#39;:True,
                    &#39;cal&#39;:True,
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k]=defaults[k]

        frequency = kwargs.pop(&#39;frequency&#39;)
        phase = kwargs.pop(&#39;phase&#39;)
        dB = kwargs.pop(&#39;dB&#39;)
        cal = kwargs.pop(&#39;cal&#39;)

        fig,ax=plt.subplots(8,self.Nt,sharex=True,sharey=True,**kwargs)

        if cal:
            H = self.Hcal
        else:
            H = self.H
        for iR in range(self.Nr):
            for iT in range(self.Nt):
                k = iR*4+iT
                if frequency:
                    if not phase:
                        if dB:
                            #ax[iR,iT].plot(H.x,20*np.log10(abs(H.y[k,:])),color=color)
                            ax[iR,iT].plot(H.x,20*np.log10(abs(H.y[iR,iT,:])),color=color)
                            #ax[iR,iT].plot(H.x,20*np.log10(abs(H.y[iR,iT,:])),color=&#39;k&#39;)
                        else:
                            #ax[iR,iT].plot(H.x,abs(H.y[k,:]),color=&#39;k&#39;)
                            ax[iR,iT].plot(H.x,abs(H.y[iR,iT,:]),color=&#39;k&#39;)
                    else:
                        #ax[iR,iT].plot(H.x,np.unwrap(np.angle(H.y[k,:])),color=color)
                        ax[iR,iT].plot(H.x,np.unwrap(np.angle(H.y[iR,iT,:])),color=color)
                else:
                        ax[iR,iT].plot(self.h.x,abs(self.h.y[iR,iT,:]),color=color)
                if (iR==7):
                    ax[iR,iT].set_xlabel(&#39;f (GHz)&#39;)
                    ax[iR,iT].plot(H.x,np.unwrap(np.angle(H.y[iR,iT,:])),color=&#39;k&#39;)
                else:
                        ax[iR,iT].plot(self.hcal.x,abs(self.hcal.y[iR,iT,:]),color=&#39;k&#39;)
                if (iR==7):
                    ax[iR,iT].set_xlabel(&#39;Frequency (GHz)&#39;)
                    ax[iR,iT].set_title(str(iR+1)+&#39;x&#39;+str(iT+1))
        return(fig,ax)

<div class="viewcode-block" id="MIMO.showgrid"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.showgrid">[docs]</a>    def showgrid(self,**kwargs):
        &quot;&quot;&quot; show the data on a spatial grid

        Parameters
        ----------

        layout:[],
        s:50,
        vmin : 0,
        vmax: 0.5,
        linewidth:0,
        fig:[],
        ax:[],
        save:True,
        filename:&#39;showgrid1&#39;,
        title:&#39;&#39;,
        save:True,
        dB : False,
        OR : np.array([3.4,0.73]),
        OT : np.array([5.29,6.65]),
        cR : np.array([0.07,0]),
        cT : np.array([-0.07,0]),
        target : np.array([]),
        gating : False,
        dynamic : 30


        Notes
        -----

        This function accepts a Layout as input and allows to display
        a projection of the spatio-delay volume on a 2D grid.


        &quot;&quot;&quot;
        defaults = { &#39;layout&#39;:[],
                    &#39;s&#39;:50,
                    &#39;vmin&#39; : 0,
                    &#39;vmax&#39;: 0.5,
                    &#39;linewidth&#39;:0,
                    &#39;fig&#39;:[],
                    &#39;ax&#39;:[],
                    &#39;save&#39;:True,
                    &#39;filename&#39;:&#39;showgrid1&#39;,
                    &#39;title&#39;:&#39;&#39;,
                    &#39;save&#39;:True,
                    &#39;dB&#39;:False,
                    &#39;OR&#39; : np.array([3.4,0.73]),
                    &#39;OT&#39; : np.array([5.29,6.65]),
                    &#39;cR&#39; : np.array([0.07,0]),
                    &#39;cT&#39; : np.array([-0.07,0]),
                    &#39;target&#39; : np.array([]),
                    &#39;gating&#39;:False
                   }


        for key, value in defaults.items():
            if key not in kwargs:
                kwargs[key] = value

        OR = kwargs[&#39;OR&#39;]
        OT = kwargs[&#39;OT&#39;]
        cR = kwargs[&#39;cR&#39;]
        cT = kwargs[&#39;cT&#39;]

        ULAR = OR+np.arange(8)[:,np.newaxis]*cR-3.5*cR
        ULAT = OT+np.arange(4)[:,np.newaxis][::-1]*cT-1.5*cT

        if kwargs[&#39;gating&#39;]:
            dTM = np.sqrt((self.grid[...,0]-OT[0])**2+(self.grid[...,1]-OT[1])**2)
            dRM = np.sqrt((self.grid[...,0]-OR[0])**2+(self.grid[...,1]-OR[1])**2)
            # dM : Nx,Ny
            dM  = dTM+dRM
            # dM : ,Nx x Ny
            dM = np.ravel(dM)
            # 6 sigma = 1/400MHz
            # 6 sigma = 2.5ns
            # sigma = (2.5/6)
            # alpha = 1/(2 sigma^2) = 2*(2.5)**2/36 = 0.347
            #
            alpha = 0.347
            # Gaussian gate
            # Laplacian gate
            # Nx x Ny x Ntau
            self.gate = np.exp(-alpha*(dM[:,np.newaxis]/0.3-self.gloc.x[np.newaxis,:])**2)
            data = self.gloc.y*self.gate
            data = np.sum(abs(data),axis=1)
        else:
            data = np.sum(abs(self.gloc.y),axis=1)

        if kwargs[&#39;fig&#39;]==[]:
            fig = plt.figure(figsize=(10,10))
            ax  = fig.add_subplot(111)
        else:
            fig=kwargs[&#39;fig&#39;]
            ax = kwargs[&#39;ax&#39;]

        if kwargs[&#39;dB&#39;]:
            data = 20*np.log10(data)
            vmax = data.max()
            # clipping @ vmax - dynamic
            vmin = vmax-kwargs[&#39;dynamic&#39;]
        else:
            vmin = data.min()
            vmax = data.max()

        scat = ax.scatter(self.grid[...,0],
                               self.grid[...,1],
                               c= data,
                               s=kwargs[&#39;s&#39;],
                               vmin=vmin,
                               vmax=vmax,
                               linewidth=kwargs[&#39;linewidth&#39;])

        cb = plt.colorbar(scat)
        if kwargs[&#39;dB&#39;]:
            cb.set_label(&#39;Level (dB)&#39;)
        else:
            cb.set_label(&#39;Linear Level&#39;)


        # plot ULAs

        ax.plot(ULAR[:,0],ULAR[:,1],&#39;+b&#39;)
        ax.plot(ULAT[:,0],ULAT[:,1],&#39;+g&#39;)
        plt.axis(&#39;off&#39;)

        # plot target

        if kwargs[&#39;target&#39;]!=[]:
            target = ax.scatter(kwargs[&#39;target&#39;][0],kwargs[&#39;target&#39;][1],c=&#39;black&#39;,s=100)

        # display layout
        if kwargs[&#39;layout&#39;] != []:
            L = kwargs[&#39;layout&#39;]
            #fig,ax = L.showG(&#39;s&#39;,fig=fig,ax=ax,nodes=False)
            L.display[&#39;ednodes&#39;]=False
            L.display[&#39;nodes&#39;]=False
            L.display[&#39;title&#39;]=kwargs[&#39;title&#39;]
            fig,ax = L.showG(&#39;s&#39;,fig=fig,ax=ax,nodes=False)

        if kwargs[&#39;save&#39;]:
            fig.savefig(kwargs[&#39;filename&#39;]+&#39;.pdf&#39;)
            fig.savefig(kwargs[&#39;filename&#39;]+&#39;.png&#39;)

        return fig,ax</div>

<div class="viewcode-block" id="MIMO.animgrid"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.animgrid">[docs]</a>    def animgrid(self,**kwargs):
        &quot;&quot;&quot;
        &quot;&quot;&quot;

        defaults = { &#39;layout&#39;:[],
                    &#39;s&#39;:100,
                    &#39;vmin&#39; : 0,
                    &#39;vmax&#39;: 0.5,
                    &#39;linewidth&#39;:0,
                    &#39;fig&#39;:[],
                    &#39;ax&#39;:[],
                    &#39;filename&#39;:&#39;animgrid1&#39;,
                    &#39;save&#39;:True,
                    &#39;abs&#39;:True,
                    &#39;title&#39;:&#39;&#39;,
                   }

        for key, value in defaults.items():
            if key not in kwargs:
                kwargs[key] = value


        if kwargs[&#39;fig&#39;]==[]:
            fig = plt.figure(figsize=(20,20))
            ax  = fig.add_subplot(111)

        if kwargs[&#39;layout&#39;] != []:
            L = kwargs[&#39;layout&#39;]
            fig,ax = L.showG(&#39;s&#39;,fig=fig,ax=ax,nodes=False)

        Nframe = self.gloc.y.shape[1]
        if kwargs[&#39;abs&#39;]:
            scat = ax.scatter(self.grid[...,0],
                               self.grid[...,1],
                               c=abs(self.gloc.y[:,0]),
                               s=kwargs[&#39;s&#39;],
                               vmin=kwargs[&#39;vmin&#39;],
                               vmax=kwargs[&#39;vmax&#39;],
                               linewidth=kwargs[&#39;linewidth&#39;])
        else:
            scat = ax.scatter(self.grid[...,0],
                               self.grid[...,1],
                               c=self.gloc.y[:,0],
                               s=kwargs[&#39;s&#39;],
                               vmin=kwargs[&#39;vmin&#39;],
                               vmax=kwargs[&#39;vmax&#39;],
                               linewidth=kwargs[&#39;linewidth&#39;])

        title  = ax.text(0.1,0.9,kwargs[&#39;title&#39;],transform=ax.transAxes,fontsize=18)
        cb   = plt.colorbar(scat)
        delay_template = &#39;%d : tau = %5.2f (ns) d= %5.2f (m)&#39;
        delay_text  = ax.text(0.1,0.9,&#39;&#39;,transform=ax.transAxes,fontsize=18)

        def init():
            delay_text.set_text(&#39;&#39;)
            if kwargs[&#39;abs&#39;]:
                scat.set_array(abs(self.gloc.y[:,0]))
            else:
                scat.set_array(self.gloc.y[:,0])
            return scat,delay_text

        def animate(i):
            delay_text.set_text(delay_template%(i,self.gloc.x[i],self.gloc.x[i]*0.3))
            if kwargs[&#39;abs&#39;]:
                scat.set_array(abs(self.gloc.y[:,i]))
            else:
                scat.set_array(abs(self.gloc.y[:,i]))
            return scat,delay_text

        anim = animation.FuncAnimation(fig,
                                       animate,
                                       init_func=init,
                                       frames=Nframe,
                                       interval=1,
                                       blit=True)
        if kwargs[&#39;save&#39;]:
            anim.save(kwargs[&#39;filename&#39;]+&#39;.mp4&#39;, fps=5)
        return fig,ax,anim</div>

<div class="viewcode-block" id="MIMO.plot"><a class="viewcode-back" href="../../../api/pylayers.measures.mesmimo.MIMO.html#pylayers.measures.mesmimo.MIMO.plot">[docs]</a>    def plot(self,frequency=True,phase=False,dB=True,cal=True,fig=[],ax=[],color=&#39;k&#39;):
        &quot;&quot;&quot;

        &quot;&quot;&quot;
        if fig==[]:
            fig,ax=plt.subplots(8,self.Nt,sharex=True,sharey=True)
        if cal:
            H = self.Hcal
        else:
            H = self.H
        for iR in range(self.Nr):
            for iT in range(self.Nt):
                k = iR*4+iT
                if frequency:
                    if not phase:
                        if dB:
                            #ax[iR,iT].plot(H.x,20*np.log10(abs(H.y[k,:])),color=color)
                            ax[iR,iT].plot(H.x,20*np.log10(abs(H.y[iR,iT,:])),color=color)
                        else:
                            #ax[iR,iT].plot(H.x,abs(H.y[k,:]),color=&#39;k&#39;)
                            ax[iR,iT].plot(H.x,abs(H.y[iR,iT,:]),color=&#39;k&#39;)
                    else:
                        #ax[iR,iT].plot(H.x,np.unwrap(np.angle(H.y[k,:])),color=color)
                        ax[iR,iT].plot(H.x,np.unwrap(np.angle(H.y[iR,iT,:])),color=color)
                else:
                        ax[iR,iT].plot(self.h.x,abs(self.h.y[iR,iT,:]),color=color)
                if (iR==7):
                    ax[iR,iT].set_xlabel(&#39;f (GHz)&#39;)
                ax[iR,iT].set_title(str(iR+1)+&#39;x&#39;+str(iT+1))
        return(fig,ax)</div></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team.
      Last updated on Jan 29, 2019.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>