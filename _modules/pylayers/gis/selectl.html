

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.gis.selectl &mdash; PyLayers</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_issue314.html">Exemple of issue 314</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_cover.html">Outdoor Radio Coverage with Deygout Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction_polar.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html">1&nbsp;&nbsp;&nbsp;pylayers.util.project Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.layout">2&nbsp;&nbsp;&nbsp;pylayers.gis.layout Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.selectl">3&nbsp;&nbsp;&nbsp;pylayers.gis.selectl Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.srtm">4&nbsp;&nbsp;&nbsp;pylayers.gis.srtm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.osmparser">5&nbsp;&nbsp;&nbsp;pylayers.gis.osmparser Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.ezone">6&nbsp;&nbsp;&nbsp;pylayers.gis.ezone Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antenna">7&nbsp;&nbsp;&nbsp;pylayers.antprop.antenna Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.aarray">8&nbsp;&nbsp;&nbsp;pylayers.antprop.aarray Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.spharm">9&nbsp;&nbsp;&nbsp;pylayers.antprop.spharm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antssh">10&nbsp;&nbsp;&nbsp;pylayers.antprop.antssh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antvsh">11&nbsp;&nbsp;&nbsp;pylayers.antprop.antvsh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.slab">12&nbsp;&nbsp;&nbsp;pylayers.antprop.slab Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.signature">13&nbsp;&nbsp;&nbsp;pylayers.antprop.signature Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.interactions">14&nbsp;&nbsp;&nbsp;pylayers.antprop.interactions Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffraction">15&nbsp;&nbsp;&nbsp;pylayers.antprop.diffraction Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffRT">16&nbsp;&nbsp;&nbsp;pylayers.antprop.diffRT Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.rays">17&nbsp;&nbsp;&nbsp;pylayers.antprop.rays Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.loss">18&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.channel">19&nbsp;&nbsp;&nbsp;pylayers.antprop.channel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id39">20&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coverage">21&nbsp;&nbsp;&nbsp;pylayers.antprop.coverage Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coeffModel">22&nbsp;&nbsp;&nbsp;pylayers.antprop.coeffModel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.link">23&nbsp;&nbsp;&nbsp;pylayers.simul.link Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit">24&nbsp;&nbsp;&nbsp;pylayers.simul.exploit Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit_simulnet">25&nbsp;&nbsp;&nbsp;pylayers.simul.exploit_simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simulnet">26&nbsp;&nbsp;&nbsp;pylayers.simul.simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simultraj">27&nbsp;&nbsp;&nbsp;pylayers.simul.simultraj Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.exploit.simnet">28&nbsp;&nbsp;&nbsp;pylayers.exploit.simnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesuwb">29&nbsp;&nbsp;&nbsp;pylayers.measures.mesuwb Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesmimo">30&nbsp;&nbsp;&nbsp;pylayers.measures.mesmimo Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.cormoran">31&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.vna.E5072A">32&nbsp;&nbsp;&nbsp;pylayers.measures.vna.E5072A Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.parker.smparker">33&nbsp;&nbsp;&nbsp;pylayers.measures.parker.smparker Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.bsignal">34&nbsp;&nbsp;&nbsp;pylayers.signal.bsignal Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.standard">35&nbsp;&nbsp;&nbsp;pylayers.signal.standard Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.device">36&nbsp;&nbsp;&nbsp;pylayers.signal.device Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.DF">37&nbsp;&nbsp;&nbsp;pylayers.signal.DF Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.waveform">38&nbsp;&nbsp;&nbsp;pylayers.signal.waveform Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.agent">39&nbsp;&nbsp;&nbsp;pylayers.mobility.agent Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.ban.body">40&nbsp;&nbsp;&nbsp;pylayers.mobility.ban.body Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id138">41&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pylayers.gis.selectl</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.gis.selectl</h1><div class="highlight"><pre>
<span></span># -*- coding: utf-8 -*-
r&quot;&quot;&quot;

.. currentmodule:: pylayers.gis.selectl

.. autosummary::

&quot;&quot;&quot;
from __future__ import print_function
import os
import pdb
from PIL import Image
import numpy as np
from pylayers.util import geomutil as geu
from pylayers.util import pyutil as pyu
import pylayers.util.plotutil as plu

import matplotlib.pyplot as plt
#from pylayers.util.easygui import *
from matplotlib.widgets import RectangleSelector

import copy


<div class="viewcode-block" id="SelectL"><a class="viewcode-back" href="../../../api/pylayers.gis.selectl.SelectL.html#pylayers.gis.selectl.SelectL">[docs]</a>class SelectL(object):
    &quot;&quot;&quot; Associates a Layout and a figure

    &#39;l&#39;  : select activelayer
    &#39;i&#39;  : back to init state
    &#39;e&#39;  : edit segment
    &#39;CTLR + t&#39;  : translate  structure
    &#39;h&#39;  : add subsegment
    &#39;d&#39;  : delete subsegment
    &#39;r&#39;  : refresh
    &#39;o&#39;  : toggle overlay
    &#39;m&#39;  : toggle mode (point or segment)
    &#39;z&#39;  : change display parameters
    &#39;q&#39;  : quit interactive mode
    &#39;x&#39;  : save .str2 file
    &#39;w&#39;  : display all layers

    &quot;&quot;&quot;
    def __init__(self,L,fig,ax):
        &quot;&quot;&quot; SelectL is a class which associates a Layout and a figure

        Parameters
        ----------

        L   : Layout
        fig : figure
        ax  : axes

        &quot;&quot;&quot;
        self.fig=fig
        self.ax=ax

        self.L = L
        self.text = self.ax.text(0.05, 0.95, &#39;Selected : none&#39;,
                                 transform=self.ax.transAxes, va=&#39;top&#39;)
        self.set_origin = False
        self.set_x = False
        self.set_y = False
        self.pt = []
        self.seg = []
        self.coseg = []
        self.pt1 = np.array([])
        self.pt2 = np.array([])
        self.selected_pt1 = 0
        self.selected_pt2 = 0
        self.selected_edge1 = 0
        self.selected_edge2 = 0
        self.current_layer = self.L.display[&#39;activelayer&#39;]
        self.npsel = 0
        self.nedge_sel = 0
        self.indp = 0
        self.state = &#39;Init&#39;
        self.evt=&#39;&#39;
        self.statename={&#39;Init&#39;:&#39;Point/Segment Selection&#39;,
                &#39;CP&#39;:&#39;Create Point&#39;,
                &#39;SP1&#39;:&#39;Select Point 1&#39;,
                &#39;SP2&#39;:&#39;Select Point 2, Click Again for Creating Segment&#39;,
                &#39;SS&#39;:&#39;Select Segment&#39;,
                &#39;SSS&#39;:&#39;Select Sub Segment&#39;,
                &#39;CPS&#39;:&#39;Click again for Split Segment&#39;,
                &#39;CPSS&#39;:&#39;Create Point On Sub Segment&#39;,
                &#39;SMP&#39;: &#39;Multiple Points Selection&#39;,
                &#39;SMS&#39;: &#39;Multiple Segments Selection&#39;
                }
        self.help={&#39;&#39;:&#39;&#39;,
                &#39;Init&#39;:&#39;Select Point or Segment/ F1: Multiple selection/ F2: Create Point/ CTRL+q: Quit&#39;,
                &#39;CP&#39;:&#39;Create Point/ +CTRL same x/ +SHIFT same y&#39;,
                &#39;SP1&#39;:&#39;Select Point/ Click another point to create segment&#39;,
                &#39;SP2&#39;:&#39;Click Again for Creating Segment&#39;,
                &#39;SS&#39;:&#39;e: edit segment properties, h: add a sub-segment&#39;,
                &#39;SSS&#39;:&#39;Select Sub Segment&#39;,
                &#39;CPS&#39;:&#39;Click again for Split Segment&#39;,
                &#39;CPSS&#39;:&#39;Create Point On Sub Segment&#39;,
                &#39;SMP&#39;: &#39;t: toggle point/segment, Shift + select : add selected points, CTRL + select : remove selected points&#39;,
                &#39;SMS&#39;: &#39;t: toggle point/segment, e: Edit Selected Segments Propeties&#39;
                }
        self.nsel = 0
        self.ax.axis(self.L.display[&#39;box&#39;])
        plt.title(self.statename[self.state])
        self.undoGs=[]
        self.bundo=False
        self.update_state()
        self.shift_is_held = False
        self.ctrl_is_held = False
        self.alt_is_held = False
        self.selectpt=[]
        self.selectseg=[]
        self.selected=&#39;pt&#39;
        # save matplotlib config
        self.rcconf = {}
        self.rcconf[&#39;keymap.save&#39;]= plt.rcParams[&#39;keymap.save&#39;]
        plt.rcParams[&#39;keymap.save&#39;]=[]


        self.ddoc = {&#39;l&#39;  : &#39;select activelayer&#39;,
            &#39;i&#39;  :&#39; back to init state&#39;,
            &#39;j&#39;  :&#39; vertical and horizontal scaling&#39;,
            &#39;e&#39;  :&#39; edit segment&#39;,
            &#39;b&#39;  :&#39; edit segment keyboard&#39;,
            &#39;CTRL + t&#39;  :&#39; translate  structure&#39;,
            &#39;h&#39;  :&#39; add subsegment&#39;,
            &#39;d&#39;  :&#39; delete selected object&#39;,
            &#39;r&#39;  :&#39; refresh&#39;,
            &#39;o&#39;  :&#39; toggle overlay (&lt;&gt; CP mode) set origin (CP mode) &#39;,
            &#39;m&#39;  :&#39; toggle mode (point or segment)&#39;,
            &#39;n&#39;  : &#39;toggle node label display &#39;,
            &#39;z&#39;  : &#39;change display parameters&#39;,
            &#39;x&#39;  : &#39;save .str2 and .ini file&#39;,
            &#39;w&#39;  :&#39; display all layers&#39;,
            &#39;v&#39;  :&#39; flip layout w.r.t y axis&#39;,
            &#39;f&#39;  :&#39; toggle points nodes display&#39;,
            &#39;g&#39;  :&#39; toggle segments nodes display&#39;,
            &#39;=&#39;  :&#39; increment layer &#39;,
            &#39;,&#39;  : &#39;this help&#39;,
            &#39;delete&#39; :&#39;delete selected&#39;,
            &#39;$&#39;  :&#39; decrement layer &#39;}


<div class="viewcode-block" id="SelectL.show"><a class="viewcode-back" href="../../../api/pylayers.gis.selectl.SelectL.html#pylayers.gis.selectl.SelectL.show">[docs]</a>    def show(self,fig,ax,clear=False, dnodes=True, dedges=True,  font_size=14, title=&#39;&#39;):
        &quot;&quot;&quot; show layout

        Parameters
        ----------
        clear     : boolean
        dnodes    : boolean
        dedges    : boolean
        dlabels   : boolean
        font_size : integer
        title     : string

        &quot;&quot;&quot;
        if title==&#39;&#39;:
            title = self.statename[self.state]
        axis = self.ax.axis()
        self.L.display[&#39;clear&#39;] = clear
        self.L.display[&#39;fontsize&#39;] = font_size
        self.L.display[&#39;title&#39;] = title
        self.fig,self.ax = self.L.showGs(fig=self.fig,ax=self.ax,axis=axis,isonb=True)
        return(self.fig,self.ax)</div>


<div class="viewcode-block" id="SelectL.plotselptseg"><a class="viewcode-back" href="../../../api/pylayers.gis.selectl.SelectL.html#pylayers.gis.selectl.SelectL.plotselptseg">[docs]</a>    def plotselptseg(self,pt,color=&#39;y&#39;,ms=10,marker=&#39;o&#39;):
        &quot;&quot;&quot; plot selected point or segments

        Parameters
        ----------

            pt : list
                list of points or segments to plot

        &quot;&quot;&quot;
        if len(pt)&gt;0:
            pts = np.array([self.L.Gs.pos[x] for x in pt])
            p1 = self.ax.plot(pts[:,0], pts[:,1],marker=marker,
                                visible=True,
                                color =color,
                                ms=10,
                                alpha=0.4)
            self.fig.canvas.draw()

        return self.fig,self.ax</div>


<div class="viewcode-block" id="SelectL.OnPress"><a class="viewcode-back" href="../../../api/pylayers.gis.selectl.SelectL.html#pylayers.gis.selectl.SelectL.OnPress">[docs]</a>    def OnPress(self,event,verbose=True):
        &quot;&quot;&quot; Keyboard event handler


        Parameters
        ----------

        event
        verbose

        &quot;&quot;&quot;

        # fig = plt.gcf()
        # ax  = plt.gca()
        # selected

        self.nsel = 0
        self.ptsel = np.array([])
        self.evt = event.key
        if event.key == &#39;shift&#39;:
            self.shift_is_held = True
        if event.key == &#39;control&#39;:
            self.ctrl_is_held = True
        if event.key == &#39;alt&#39;:
            self.alt_is_held = True


        if verbose:
            try:
                print(&quot;Evenement :&quot;, self.evt,self.ddoc[self.evt])
            except:
                print(self.evt + &#39;N/A&#39;)
        self.new_state()</div>


<div class="viewcode-block" id="SelectL.OnRelease"><a class="viewcode-back" href="../../../api/pylayers.gis.selectl.SelectL.html#pylayers.gis.selectl.SelectL.OnRelease">[docs]</a>    def OnRelease(self, event):
        if event.key == &#39;shift&#39;:
           self.shift_is_held = False
        if event.key == &#39;control&#39;:
            self.ctrl_is_held = False
        if event.key == &#39;alt&#39;:
            self.alt_is_held = False</div>

<div class="viewcode-block" id="SelectL.OnClickRelease"><a class="viewcode-back" href="../../../api/pylayers.gis.selectl.SelectL.html#pylayers.gis.selectl.SelectL.OnClickRelease">[docs]</a>    def OnClickRelease(self, event):
        pass</div>

<div class="viewcode-block" id="SelectL.OnMotion"><a class="viewcode-back" href="../../../api/pylayers.gis.selectl.SelectL.html#pylayers.gis.selectl.SelectL.OnMotion">[docs]</a>    def OnMotion(self, event):
        pass</div>

<div class="viewcode-block" id="SelectL.OnClick"><a class="viewcode-back" href="../../../api/pylayers.gis.selectl.SelectL.html#pylayers.gis.selectl.SelectL.OnClick">[docs]</a>    def OnClick(self, event):
        &quot;&quot;&quot; handle OnClick event

        Parameters
        ----------

        event :

        See Also
        --------

        pylayers.gis.layout.Layout.ispoint

        &quot;&quot;&quot;
        fig = self.fig#plt.gcf()
        ax  = self.ax#plt.gca()
        self.nsel = 0
        self.ptsel = np.array([])
        xmin, xmax, ymin, ymax = self.ax.axis()
        #print( xmin,xmax,ymin,ymax)
        dx = xmax - xmin
        dy = ymax - ymin
        dd = np.minimum(dx, dy)

        if event.button == 1 and event.inaxes:
            self.evt = &#39;lclic&#39;
            x = event.xdata
            y = event.ydata
            self.ptsel = np.array((x, y))
            self.nsel = self.L.ispoint(self.ptsel, dd / 100)

        if event.button == 2 and event.inaxes:
            self.evt = &#39;cclic&#39;
            x = event.xdata
            y = event.ydata
            self.ptsel = np.array((x, y))
            self.nsel = self.L.ispoint(self.ptsel, dd / 100)

        if event.button == 3 and event.inaxes:
            self.evt = &#39;rclic&#39;
            x = event.xdata
            y = event.ydata
            self.ptsel = np.array((x, y))
            self.nsel = self.L.ispoint(self.ptsel, dd / 100)

        #print(&quot;Selected point coord : &quot;, self.ptsel)
        #print(&quot;Selected point number: &quot;, self.nsel)
        if self.nsel &gt; 0:
            print(&quot;Selected segment : &quot;, self.nsel)

        self.new_state()</div>




<div class="viewcode-block" id="SelectL.format_coord"><a class="viewcode-back" href="../../../api/pylayers.gis.selectl.SelectL.html#pylayers.gis.selectl.SelectL.format_coord">[docs]</a>    def format_coord(self,x, y):
        col = int(x+0.5)
        row = int(y+0.5)
        string = &#39;x=%1.4f, y=%1.4f&#39;%(x, y)
        try:
            string = string + &#39; &#39; + self.L.Gs.node[self.nsel][&#39;name&#39;]
        except:
            pass
        try:
            string = string + &#39; with &#39; +str(len(self.L.Gs.node[self.nsel][&#39;ss_name&#39;])) + &#39;subseg(s)&#39;
        except:
            pass
        string = string + &#39; ///&#39; +self.help[self.state]
        return string</div>
        
        # if col&gt;=0 and col&lt;numcols and row&gt;=0 and row&lt;numrows:
        #     z = X[row,col]
        #     return &#39;x=%1.4f, y=%1.4f, z=%1.4f&#39;%(x, y, z)
        # else:
        #     return &#39;x=%1.4f, y=%1.4f&#39;%(x, y)

<div class="viewcode-block" id="SelectL.update_state"><a class="viewcode-back" href="../../../api/pylayers.gis.selectl.SelectL.html#pylayers.gis.selectl.SelectL.update_state">[docs]</a>    def update_state(self):
        &quot;&quot;&quot; update state
        &quot;&quot;&quot;
        # fig = plt.gcf()
        # ax = plt.gca()
        if not self.bundo:
            self.undoGs.append(self.L.Gs.copy())
            if len(self.undoGs) &gt; 50:
                self.undoGs.pop(0)

        self.ax.format_coord=self.format_coord

        if self.state == &#39;Init&#39;:
            self.fig,self.ax = self.show(self.fig,self.ax,clear=True)
            self.ax.title.set_text(self.statename[self.state])
            self.selected_edge1 = 0
            self.selected_pt1 = 0
            self.selected_pt2 = 0
            self.selectpt=[]
            self.selectseg=[]
            try:
                del self.pt_previous
            except:
                pass
            try:
                self.selector.set_active(False)
                print(&#39;inhib select&#39;)
            except:
                pass
            #ax.title.set_text(self.state)
            #ax.title.set_text(&#39;Init : &#39;
            #                       +self.L.display[&#39;activelayer&#39;])
            try:
                self.p1[0].set_visible(False)
            except:
                pass
            try:
                self.p2[0].set_visible(False)
            except:
                pass
            try:
                self.segment[0].set_visible(False)
            except:
                pass
            #
            # If Layout has no point go to CP state
            #
            if self.L.Np==0:
                self.state=&#39;CP&#39;
                self.update_state()

        if self.state == &#39;SP1&#39;:
            self.fig,self.ax = self.show(self.fig,self.ax,clear=False)
            self.ax.title.set_text(self.statename[self.state])
            print(&#39;Selected node : &#39;+str(self.nsel))
            #ax.title.set_text(self.nsel))
            self.selected_pt1 = self.nsel
            self.pt1 = np.array(self.L.Gs.pos[self.nsel]).reshape(2, 1)
            self.pt_previous = self.pt1
            self.p1 = self.ax.plot([self.pt1[0]], [self.pt1[1]], &#39;o&#39;, visible=True)
            self.p1[0].set_color(&#39;yellow&#39;)
            self.p1[0].set_ms(10)
            self.p1[0].set_alpha(0.4)
            try:
                self.p2.set_visible(False)
            except:
                pass

        if self.state == &#39;SP2&#39;:
            self.p1[0].set_color(&#39;green&#39;)
            self.ax.title.set_text(self.statename[self.state])
            #ax.title.set_text(&#39;Selected node : %d &#39; % (self.nsel))
            print(&#39;Selected node : &#39; + str(self.nsel))
            self.selected_pt2 = self.nsel
            self.pt2 = np.array(self.L.Gs.pos[self.nsel]).reshape(2, 1)
            self.pt_previous = self.pt2
            self.p2 = self.ax.plot([self.pt2[0]], [self.pt2[1]], &#39;o&#39;, visible=True)
            self.p2[0].set_color(&#39;green&#39;)
            self.p2[0].set_ms(10)
            self.p2[0].set_alpha(0.4)
            #ax.title.set_text(&#39;SP2&#39;)

        if self.state == &#39;SS&#39;:
            self.ax.title.set_text(self.statename[self.state])
            try:
                self.p1[0].set_visible(False)
            except:
                pass
            try:
                self.p2[0].set_visible(False)
            except:
                pass
            self.selected_edge1 = self.nsel
            nse = self.nsel
            ta, he = self.L.Gs.neighbors(nse)
            pta = np.array(self.L.Gs.pos[ta])
            phe = np.array(self.L.Gs.pos[he])
            alpha = self.L.display[&#39;alpha&#39;]
            self.current_layer = self.L.Gs.node[nse][&#39;name&#39;]
            self.L.display[&#39;activelayer&#39;] = self.current_layer
            #self.seg       = linet(ax,pta,phe,alpha,&#39;red&#39;,3.5)
            segdico = self.L.Gs.node[nse]
            self.fig,self.ax=self.show(self.fig,self.ax,clear=False)
            self.segment = self.ax.plot([pta[0],phe[0]],
                                        [pta[1],phe[1]],
                                        &#39;r&#39;,linewidth=3, visible=True)
            if &#39;ss_name&#39; in segdico:
                cosegname = segdico[&#39;ss_name&#39;]
                titre = &#39;Select Segment : %d (%d-&gt;%d) Layer : %s Coseg : %s &#39; % (nse, ta, he, self.current_layer, cosegname)
            else:
                titre = &#39;Select Segment : %d (%d-&gt;%d) Layer : %s&#39; % (nse, ta, he, self.L.Gs.node[nse][&#39;name&#39;])
            print(titre)
            #ax.title.set_text(titre)
            self.L.show_nodes(ndlist=[nse], size=200, color=&#39;r&#39;, alpha=0.5)

        if self.state == &#39;SSS&#39;:
            self.ax.title.set_text(self.statename[self.state])
            nse = self.selected_edge1
            segdico = self.L.Gs.node[nse]
            z  = segdico[&#39;ss_z&#39;]
            #ax.title.set_text(&#39;SSS : &#39;+self.L.Gs.node[nse][&#39;name&#39;]+&#39; [&#39;+str(z[0])+&#39;]&#39;)
            print(self.L.Gs.node[nse][&#39;name&#39;]+&#39; [&#39;+str(z[0])+&#39;]&#39;)
            self.segment[0].set_color(&#39;blue&#39;)
        #
        # Create Point state
        #
        if self.state == &#39;CP&#39;:
            self.ax.title.set_text(self.statename[self.state])
            try:
                self.segment[0].set_visible(False)
            except:
                pass
            try:
                self.segment1[0].set_visible(False)
            except:
                pass
            try:
                self.segment2[0].set_visible(False)
            except:
                pass
            print(&#39;lclic : free point, +CTRL same x, +SHIFT: same y&#39;)
            self.fig,self.ax=self.show(self.fig,self.ax,clear=False)
            self.L.g2npy()

        #
        # Create Point on Segment state
        #

        if self.state == &#39;CPS&#39;:
            self.ax.title.set_text(self.statename[self.state])
            self.selected_edge1 = self.nsel
            ta, he = self.L.Gs.neighbors(self.nsel)
            self.pta1 = np.array(self.L.Gs.pos[ta])
            self.phe1 = np.array(self.L.Gs.pos[he])
            self.current_layer = self.L.Gs.node[self.nsel][&#39;name&#39;]
            self.L.display[&#39;activelayer&#39;] = self.current_layer
            self.segment1 = self.ax.plot([self.pta1[0],self.phe1[0]],
                                        [self.pta1[1],self.phe1[1]],
                                        &#39;g&#39;,linewidth=3, visible=True)
            try:
                self.segment2[0].set_visible(False)
            except:
                pass

        if self.state == &#39;CPSS&#39;:
            self.ax.title.set_text(self.statename[self.state])
            self.selected_edge2 = self.nsel
            ta, he = self.L.Gs.neighbors(self.nsel)
            self.pta2 = np.array(self.L.Gs.pos[ta])
            self.phe2 = np.array(self.L.Gs.pos[he])
            self.current_layer = self.L.Gs.node[self.nsel][&#39;name&#39;]
            self.L.display[&#39;activelayer&#39;] = self.current_layer
            self.segment2 = self.ax.plot([self.pta2[0],self.phe2[0]],
                                        [self.pta2[1],self.phe2[1]],
                                        &#39;c&#39;,linewidth=3, visible=True)


        if &#39;SM&#39; in self.state:
            self.fig,self.ax = self.show(self.fig,self.ax,clear=True)
            self.ax.title.set_text(self.statename[self.state])
            self.selected_edge1 = 0
            self.selected_pt1 = 0
            self.selected_pt2 = 0
            try:
                del self.pt_previous
            except:
                pass
            # self.state=&#39;SM&#39;
        #print self.state
        #print self.nsel
        #print self.selected_pt1
        #print self.selected_pt2
        self.fig.canvas.draw()
        return(self.fig,self.ax)</div>


<div class="viewcode-block" id="SelectL.new_state"><a class="viewcode-back" href="../../../api/pylayers.gis.selectl.SelectL.html#pylayers.gis.selectl.SelectL.new_state">[docs]</a>    def new_state(self):
        &quot;&quot;&quot; layout editor state machine

        Parameters
        ----------


        &#39;l&#39;  : select activelayer
        &#39;i&#39;  : back to init state
        &#39;j&#39;  : vertical and horizontal scaling
        &#39;e&#39;  : edit segment
        &#39;b&#39;  : edit segment keyboard
        &#39;CTRL + t&#39;  : translate  structure
        &#39;h&#39;  : add subsegment
        &#39;d |Del&#39;  : delete subsegment
        &#39;r |F5&#39;  : refresh
        &#39;o&#39;  : toggle overlay (&lt;&gt; CP mode)
               set origin (CP mode)
        &#39;m&#39;  : toggle mode (point or segment)
        &#39;n&#39;  : toggle node label display 
        &#39;z&#39;  : change display parameters
        &#39;CTRL+q&#39;  : quit
        &#39;x |CTRL+s&#39;  : save .str2 and .ini file
        &#39;w&#39;  : display all layers
        &#39;v&#39;  : flip layout w.r.t y axis
        &#39;f&#39;  : toggle points nodes display
        &#39;g&#39;  : toggle segments nodes display
        &#39;=&#39;  : increment layer 
        &#39;$&#39;  : decrement layer 
        &quot;&quot;&quot;
        fig = plt.gcf()
        ax  = plt.gca()
        sl = self.L.sl
        cold = pyu.coldict()
        #print &quot;In State &quot;,self.state
        #print &quot;In Event &quot;,self.evt

                #
        # flip layout in y
        #
        if self.evt == &#39;,&#39;:
            for k in self.ddoc.keys():
                print(k,self.ddoc[k])

        if self.evt == &#39;v&#39;:
            for n in self.L.Gs.pos:
                self.L.Gs.pos[n]=(self.L.Gs.pos[n][0],-self.L.Gs.pos[n][1])
            self.update_state()
            return
        #
        # translation of layout (open a box)
        #
        # if self.evt == &#39;t&#39; :
        #     offx,offy = offsetbox()
        #     for n in self.L.Gs.pos:
        #         self.L.Gs.pos[n]=(self.L.Gs.pos[n][0]+offx,self.L.Gs.pos[n][1]+offy)
        #     self.update_state()
        #     return

        if self.evt==&#39;escape&#39;:
            self.state=&#39;Init&#39;
            self.update_state()
            self.fig.canvas.draw()
            return


        if self.evt==&#39;ctrl+z&#39;:
            self.bundo=True
            print( len(self.L.Gs))
            if len (self.undoGs) &gt;2:
                oGs=self.undoGs.pop(-1)
                oGs=self.undoGs.pop(-1)
                self.L.Gs=oGs
                self.L.g2npy()
            self.update_state()
            self.bundo=False
            return

        if self.evt==&#39;t&#39;:
            if &#39;SM&#39; in self.state:
                self.update_state()
                # fig=plt.gcf()
                # ax=plt.gca()
                if self.selected == &#39;pt&#39;:
                    self.plotselptseg(self.selectseg,color=&#39;r&#39;)
                    PP=self.L.pt[:,self.L.tahe[:,self.L.tgs[self.selectseg]]]
                    if PP.shape[-1]!=0:
                        self.fig,self.ax=plu.displot(PP[:,0],PP[:,1],fig=self.fig,ax=self.ax,color=&#39;r&#39;,linewidth=3,alpha=0.4)
                        plt.draw()
                    self.selected=&#39;seg&#39;
                    self.state=&#39;SMS&#39;
                else:
                    self.fig,self.ax= self.plotselptseg(self.selectpt)
                    self.selected=&#39;pt&#39;
                    self.state=&#39;SMP&#39;
                self.ax.title.set_text(self.statename[self.state])
                # self.update_state()

        if self.evt == &#39;3&#39;:
            self.L._show3()
            return

        # Choose layers to visualized
        #
        if self.evt == &#39;l&#39;:
            listchoices = self.L.name.keys()
            self.L.display[&#39;layers&#39;] = multchoicebox(&#39;message&#39;,
                                                     &#39;titre&#39;, listchoices)
            self.state = &#39;Init&#39;
            self.update_state()
            return
        #
        # &#39;f&#39; toggle points nodes display
        #
        if self.evt==&#39;f&#39;:
            self.L.display[&#39;nodes&#39;] = not self.L.display[&#39;nodes&#39;]
            print (self.L.display[&#39;nodes&#39;])
            self.update_state()
            return

        #
        # &#39;g&#39; toggle segment nodes dislay
        #
        if self.evt==&#39;g&#39;:
            self.L.display[&#39;ednodes&#39;] = not self.L.display[&#39;ednodes&#39;]
            print (self.L.display[&#39;ednodes&#39;])
            self.update_state()
            return

        #
        # &#39;=&#39; Increment layer
        #
        if self.evt==&#39;=&#39;:
            N = len(self.L.display[&#39;layerset&#39;])
            index = self.L.display[&#39;layerset&#39;].index(self.L.display[&#39;activelayer&#39;])
            self.L.display[&#39;activelayer&#39;] = self.L.display[&#39;layerset&#39;][(index+1) % N]
            self.current_layer = self.L.display[&#39;activelayer&#39;]
            print (self.current_layer)
            self.update_state()
            return

        #
        # &#39;=&#39; Decrement layer
        #
        if self.evt==&#39;$&#39;:
            N = len(self.L.display[&#39;layerset&#39;])
            index = self.L.display[&#39;layerset&#39;].index(self.L.display[&#39;activelayer&#39;])
            self.L.display[&#39;activelayer&#39;] = self.L.display[&#39;layerset&#39;][(index-1) % N]
            self.current_layer = self.L.display[&#39;activelayer&#39;]
            print (self.current_layer)
            self.update_state()
            return
        #
        # &#39;i&#39; : Back to init state 
        #
        if self.evt == &#39;i&#39;:
            self.state = &#39;Init&#39;
            self.update_state()
            return

        #
        #  &#39;e&#39;
        #       if state == Init
        #           egalize points coordinates
        #
        #       if state == SS
        #           edit segment properties
        #
        if self.evt == &#39;e&#39;:
            if (self.state == &#39;Init&#39;):
                #
                # averaging one point coordinate along the smallest dimension
                #
                x1 = self.ax.get_xbound()
                y1 = self.ax.get_ybound()
                # get node list and edge list
                ndlist, edlist = self.L.get_zone([x1[0],x1[1],y1[0],y1[1]])
                for k,nd in enumerate(ndlist):
                    try:
                        tp = np.vstack((tp,np.array(self.L.Gs.pos[nd])))
                    except:
                        tp = np.array(self.L.Gs.pos[nd])
                mtp = np.sum(tp,axis=0)/(k+1)
                stp = np.sqrt(np.sum((tp-mtp)*(tp-mtp),axis=0)/(k+1))
                # if the standard deviation is lower than 10cm
                # averaging coordinates along the shortest axis
                if min(stp) &lt; 0.10:
                    ind = np.where(stp==min(stp))[0][0]
                    for nd in ndlist:
                        x = self.L.Gs.pos[nd][0]
                        y = self.L.Gs.pos[nd][1]
                        if ind ==0:
                            self.L.Gs.pos[nd]=(mtp[0],y)
                        if ind ==1:
                            self.L.Gs.pos[nd]=(x,mtp[1])
                    plt.axis(&#39;tight&#39;)
                    self.fig,self.ax = self.show(self.fig,self.ax,clear=True)
                    self.update_state()
                return()

            if (self.state == &#39;SS&#39;) | (self.state ==&#39;SSS&#39;):
                self.L.edit_segment(self.selected_edge1)
                self.state = &#39;Init&#39;
                self.update_state()
                return

            if self.state == &#39;SP1&#39;:
                self.L.edit_point(self.selected_pt1)
                self.state = &#39;Init&#39;
                self.update_state()
                return
            if self.state == &#39;SMS&#39;:
                outdata=self.L.edit_segment(self.selectseg[0])
                [self.L.edit_segment(s,outdata=outdata,gui=False) for s in self.selectseg]
                self.update_state()
                return


        #
        # &quot;b&quot; : enter a segment node value with keyboard
        #
        if self.evt == &#39;b&#39;:
            if self.state == &#39;Init&#39;:
                self.nsel = eval(raw_input(&quot;seg number :&quot;))
                #self.L.edit_segment(nseg)
                self.state=&#39;SS&#39;
                self.update_state()
                return

        #
        # j : vertical and horizontal scaling (Init)
        #
        if self.evt == &#39;j&#39;:
            if self.state == &#39;Init&#39;:
                vscale = eval(enterbox(&#39;enter vscale&#39;,argDefaultText=&#39;1.0&#39;))
                hscale = eval(enterbox(&#39;enter hscale&#39;,argDefaultText=&#39;1.0&#39;))
                for n in self.L.Gs.pos:
                    self.L.Gs.pos[n]=(self.L.Gs.pos[n][0]*hscale,self.L.Gs.pos[n][1]*vscale)
                plt.axis(&#39;tight&#39;)
                self.fig,self.ax = self.show(self.fig,self.ax,clear=True)
                self.update_state()
                return

        # Init
        # h : horizontal scaling factor
        #    add subsegment (SS)
        #
        if self.evt == &#39;h&#39;:
#            if self.state == &#39;Init&#39;:
#                hscale = eval(raw_input(&quot;horizontal scaling factor : &quot;))
#                for n in self.L.Gs.pos:
#                    self.L.Gs.pos[n]=(self.L.Gs.pos[n][0]*hscale,self.L.Gs.pos[n][1])
#                plt.axis(&#39;tight&#39;)
#                fig,ax = self.show(fig,ax,clear=True)
#                self.update_state()
#                return()

            if self.state == &#39;SS&#39;:
                result = self.L.add_subseg(self.selected_edge1,self.current_layer)
                if result:
                    self.state = &#39;SSS&#39;
                else :
                    self.state = &#39;Init&#39;
                self.update_state()
                return
        #
        # d : delete
        #
        if self.evt == &#39;d&#39; or self.evt ==&#39;delete&#39;:
            if  self.state == &#39;SP1&#39;:
                self.state = &#39;Init&#39;
                self.L.del_points(self.selected_pt1)
                self.update_state()
                return

            if self.state == &#39;SS&#39;:
                self.L.del_segment(self.selected_edge1)
                self.state = &#39;Init&#39;
                self.update_state()
                return

            if self.state == &#39;SSS&#39;:
                self.L.del_subseg(self.selected_edge1)
                self.state = &#39;Init&#39;
                self.update_state()
                return

            if self.state==&#39;SMP&#39;:
                # get boundary of the region 
                if hasattr(self,&#39;selectpt&#39;):

                    ptlist = self.selectpt
                    self.selectpt=[]
                    self.selectseg=[]
                    self.L.del_points(ptlist)
                    self.state = &#39;Init&#39;
                    self.update_state()
                    return
                else :
                    print (&#39;no selected region&#39;)

            if self.state==&#39;SMS&#39;:
                seglist = self.selectseg
                self.selectpt=[]
                self.selectseg=[]
                self.L.del_segment(seglist)
                self.state = &#39;Init&#39;
                self.update_state()
                return
            else :
                print (&#39;no selected region&#39;)
        #
        # r : Refresh
        #
        if self.evt == &#39;r&#39; or self.evt == &#39;f5&#39;:
            #plt.axis(&#39;tight&#39;)
            plt.axis(self.L.display[&#39;box&#39;])
            self.fig,self.ax = self.show(self.fig,self.ax,clear=True)
            self.state = &#39;Init&#39;
            self.update_state()
            return

        #
        # o : Toggle overlay
        #
        if self.evt == &#39;o&#39; and not self.ctrl_is_held:
            self.state=&#39;Init&#39;
            self.update_state()
            if self.L.display[&#39;overlay&#39;]:
                self.L.display[&#39;overlay&#39;] = False
                self.update_state()
            else:
                self.L.display[&#39;overlay&#39;] = True
                self.update_state()
            return

        if self.evt == &#39;o&#39; :
            self.set_origin = True

        #
        # F2 : Create point
        #
        if self.evt == &#39;f2&#39;:
            self.state = &quot;CP&quot;
            self.update_state()
            return
        #
        # m : Toggle mode edition Point | Segment
        #
        if self.evt == &#39;m&#39;:
            if self.state == &quot;Init&quot;:
                self.state = &quot;CP&quot;
            elif self.state == &quot;CP&quot;:
                self.state = &quot;Init&quot;
            self.update_state()
            return
        #
        # &#39;z&#39; : change display parameters
        #
        if self.evt == &#39;z&#39;:
            self.L.displaygui()
            self.fig,self.ax = self.show(fig=self.fig,ax=self.ax,clear=True)
            return
        #
        # &#39;q&#39; : quit interactive mode
        #
        # if self.evt == &#39;q&#39;:
        #     plt.rcParams.update(self.rcconf)
        #     fig.canvas.mpl_disconnect(self.L.cid1)
        #     fig.canvas.mpl_disconnect(self.L.cid2)
        #     return

        if self.evt == &#39;ctrl+q&#39;:
            plt.rcParams.update(self.rcconf)
            self.fig.canvas.mpl_disconnect(self.L.cid1)
            self.fig.canvas.mpl_disconnect(self.L.cid2)
            plt.close()
            return

        #
        # &#39;x&#39; save structure
        #
        if self.evt == &#39;x&#39; or self.evt ==&#39;ctrl+s&#39;:
            racine, ext = os.path.splitext(self.L.filename)
            filename = racine + &#39;.str2&#39;
            fileini = racine + &#39;.ini&#39;

            # Commented because ss_ce not updated 
            #self.L.savestr2(filename)

            self.L.saveini(fileini)
            print( &quot;structure saved in &quot;, filename)
            print( &quot;structure saved in &quot;, fileini)
            return
        #
        # &#39;n&#39; : toggle node label display
        #
        if self.evt == &#39;n&#39;:
            self.L.display[&#39;ndlabel&#39;] = not self.L.display[&#39;ndlabel&#39;]
            self.L.display[&#39;edlabel&#39;] = not self.L.display[&#39;edlabel&#39;]
            print( self.L.display[&#39;activelayer&#39;])
            self.fig,ax = self.show(fig=self.fig,ax=self.ax,clear=True)
            self.fig.canvas.draw()
            return
        #
        # &quot;w&quot; : display all layers
        #
        if self.evt == &#39;w&#39;:
        # display all layer
            self.L.display[&#39;activelayer&#39;] = self.L.name.keys()
            print( self.L.display[&#39;activelayer&#39;])
            self.fig,self.ax = self.show(fig=self.fig,ax=self.ax,clear=True)
            return self.fig,self.ax
        #
        # Left clic and selected node is a point
        #
        if (self.evt == &#39;lclic&#39;) &amp; (self.nsel &lt; 0):

        #
        # select point 1 : Init -&gt; SP1
        #
            if self.state==&#39;Init&#39;:
                # yellow point 
                self.state = &#39;SP1&#39;
                self.update_state()
                return
        #
        # select point 2 : SP1 --&gt; SP2
        #

            if self.state==&#39;SP1&#39;:
                if self.nsel != self.selected_pt1:
                    # green point 
                    self.state = &#39;SP2&#39;
                    self.update_state()
                    return
                else:
                    self.state = &#39;Init&#39;
                    # yellow point 
                    self.update_state()
                    return
        #
        # Create point on selected segment orthogonaly to segment starting in
        # selected point
        # 
        # Not finished 
        #
            if self.state==&#39;SS&#39;:
                # get the connection of the selected segment
                connect = self.L.Gs.node[self.selected_edge1][&#39;connect&#39;]
                if (self.nsel != connect[0]) &amp; (self.nsel != connect[1]): 
                   self.L.add_nfpe(self.nsel,self.nsel,self.selected_edge1,self.selected_edge2)
                   pass

        #
        # Left clic and selected node is a segment
        #

        if (self.evt == &#39;lclic&#39;) &amp; (self.nsel &gt; 0):
            if self.state==&#39;Init&#39;:
                self.state = &#39;SS&#39;
                self.update_state()
                return

            if self.state==&#39;SS&#39;:
                self.nsel = self.selected_edge1
                segdico = self.L.Gs.node[self.nsel]
                if &#39;ss_name&#39; in segdico:
                    self.state = &#39;SSS&#39;
                else:
                    self.state = &#39;CPS&#39;
                self.update_state()
                return
        #
        # Right clic and selected node is a point
        #

        if (self.evt == &#39;rclic&#39;) &amp; (self.nsel &lt; 0):
            if self.state==&#39;SP1&#39;:
                if self.nsel==self.selected_pt1:
                    self.state = &#39;Init&#39;
                    self.update_state()
                    return
        #
        # Right clic and selected node is a segment
        #

        if (self.evt == &#39;rclic&#39;) &amp; (self.nsel &gt; 0):
            if self.state==&#39;SS&#39;:
                self.state = &#39;Init&#39;
                self.update_state()
                return

            if self.state==&#39;SSS&#39;:
                self.state = &#39;SS&#39;
                self.update_state()
                return

            if self.state == &#39;CP&#39;:
            # create point on edge
                self.state = &#39;CPS&#39;
                self.update_state()
                return

            if (self.state == &#39;CPS&#39;) &amp; (self.nsel!= self.selected_edge1):
            # create point on edge
                self.state = &#39;CPSS&#39;
                self.update_state()
                return
        #
        # Left clic
        #
        if (self.evt == &#39;lclic&#39;) and not (self.shift_is_held or self.alt_is_held or self.ctrl_is_held ):
            # add free node
            # or set origin
            if self.state == &#39;CP&#39;:
                if self.set_origin:
                    offx = self.ptsel[0]
                    offy = self.ptsel[1]
                    print( offx,offy)
                    xmin,xmax,ymin,ymax = self.L.display[&#39;box&#39;]
                    self.L.display[&#39;box&#39;] = [xmin-offx,xmax-offx,ymin-offy,ymax-offy]
                    self.set_origin=False
                    self.set_x=True
                    plt.axis(&#39;tight&#39;)
                    self.fig,self.ax = self.show(self.fig,self.ax,clear=True)
                    self.update_state()
                    return
                if self.set_x:
                    offx = self.ptsel[0]
                    val  = eval(enterbox(&#39;enter x value&#39;))
                    ratio = val/offx
                    print( ratio)
                    xmin,xmax,ymin,ymax = self.L.display[&#39;box&#39;]
                    self.L.display[&#39;box&#39;] = [ratio*xmin,ratio*xmax,ymin,ymax]
                    self.set_x=False
                    self.set_y=True
                    plt.axis(&#39;tight&#39;)
                    self.fig,self.ax = self.show(self.fig,self.ax,clear=True)
                    self.update_state()
                    return
                if self.set_y:
                    offx = self.ptsel[1]
                    val  = eval(enterbox(&#39;enter y value&#39;))
                    ratio = val/offx
                    print( ratio)
                    xmin,xmax,ymin,ymax = self.L.display[&#39;box&#39;]
                    self.L.display[&#39;box&#39;] = [xmin,xmax,ratio*ymin,ratio*ymax]
                    self.set_y=False
                    plt.axis(&#39;tight&#39;)
                    self.fig,self.ax = self.show(self.fig,self.ax,clear=True)
                    self.update_state()
                    return
                else:
                    self.L.add_fnod(tuple(self.ptsel))
                    self.pt_previous = self.ptsel
                    self.update_state()

                return

            if self.state == &#39;SP2&#39;:

                ta = self.selected_pt1
                he = self.selected_pt2

                segexist = self.L.isseg(ta,he)
                print( segexist)
                # if segment do not already exist, create it
                if not segexist: 
                    self.nsel  = self.L.add_segment(ta, he,name=self.current_layer)
                else:
                    print( &quot;segment (&quot;+str(ta)+&quot;,&quot;+str(he)+&quot;) already exists&quot;)
                self.L.g2npy()
                self.state = &#39;Init&#39;
                self.update_state()
                return

            # create point on segment
            if self.state == &#39;CPS&#39;:
                pt_new = geu.ptonseg(self.pta1, self.phe1, self.ptsel)
                pd1 = pt_new - self.pta1
                pd2 = self.phe1 - self.pta1
                alpha = np.sqrt(np.dot(pd1, pd1)) / np.sqrt(np.dot(pd2, pd2))
                if (pt_new != []):
                    # calculate alpha
                    self.L.add_pons(self.selected_edge1, 1. - alpha)
                    self.current_layer = self.L.Gs.node[self.selected_edge1][&#39;name&#39;]
                    self.state = &#39;Init&#39;
                self.update_state()
                return

        #
        # Right Clic event
        #
        if (self.evt == &#39;rclic&#39;) or (self.evt == &#39;lclic&#39; and self.ctrl_is_held ):
            if self.state == &#39;CP&#39;:
                try:
                    self.ptsel[0] = self.pt_previous[0]
                    self.L.add_fnod(tuple(self.ptsel))
                    self.pt_previous = self.ptsel
                    self.update_state()
                    return
                except:
                    return

            if self.state==&#39;SP2&#39;:
                if self.nsel == self.selected_pt1:
                    self.p1[0].set_visible(False)
                    self.p2[0].set_visible(False)
                    self.nsel = self.selected_pt2
                    self.state = &#39;SP1&#39;
                    self.update_state()
                    return
                if self.nsel == self.selected_pt2:
                    self.p1[0].set_visible(False)
                    self.p2[0].set_visible(False)
                    self.nsel = self.selected_pt1
                    self.state = &#39;SP1&#39;
                    self.update_state()
                    return
        #
        # right click : back to SS from CPS
        #
            if self.state == &#39;CPS&#39;:
                self.state = &#39;SS&#39;
                self.update_state()
                return
        #
        # right click : back to CPS from CPSS
        #
            if self.state == &#39;CPSS&#39;:
                self.state = &#39;CPS&#39;
                self.update_state(self.fig,self.ax)
                return
        #
        # Center Clic event
        #
        if (self.evt == &#39;cclic&#39;) or (self.evt == &#39;lclic&#39; and self.shift_is_held ):
            if self.state == &#39;CP&#39;:
                try:
                    self.ptsel[1] = self.pt_previous[1]
                    self.L.add_fnod(tuple(self.ptsel))
                    self.pt_previous = self.ptsel
                    self.update_state()
                    return
                except:
                    return
        #
        # Left clic and selected node is a point
        #


        def point_select_callback(eclick, erelease):
            &#39;eclick and erelease are the press and release events&#39;
            self.update_state()
            if not (self.shift_is_held or self.ctrl_is_held):
                self.selectpt=[]
                self.selectseg=[]
            x1, y1 = eclick.xdata, eclick.ydata
            x2, y2 = erelease.xdata, erelease.ydata

            # print x1,x2,y1,y2
            if x1&gt;x2:
                x1,x2=x2,x1
            if y1&gt;y2:
                y1,y2=y2,y1


            # try:
            selectpt,selectseg = self.L.get_zone([x1,x2,y1,y2])

            if not self.ctrl_is_held:
                self.selectpt.extend(selectpt)
                self.selectseg.extend(selectseg)
                self.selectseg=filter(lambda x: self.L.Gs.node[x][&#39;connect&#39;][0] in self.selectpt
                                 and self.L.Gs.node[x][&#39;connect&#39;][1] in self.selectpt,
                                 self.selectseg)

                self.selectpt=np.unique(self.selectpt).tolist()
                self.selectseg=np.unique(self.selectseg).tolist()
            else: 
                [self.selectpt.pop(self.selectpt.index(x)) for x in selectpt if x in self.selectpt]
                [self.selectseg.pop(self.selectseg.index(x)) for x in selectseg if x in self.selectseg]
            # except:
            #     print &#39;empty selection&#39;
            print(self.selectpt,self.selectseg)
            self.plotselptseg(self.selectpt)
            self.selected=&#39;pt&#39;
            print(self.state)
            
                

        def toggle_selector(event):
            if toggle_selector.RS.active:
                toggle_selector.RS.set_active(False)
            if not toggle_selector.RS.active:
                toggle_selector.RS.set_active(True)

        if self.evt == &#39;f1&#39;:
            #avoid conflict between zoom and selection 
            # fm=plt.get_current_fig_manager()
            # if fm.toolbar._active == &#39;PAN&#39;:
            #     fm.toolbar.pan()
            # if fm.toolbar._active == &#39;ZOOM&#39;:
            #     fm.toolbar.zoom()

            self.state=&#39;SMP&#39;
            toggle_selector.RS = RectangleSelector(self.ax, point_select_callback,
                                               drawtype=&#39;box&#39;, useblit=True,
                                               button=[1,3], # don&#39;t use middle button
                                               minspanx=5, minspany=5,
                                               spancoords=&#39;pixels&#39;)
            self.selector = toggle_selector.RS
            self.update_state()

        if self.evt == &#39;f9&#39;:
            print(self.selectpt, self.selectseg)</div></div>
            #print self.selectsl
            # plt.connect(&#39;key_press_event&#39;, toggle_selector)

if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod()
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team.
      Last updated on Jan 29, 2019.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>