

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.gis.osmparser &mdash; PyLayers</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_issue314.html">Exemple of issue 314</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_dakar.html">Outdoor Radio Coverage with Deygout Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_cover.html">Outdoor Radio Coverage with Deygout Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction_polar.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pylayers.gis.osmparser</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.gis.osmparser</h1><div class="highlight"><pre>
<span></span># -*- moding: utf-8 -*-
&quot;&quot;&quot;
Module OSMParser

.. currentmodule:: pylayers.gis.osmparser

.. autosummary::

&quot;&quot;&quot;
from osmapi import OsmApi
import geocoder as geo
import sys
import urllib

if sys.version_info.major == 2:
    from  urllib2 import urlopen
else:
    from  urllib.request import urlopen

from pylayers.util.project import *
import pylayers.util.pyutil as pyu
import pylayers.util.geomutil as geu
from mpl_toolkits.basemap import Basemap
from matplotlib.collections import PolyCollection
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
import xml.etree.ElementTree as xml

import pdb

# classes that handle the OSM data file format.
<div class="viewcode-block" id="Way"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Way.html#pylayers.gis.osmparser.Way">[docs]</a>class Way(object):
    &quot;&quot;&quot;

    A Way is a polyline or a Polygon (if closed)

    typ : 0 Polygon
          1 LineString

    &quot;&quot;&quot;
    def __init__(self, refs, tags, coords):
        &quot;&quot;&quot; object constructor

        Parameters
        ----------

        refs  :
        tags  :
        coords :
        nodes_sign : int
            if data comes from osm nodes are &gt;0 in ways sequence
            if data comes from josm editor nodes are &lt;0 ways sequence

        &quot;&quot;&quot;
        self.refs  = refs
        self.tags = tags
        N = len(refs)
        p = np.zeros((2, N))
        self.valid = True
        for k, nid in enumerate(refs):
            try:
                p[0, k] = coords.xy[nid][0]
                p[1, k] = coords.xy[nid][1]
            except:
                self.valid=False
                break
        # closed way or open way
        if self.valid:
            if (N&gt;=4) &amp; (refs[0]==refs[-1]):
                self.shp = geu.Polygon(p)
                self.typ = 0
            else:
                self.shp = geu.LineString(p)
                self.typ = 1

    def __repr__(self):
        st = &#39;&#39;
        st = st + str(self.tags) + &#39;:&#39; + str(self.refs)
        return(st)

<div class="viewcode-block" id="Way.show"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Way.html#pylayers.gis.osmparser.Way.show">[docs]</a>    def show(self,fig=[],ax=[]):
        &quot;&quot;&quot; show way

        Parameters
        ----------

        fig : matplotlib figure
        ax  : axes

        &quot;&quot;&quot;
        fig, ax = self.shp.plot(fig=fig, ax=ax)
        return fig, ax</div></div>

<div class="viewcode-block" id="Coords"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Coords.html#pylayers.gis.osmparser.Coords">[docs]</a>class Coords(object):
    &quot;&quot;&quot; Coords describes a set of points in OSM

    Attributes
    ----------

    xy :
    latlon :
    cpt :
    minlon :
    maxlon :
    minlat :
    maxlat :
    boundary : np.array
        (minlon,minlat,maxlon,maxlat)

    Notes
    -----


    &quot;&quot;&quot;
    cpt = 0
    latlon = {}
    xy = {}
    minlon = 1000
    maxlon = -1000
    minlat = 1000
    maxlat = -1000

    def __init__(self,idx=[],latlon=[]):
        &quot;&quot;&quot;
        &quot;&quot;&quot;
        if latlon!=[]:
            for k,ix in enumerate(idx):
                self.latlon[k]=np.array(latlon[k][0],latlon[k][1])

    def __repr__(self):
        st = &#39;&#39;
        for k in self.xy:
            st = st + str(k)+ &#39;:&#39; + str(self.xy[k])+&#39;\n&#39;
        st = st+ &#39;Ncoords = &#39;+ str(len(self.xy))+&#39;\n&#39;

        return(st)

<div class="viewcode-block" id="Coords.filter"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Coords.html#pylayers.gis.osmparser.Coords.filter">[docs]</a>    def filter(self,lexcluded):
        for ix in lexcluded:
            self.latlon.pop(-np.abs(ix))
            self.xy.pop(-np.abs(ix))
            self.cpt-=1</div>

<div class="viewcode-block" id="Coords.clean"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Coords.html#pylayers.gis.osmparser.Coords.clean">[docs]</a>    def clean(self):
        &quot;&quot;&quot; reset coordinates

        &quot;&quot;&quot;
        self.cpt = 0
        self.latlon={}
        self.xy = {}
        self.minlon = 1000
        self.maxlon = -1000
        self.minlat = 1000
        self.maxlat = -1000</div>

<div class="viewcode-block" id="Coords.coords"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Coords.html#pylayers.gis.osmparser.Coords.coords">[docs]</a>    def coords(self, coords):
        &quot;&quot;&quot; calculates extrema of coords

        Parameters
        ----------

        coords

        &quot;&quot;&quot;
        # callback method for coords
        for osmid, lon, lat in coords:
            self.latlon[osmid] = np.array([lon, lat])
            # find extrema
            self.minlon = min(lon,self.minlon)
            self.maxlon = max(lon,self.maxlon)
            self.minlat = min(lat,self.minlat)
            self.maxlat = max(lat,self.maxlat)

            self.cpt += 1

        self.boundary=np.array([self.minlon,self.minlat,self.maxlon,self.maxlat])</div>

<div class="viewcode-block" id="Coords.cartesian"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Coords.html#pylayers.gis.osmparser.Coords.cartesian">[docs]</a>    def cartesian(self, cart=False, delta=0, projection=&#39;cass&#39;):
        &quot;&quot;&quot; convert Latitude/Longitude in cartesian

        Parameters
        ----------
        cart : Boolean
            conversion to cartesian
        delta : offset
            default 0 : in this case the origin corresponds to the lower left point
        projection = [&#39;aeqd&#39;,&#39;gnom&#39;,&#39;ortho&#39;,&#39;geos&#39;,&#39;nsper&#39;,&#39;moll&#39;,&#39;lcc&#39;,&#39;laea&#39;,&#39;cass&#39;]

        Notes
        -----

        This method converts latlon coordinates into cartesian x,y coordinates in
        a given projection (Default Cassini) relatively to specified latlon boundary
        The basemap objet for back and forth coordinates conversion is returned.

        The transformation is centered on the mean of latitude and longitude.
        The cartesian origin (0,0) correspond to the lower left corner (lonmin,latmin)

        Returns
        -------

        m : Basemap converter


        Warning
        -------

        If boundary is modified cartesian coordinates change.


        &quot;&quot;&quot;
        bd = self.boundary
        lon_0 = (bd[0]+bd[2])/2.
        lat_0 = (bd[1]+bd[3])/2.

        m = Basemap(llcrnrlon=bd[0]-delta, llcrnrlat=bd[1]-delta,
                    urcrnrlon=bd[2]+delta, urcrnrlat=bd[3]+delta,
                resolution=&#39;i&#39;, projection = projection, lon_0=lon_0, lat_0=lat_0)

        for kid in self.latlon:
            if cart:
                x, y = m(self.latlon[kid][0], self.latlon[kid][1])
            else:
                x, y = (self.latlon[kid][0], self.latlon[kid][1])

            self.xy[kid]  = np.array([x,y])

        return(m)</div>

<div class="viewcode-block" id="Coords.from_nodes"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Coords.html#pylayers.gis.osmparser.Coords.from_nodes">[docs]</a>    def from_nodes(self,nodes):
        &quot;&quot;&quot; read coordinates from nodes

        Parameters
        ----------

        nodes : Nodes


        &quot;&quot;&quot;
        for osmid in nodes.node:
            lon = nodes.node[osmid][&#39;lonlat&#39;][0]
            lat = nodes.node[osmid][&#39;lonlat&#39;][1]
            self.latlon[osmid] = np.array([lon,lat])
            # find extrema
            self.minlon = min(lon,self.minlon)
            self.maxlon = max(lon,self.maxlon)
            self.minlat = min(lat,self.minlat)
            self.maxlat = max(lat,self.maxlat)

            self.cpt += 1

        self.boundary = np.array([self.minlon,
                                  self.minlat,
                                  self.maxlon,
                                  self.maxlat])</div></div>



<div class="viewcode-block" id="Nodes"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Nodes.html#pylayers.gis.osmparser.Nodes">[docs]</a>class Nodes(object):
    &quot;&quot;&quot;

    osm Nodes container

    &quot;&quot;&quot;

    node = {}
    cpt = 0

<div class="viewcode-block" id="Nodes.nodes"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Nodes.html#pylayers.gis.osmparser.Nodes.nodes">[docs]</a>    def nodes(self,nodes):
        &quot;&quot;&quot;  parse tagged nodes
        &quot;&quot;&quot;
        for osmid, tags, coords in nodes:
            self.node[osmid] = {}
            self.node[osmid][&#39;tags&#39;] = tags
            self.node[osmid][&#39;lonlat&#39;] = coords
            lon = coords[0]
            lat = coords[1]
            self.cpt += 1</div>

    def __repr__(self):
        st = &#39;&#39;
        for kid in self.node:
            st = st+str(kid) + &#39; : &#39; + str(self.node[kid][&#39;lonlat&#39;])+&#39;\n&#39;
        return(st)

<div class="viewcode-block" id="Nodes.clean"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Nodes.html#pylayers.gis.osmparser.Nodes.clean">[docs]</a>    def clean(self):
        self.node= {}
        self.cpt = 0</div>

<div class="viewcode-block" id="Nodes.readmap"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Nodes.html#pylayers.gis.osmparser.Nodes.readmap">[docs]</a>    def readmap(self,osmmap):
        &quot;&quot;&quot; read nodes from a map

        &quot;&quot;&quot;
        for item in osmmap:
            if item[&#39;type&#39;]==&#39;node&#39;:
                osmid = -item[&#39;data&#39;][&#39;id&#39;]
                if osmid&gt;0:
                    osmid = -osmid
                lon = item[&#39;data&#39;][&#39;lon&#39;]
                lat = item[&#39;data&#39;][&#39;lat&#39;]
                self.node[osmid]={}
                self.node[osmid][&#39;tags&#39;] = item[&#39;data&#39;][&#39;tag&#39;]
                self.node[osmid][&#39;lonlat&#39;] = (lon,lat)
                self.cpt += 1</div></div>

<div class="viewcode-block" id="Ways"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Ways.html#pylayers.gis.osmparser.Ways">[docs]</a>class Ways(object):
    &quot;&quot;&quot;

    Attributes
    ----------

    w : dict
    way : dict
    cpt : int
        way counter


    Methods
    -------

    ways
    eval
    show

    &quot;&quot;&quot;
    w = {}
    way = {}
    cpt = 0

<div class="viewcode-block" id="Ways.ways"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Ways.html#pylayers.gis.osmparser.Ways.ways">[docs]</a>    def ways(self, ways):
        &quot;&quot;&quot; general callback function
        &quot;&quot;&quot;
        for osmid, tags, refs in ways:
            self.w[osmid] = [refs,tags]
            self.cpt += 1</div>

    def __repr__(self):
        st = &#39;&#39;
        for kid in self.w:
            st = st + str(self.w[kid])+&#39;\n&#39;
        return st

<div class="viewcode-block" id="Ways.clean"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Ways.html#pylayers.gis.osmparser.Ways.clean">[docs]</a>    def clean(self):
        &quot;&quot;&quot; clean ways

        &quot;&quot;&quot;
        self.w = {}
        self.way = {}
        self.cpt = 0</div>

<div class="viewcode-block" id="Ways.building"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Ways.html#pylayers.gis.osmparser.Ways.building">[docs]</a>    def building(self, ways, height=8.5, min_heigh=0):
        &quot;&quot;&quot; building callback function

        Parameters
        ----------

        ways : Ways
        height : float

        &quot;&quot;&quot;
        for osmid, tags, refs in ways:
            if &#39;building&#39; in tags:
                ntags ={}
                # height : from ground to roof top
                if &#39;height&#39; in tags:
                    ntags[&#39;height&#39;] = tags[&#39;height&#39;]
                elif &#39;building:height&#39; in tags:
                    ntags[&#39;height&#39;]  = tags[&#39;building:height&#39;]
                else:
                    ntags[&#39;height&#39;] = height

                # min_height : from ground to roof top
                if &#39;building:min_height&#39; in tags:
                    ntags[&#39;min_height&#39;] = tags[&#39;building:min_height&#39;]
                elif &#39;min_height&#39; in tags:
                    ntags[&#39;min_height&#39;] = tags[&#39;min_height&#39;]
                else:
                    ntags[&#39;min_height&#39;] = min_height

                # material : from ground to roof top
                if &#39;building:material&#39; in tags:
                    ntags[&#39;material&#39;] = tags[&#39;building:material&#39;]
                elif &#39;material&#39; in tags:
                    ntags[&#39;material&#39;] = tags[&#39;material&#39;]
                else:
                    ntags[&#39;material&#39;] = &#39;WALL&#39;

                self.w[osmid] = [refs, ntags]
                self.cpt += 1</div>

    def toway(self,coords):
        &quot;&quot;&quot; convert into a Way object

        Parameters
        ----------

        coords : osm coordinates

        &quot;&quot;&quot;
        for osmid in self.w:
            refs = self.w[osmid][0]
            tags = self.w[osmid][1]
            away =  Way(refs, tags, coords)
            if away.valid:
                self.way[osmid] = away

<div class="viewcode-block" id="Ways.show"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Ways.html#pylayers.gis.osmparser.Ways.show">[docs]</a>    def show(self, typ=2, **kwargs):
        &quot;&quot;&quot; show all way

        Parameters
        ----------

        fig : figure
        ax  : axe
        typ : 0|1|2 (default)
                0 : display only way of typ 0  (Polygon)
                1 : display only way of typ 1  (Linestring)
                2 : display all way (default)
        &quot;&quot;&quot;
        if &#39;fig&#39; not in kwargs:
            fig = plt.figure(**kwargs)
        else:
            fig = kwargs[&#39;fig&#39;]

        if &#39;ax&#39; not in kwargs:
            ax = fig.gca()
        else:
            ax = kwargs[&#39;ax&#39;]

        lpoly  = []
        lonmin = 360
        lonmax = -360
        latmin = 360
        latmax = -360
        for b in self.way:
            if typ==0:
                if self.way.typ == 0:
                    p =ways.way[b].shp
            if typ==1:
                if self.way.typ == 1:
                    p = self.way[b].shp
            if typ==2:
                p = self.way[b].shp

            lpoly.append(p)

        city = PolyCollection(lpoly,closed=False)

        ax.axis((lonmin,lonmax,latmin,latmax))
        ax.add_collection(city)
        ax.autoscale_view()
        plt.axis(&#39;scaled&#39;)
        return(fig,ax)</div>

<div class="viewcode-block" id="Ways.tomaska"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Ways.html#pylayers.gis.osmparser.Ways.tomaska">[docs]</a>    def tomaska(self,m,lonlat=True):
        &quot;&quot;&quot; convert to masked array

        Parameters
        ----------

        m : Basemap object
            for converting to and from map projection coordinates
        lonlat : boolean
            returns in WGS84 format if True

        Returns
        -------

        ptma : masked array

        &quot;&quot;&quot;

        tpt  = np.empty((2,))
        mask = np.ones((2,))
        N = len(self.way.keys())
        for k,b in enumerate(self.way):
            # retrieve PolyGon or LineString
            # progress bar
            if k%1000==0:
                print(k,N)
            shp = self.way[b].shp
            if type(shp)==geu.Polygon:
                pa = self.way[b].shp.ndarray()
                Np = np.shape(pa)[1]
                for ip in range(Np+1):
                    tpt  = np.vstack((tpt,pa[:,ip%Np]))
                    mask = np.vstack((mask,np.array([[0,0]])))
                tpt = np.vstack((tpt,np.array([[0,0]])))
                mask = np.vstack((mask,np.array([[1,1]])))

        if lonlat:
            (lon,lat) = m(tpt[:,0],tpt[:,1],inverse=True)
            tpt = np.vstack([lon,lat]).T

        #vertices = np.ma.masked_array(tpt, mask)
        #return(vertices)
        return(tpt,mask)</div>

<div class="viewcode-block" id="Ways.showold"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Ways.html#pylayers.gis.osmparser.Ways.showold">[docs]</a>    def showold(self,fig=[],ax=[]):
        &quot;&quot;&quot; show ways

        Parameters
        ----------

        fig
        ax

        &quot;&quot;&quot;
        if fig==[]:
            fig = plt.figure()
        elif ax==[]:
            ax = fig.gca()

        for b in self.way:
            tags  = self.way[b].tags
            if (&#39;building&#39; in tags) | (&#39;buildingpart&#39; in tags):
                print(&quot;buildingpart found&quot;)
                try:
                    poly  = self.way[b].shp
                    if &#39;building:roof:colour&#39; in tags:
                        col = &#39;#&#39;+tags[&#39;building:roof:colour&#39;]
                    else:
                        col = &#39;#abcdef&#39;
                    fig, ax = poly.plot(fig=fig, ax=ax,color=col)
                except:
                    print(&quot;building: &quot;,b,&quot; is not a polygon&quot;)
        plt.axis(&#39;scaled&#39;)
        return(fig,ax)</div>

    def readmap1(self, osmmap, coords):
        &quot;&quot;&quot; read ways from a map

        osmmap : OSM Map from josm file
        coords : coords object previously parsed

        &quot;&quot;&quot;
        for item in osmmap:
            if item[&#39;type&#39;]==&#39;way&#39;:
                way = item[&#39;data&#39;]
                osmid = way[&#39;id&#39;]
                refs_neg = way[&#39;nd&#39;]
                # nodes should have negative index (PyLayers convention)
                tags  = way[&#39;tag&#39;]
                if &#39;z&#39; in tags:
                   z = tags[&#39;z&#39;]
                   if type(z) == str:
                       z = eval(z)
                   if type(z[0])==str:
                       z = (eval(z[0]),eval(z[1]))
                   tags[&#39;z&#39;] = z

                self.w[osmid] = [refs_neg,tags]
                self.cpt += 1

        self.toway(coords)


    def readmap2(self, osmmap, coords, typ=&#39;building&#39;):
        &quot;&quot;&quot; read ways from a map

        osmmap : OSM Map in json from OsmAPI
        coords : coords object previously parsed
        typ  : string
            type of ways to capture

        &quot;&quot;&quot;
        ltree =[]
        for item in osmmap:
            # parse trees
            if item[&#39;type&#39;]==&#39;node&#39;:
                node = item[&#39;data&#39;]
                tags = node[&#39;tag&#39;]
                if &#39;natural&#39; in tags:
                    if tags[&#39;natural&#39;]==&#39;tree&#39;:
                        ltree.append((node[&#39;lon&#39;],node[&#39;lat&#39;]))

            if item[&#39;type&#39;]==&#39;way&#39;:
                way = item[&#39;data&#39;]
                tags = way[&#39;tag&#39;]
                if typ in tags:
                    osmid = way[&#39;id&#39;]
                    refs_neg = way[&#39;nd&#39;]
                    refs_neg = [ -x for x in refs_neg if x &gt;0]
                    ntags = {}
                    # nodes should have negative index (PyLayers convention)
                    if &#39;height&#39; in tags:
                        ntags[&#39;height&#39;] = tags[&#39;height&#39;]
                    elif &#39;building:height&#39; in tags:
                        ntags[&#39;height&#39;]  = tags[&#39;building:height&#39;]

                    # min_height : from ground to roof top
                    if &#39;building:min_height&#39; in tags:
                        ntags[&#39;min_height&#39;] = tags[&#39;building:min_height&#39;]
                    elif &#39;min_height&#39; in tags:
                        ntags[&#39;min_height&#39;] = tags[&#39;min_height&#39;]

                    # material : from ground to roof top
                    if &#39;building:material&#39; in tags:
                        ntags[&#39;material&#39;] = tags[&#39;building:material&#39;]
                    elif &#39;material&#39; in tags:
                        ntags[&#39;material&#39;] = tags[&#39;material&#39;]
                    if &#39;z&#39; in tags:
                       z = tags[&#39;z&#39;]
                       if type(z) == str:
                           z = eval(z)
                       if type(z[0])==str:
                           z = (eval(z[0]),eval(z[1]))
                       ntags[&#39;z&#39;] = z

                    #print(&#39;osmparser readmap2&#39;,ntags)
                    self.w[osmid] = [refs_neg, ntags]
                    self.cpt += 1

        self.toway(coords)
        return(ltree)</div>
<div class="viewcode-block" id="Relations"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Relations.html#pylayers.gis.osmparser.Relations">[docs]</a>class Relations(object):
    relation = {}
    cpt = 0
<div class="viewcode-block" id="Relations.relations"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Relations.html#pylayers.gis.osmparser.Relations.relations">[docs]</a>    def relations(self,rels):
        for osmid,tags,member in rels:
                self.relation[osmid]={}
                self.relation[osmid][&#39;tags&#39;]=tags
                self.relation[osmid][&#39;members&#39;]=member
                self.cpt = self.cpt+1</div>
<div class="viewcode-block" id="Relations.clean"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.Relations.html#pylayers.gis.osmparser.Relations.clean">[docs]</a>    def clean(self):
        self.relation= {}
        self.cpt = 0</div></div>

<div class="viewcode-block" id="FloorPlan"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.FloorPlan.html#pylayers.gis.osmparser.FloorPlan">[docs]</a>class FloorPlan(nx.DiGraph):
    &quot;&quot;&quot; FloorPlan class derived from nx.DigGraph

    Methods
    -------

    build : recursive construction of floor plan 
    show : show the floor plan 

    &quot;&quot;&quot;

    def __init__(self,rootid,coords,nodes,ways,relations):
        &quot;&quot;&quot; object constructor

        Parameters
        ----------

        rootid
        coords
        nodes
        ways
        relations

        &quot;&quot;&quot;
        nx.DiGraph.__init__(self)
        self.rootid=rootid
        self.coords = coords
        self.nodes = nodes
        self.ways = ways
        self.relations = relations

    def __repr__(self):

        st = str(self.rootid)+&#39;\n&#39;
        levels = nx.neighbors(self,self.rootid)
        st = st + &#39;---&#39;+&#39;\n&#39;
        for l in levels:
            nw = len(nx.neighbors(self,l))
            st = st + str(l)+&#39; : &#39;+ str(nw) + &#39;\n&#39;
        return(st)



<div class="viewcode-block" id="FloorPlan.build"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.FloorPlan.html#pylayers.gis.osmparser.FloorPlan.build">[docs]</a>    def build(self,typ,eid):
        &quot;&quot;&quot; Notes : recursive construction

        Parameters
        ----------

        typ : string
            &#39;relation&#39; | &#39;way&#39; | &#39;node&#39;

        &quot;&quot;&quot;
        if typ==&#39;relation&#39;:
            tags = self.relations.relation[eid][&#39;tags&#39;]
            members  =  self.relations.relation[eid][&#39;members&#39;]
        if typ==&#39;way&#39;:
            tags = self.ways.way[eid].tags
            members  =  self.ways.way[eid].refs
        if typ==&#39;node&#39;:
            try:
                tags = self.nodes.node[eid][&#39;tags&#39;]
            except:
                tags = None
            members = None

        self.add_node(eid,tags=tags,type=typ)
        if members is not None:
            for m in members:
                if typ==&#39;relation&#39;:
                    eidn = m[0]
                    typn = m[1]
                if typ==&#39;way&#39;:
                    eidn = m
                    typn = &#39;node&#39;

                self.add_edge(eid,eidn)
                #self = self.build(typ=typn,eid=eidn)
                self.build(typ=typn,eid=eidn)</div>


<div class="viewcode-block" id="FloorPlan.show"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.FloorPlan.html#pylayers.gis.osmparser.FloorPlan.show">[docs]</a>    def show(self,nid=None,fig=[],ax=[]):
        &quot;&quot;&quot; show the floorplan

        Parameters
        ----------

        nid : int 
        fig : plt.figure 
        ax  : plt.ax

        &quot;&quot;&quot;
        if fig==[]:
            fig = plt.figure()
        elif ax==[]:
            ax = fig.gca()

        if nid ==None:
            nid = self.rootid
        nb = nx.neighbors(self,nid)
        for k in nb:
            #print k,self.node[k][&#39;type&#39;],self.node[k][&#39;tags&#39;]
            if self.node[k][&#39;type&#39;]==&#39;way&#39;:
                fig,ax = self.ways.way[k].show(fig=fig,ax=ax)
            else:
                fig,ax = self.show(k,fig=fig,ax=ax)
        return fig,ax</div></div>
#
#  Functions
#     getbdg
#
#
<div class="viewcode-block" id="getosm"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.getosm.html#pylayers.gis.osmparser.getosm">[docs]</a>def getosm(**kwargs):
    &quot;&quot;&quot; get osm region from osmapi

    Parameters
    ----------

    address : string
    latlon : tuple or 0
    dist_m : float
    bcart : boolean
    level_height :  float
        typical level height for deriving building height from # levels
    typical_height : float
        typical height for building when no information

    Returns
    -------

        coords
        nodes
        ways
        dpoly
        m
        latlon : tuple or 0

    Notes
    -----

    There are 3 ways to read an Open Street Map structure

    1 - From an osm file ex : filename = &#39;B11.osm&#39;
    2 - From an osm (lat,lon) string or tuple of float
    3 - From an osm address string

    if latlon tuple is precised, it has priority over the address string

    &quot;&quot;&quot;

    filename = kwargs.pop(&#39;filename&#39;,&#39;&#39;)
    bcart = kwargs.pop(&#39;cart&#39;, False)
    typ = kwargs.pop(&#39;typ&#39;,&#39;indoor&#39;)
    level_height = kwargs.pop(&#39;level_height&#39;, 3.45)
    typical_height = kwargs.pop(&#39;typical_height&#39;, 10)

    # from coordinates
    if filename == &#39;&#39;:
        address = kwargs.pop(&#39;address&#39;,&#39;Rennes&#39;)
        latlon = kwargs.pop(&#39;latlon&#39;, 0)
        dist_m = kwargs.pop(&#39;dist_m&#39;, 400)

        rad_to_deg = (180/np.pi)

        if latlon == 0:
            place = geo.osm(address)
            try:
                lat, lon = place.latlng
            except:
                print(place)
        else:
            lat = latlon[0]
            lon = latlon[1]

        r_earth = 6370e3

        alpha = (dist_m/r_earth)*rad_to_deg

    #
    # get map from OsmApi (Database query)
    # same extension in longitude and latitude
    #
        Osm = OsmApi()
        osmmap = Osm.Map(lon-alpha, lat-alpha, lon+alpha, lat+alpha)

    else:
    #
    # get map from osm (xml) file
    # type : &#39;node&#39;
    #        &#39;ways&#39;
    #
        latlon = 0
        e = xml.parse(filename).getroot()

        osmmap = []

        lnode_key = [&#39;id&#39;, &#39;lat&#39;, &#39;lon&#39;]

        lway_key = [&#39;id&#39;]

        for i in e:
            d = {}
            d[&#39;type&#39;] = i.tag
            d[&#39;data&#39;] = i.attrib
            #print(i.tag)

            if d[&#39;type&#39;] == &#39;node&#39;:
                for k in lnode_key:
                    try:
                        d[&#39;data&#39;][k] = eval(d[&#39;data&#39;][k])
                    except:
                        pass
                    if k == &#39;id&#39;:
                        if not &#39;action&#39; in d[&#39;data&#39;]:
                            d[&#39;data&#39;][k] = -d[&#39;data&#39;][k]
                d[&#39;data&#39;][&#39;tag&#39;] = {}

            elif d[&#39;type&#39;] == &#39;way&#39;:
                lk = i.getchildren()
                nd = []
                tag = {}
                for k in lk:
                    if k.tag == &#39;nd&#39;:
                        nd.append(eval(k.get(&#39;ref&#39;)))
                    if k.tag == &#39;tag&#39;:
                        tag[k.get(&#39;k&#39;)] = k.get(&#39;v&#39;)
                d[&#39;data&#39;][&#39;nd&#39;] = nd
                d[&#39;data&#39;][&#39;tag&#39;] = tag

                # for k in lway_key:
                #     lk = k.get_children()
                #     print(lk)

                    # d[&#39;data&#39;][k]=eval(d[&#39;data&#39;][k])
                # d[&#39;data&#39;][&#39;visible&#39;]=eval(d[&#39;data&#39;][&#39;visible&#39;])
            osmmap.append(d)

    nodes = Nodes()
    nodes.clean()
    nodes.readmap(osmmap)

    coords = Coords()
    coords.clean()
    coords.from_nodes(nodes)
    m = coords.cartesian(cart=bcart)

    ways = Ways()
    ways.clean()

    lat = coords.latlon[list(coords.latlon.keys())[0]][0]
    lon = coords.latlon[list(coords.latlon.keys())[0]][1]

    if typ == &#39;indoor&#39;:
        ways.readmap1(osmmap, coords)
    else:
        ltree = ways.readmap2(osmmap, coords)
    # list of nodes involved in buildings
    lnodes_id=[]
    for iw in ways.w:
        lnodes_id += ways.w[iw][0]
    # list of all nodes of coords

    lnodes_id  = np.unique(np.array(lnodes_id))
    lnodes_full = np.unique(np.array(list(coords.latlon.keys())))
    mask = np.in1d(lnodes_full, lnodes_id, invert=True)

    # nodes not involved in buildings

    #if typ != &#39;indoor&#39;:
    #    lexcluded = lnodes_full[mask]
    #    coords.filter(lexcluded)

    # dpoly = {}
    # for iw in ways.w:
    #     # ways.way[iw].tags = {}
    #     # # material
    #     # if &#39;material&#39; in ways.w[iw][1]:
    #     #     ways.way[iw].tags[&#39;name&#39;]=ways.w[iw][1][&#39;material&#39;]
    #     # elif &#39;building:material&#39; in ways.w[iw][1]:
    #     #     ways.way[iw].tags[&#39;name&#39;]=ways.w[iw][1][&#39;building:material&#39;]
    #     # else:
    #     #     ways.way[iw].tags[&#39;name&#39;]=&#39;WALL&#39;

    #     # # min_height
    #     # if &#39;building:min_height&#39; in ways.w[iw][1]:
    #     #     min_height = eval(ways.w[iw][1][&#39;building:min_height&#39;])
    #     # else:
    #     #     min_height = 0
    #     # # height
    #     # if &#39;height&#39; in ways.w[iw][1]:
    #     #     ways.way[iw].tags[&#39;z&#39;] = (min_height, eval(ways.w[iw][1][&#39;height&#39;]))
    #     # elif &#39;building:height&#39; in ways.w[iw][1]:
    #     #     ways.way[iw].tags[&#39;z&#39;] = (min_height, eval(ways.w[iw][1][&#39;building:height&#39;]))
    #     # elif &#39;building:levels&#39; in ways.w[iw][1]:
    #     #     nb_levels = eval(ways.w[iw][1][&#39;building:levels&#39;])
    #     #     if type(nb_levels)!=int:
    #     #         try:
    #     #             nb_levels = max(nb_levels)
    #     #         except:
    #     #             nb_levels=2
    #     #     ways.way[iw].tags[&#39;z&#39;]=(min_height,nb_levels*level_height)
    #     # elif &#39;levels&#39; in ways.w[iw][1]:
    #     #     nb_levels = eval(ways.w[iw][1][&#39;levels&#39;])
    #     #     if type(nb_levels)!=int:
    #     #         try:
    #     #             nb_levels=max(nb_levels)
    #     #         except:
    #     #             nb_levels=2
    #     #     ways.way[iw].tags[&#39;z&#39;] = (min_height,nb_levels*level_height)
    #     # else:
    #     #     ways.way[iw].tags[&#39;z&#39;] = (0,typical_height)

    #     ptpoly = [coords.xy[x] for x in ways.w[iw][0]]
    #     dpoly[iw] = geu.Polygon(ptpoly,vnodes=ways.w[iw][0])
    #     dpoly[iw].coorddeter()

    #return coords,nodes,ways,dpoly,m
    return coords, nodes, ways, m, (lat,lon)</div>
#
<div class="viewcode-block" id="extract"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.extract.html#pylayers.gis.osmparser.extract">[docs]</a>def extract(alat,alon,fileosm,fileout):
    &quot;&quot;&quot; extraction of an osm sub region using osmconvert

    Parameters
    ----------

    alat : array of latitude (1xn)
    alon : array of longitude (1xn)
    fileosm : source osm file
    filout  : output osm file

    Returns
    -------

    m : Basemap oject for coordinates conversion



    Notes
    -----

    This function takes two (1xn) arrays of latitude an longitude values
    Calculates extrema of those values.
    Invokes osmconvert script on a source fileosm and extract the
    corresponding zone in the fileout file.

    The functions returns a basemap object for coordinates conversion on this
    file.



    &quot;&quot;&quot;
    latmax = alat.max()
    latmin = alat.min()
    lonmax = alon.max()
    lonmin = alon.min()
    lon_0=(lonmax+lonmin)/2
    lat_0=(latmax+latmin)/2

    command = &#39;osmconvert -b=&#39;+str(lonmin)+&#39;,&#39;\
            + str(latmin)+&#39;,&#39;+str(lonmax)+&#39;,&#39;\
            + str(latmax)+&#39; &#39;+fileosm +&#39; &gt; &#39;+ fileout+&#39;.osm&#39;
    print(command)
    os.system(command)

    m = Basemap(llcrnrlon=lonmin,llcrnrlat=latmin,urcrnrlon=lonmax,urcrnrlat=latmax,
            resolution=&#39;i&#39;,projection=&#39;cass&#39;,lon_0=lon_0,lat_0=lat_0)

    return(m)</div>

<div class="viewcode-block" id="getbdg"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.getbdg.html#pylayers.gis.osmparser.getbdg">[docs]</a>def getbdg(fileosm,verbose=False):
    &quot;&quot;&quot; get building from osm file

    Parameters
    ----------

    fileosm : string

    Returns
    -------

    zone : list of Polygon

    &quot;&quot;&quot;

    coords,nodes,ways,relation,m = osmparse(fileosm,typ=&#39;outdoor&#39;,verbose=verbose)
    zone = []
    for w in ways.way:
        zone.append(ways.way[w].shp)
    return(zone)</div>

<div class="viewcode-block" id="buildingsparse"><a class="viewcode-back" href="../../../api/pylayers.gis.osmparser.buildingsparse.html#pylayers.gis.osmparser.buildingsparse">[docs]</a>def buildingsparse(filename):
    &quot;&quot;&quot; parse buildings

    Parameters
    ----------

    filename : string

    &quot;&quot;&quot;
    coords,nodes,ways,relations,m = osmparse(filename)
    for bid in relations.relation:
        tags = relations.relation[bid][&#39;tags&#39;]
        if tags[&#39;type&#39;]==&#39;outdoor&#39;:
            print(&quot;Constructing Indoor building &quot;, bid)
            bdg = FloorPlan(bid,coords,nodes,ways,relations)
            bdg.build(typ=&#39;relation&#39;,eid=bid)
    return bdg,m</div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team
      <span class="lastupdated">
        Last updated on Apr 05, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>