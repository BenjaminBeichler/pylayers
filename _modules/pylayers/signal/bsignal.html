

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.signal.bsignal &mdash; PyLayers</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_issue314.html">Exemple of issue 314</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_cover.html">Outdoor Radio Coverage with Deygout Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_dakar.html">Outdoor Radio Coverage with Deygout Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction_polar.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html">1&nbsp;&nbsp;&nbsp;pylayers.util.project Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.layout">2&nbsp;&nbsp;&nbsp;pylayers.gis.layout Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.selectl">3&nbsp;&nbsp;&nbsp;pylayers.gis.selectl Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.srtm">4&nbsp;&nbsp;&nbsp;pylayers.gis.srtm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.osmparser">5&nbsp;&nbsp;&nbsp;pylayers.gis.osmparser Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.ezone">6&nbsp;&nbsp;&nbsp;pylayers.gis.ezone Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antenna">7&nbsp;&nbsp;&nbsp;pylayers.antprop.antenna Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.aarray">8&nbsp;&nbsp;&nbsp;pylayers.antprop.aarray Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.spharm">9&nbsp;&nbsp;&nbsp;pylayers.antprop.spharm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antssh">10&nbsp;&nbsp;&nbsp;pylayers.antprop.antssh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antvsh">11&nbsp;&nbsp;&nbsp;pylayers.antprop.antvsh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.slab">12&nbsp;&nbsp;&nbsp;pylayers.antprop.slab Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.signature">13&nbsp;&nbsp;&nbsp;pylayers.antprop.signature Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.interactions">14&nbsp;&nbsp;&nbsp;pylayers.antprop.interactions Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffraction">15&nbsp;&nbsp;&nbsp;pylayers.antprop.diffraction Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffRT">16&nbsp;&nbsp;&nbsp;pylayers.antprop.diffRT Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.rays">17&nbsp;&nbsp;&nbsp;pylayers.antprop.rays Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.loss">18&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.channel">19&nbsp;&nbsp;&nbsp;pylayers.antprop.channel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id39">20&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coverage">21&nbsp;&nbsp;&nbsp;pylayers.antprop.coverage Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coeffModel">22&nbsp;&nbsp;&nbsp;pylayers.antprop.coeffModel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.link">23&nbsp;&nbsp;&nbsp;pylayers.simul.link Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit">24&nbsp;&nbsp;&nbsp;pylayers.simul.exploit Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit_simulnet">25&nbsp;&nbsp;&nbsp;pylayers.simul.exploit_simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simulnet">26&nbsp;&nbsp;&nbsp;pylayers.simul.simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simultraj">27&nbsp;&nbsp;&nbsp;pylayers.simul.simultraj Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.exploit.simnet">28&nbsp;&nbsp;&nbsp;pylayers.exploit.simnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesuwb">29&nbsp;&nbsp;&nbsp;pylayers.measures.mesuwb Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesmimo">30&nbsp;&nbsp;&nbsp;pylayers.measures.mesmimo Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.cormoran">31&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.vna.E5072A">32&nbsp;&nbsp;&nbsp;pylayers.measures.vna.E5072A Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.parker.smparker">33&nbsp;&nbsp;&nbsp;pylayers.measures.parker.smparker Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.bsignal">34&nbsp;&nbsp;&nbsp;pylayers.signal.bsignal Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.standard">35&nbsp;&nbsp;&nbsp;pylayers.signal.standard Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.device">36&nbsp;&nbsp;&nbsp;pylayers.signal.device Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.DF">37&nbsp;&nbsp;&nbsp;pylayers.signal.DF Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.waveform">38&nbsp;&nbsp;&nbsp;pylayers.signal.waveform Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.agent">39&nbsp;&nbsp;&nbsp;pylayers.mobility.agent Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.ban.body">40&nbsp;&nbsp;&nbsp;pylayers.mobility.ban.body Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id138">41&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pylayers.signal.bsignal</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.signal.bsignal</h1><div class="highlight"><pre>
<span></span>#-*- coding:Utf-8 -*-
r&quot;&quot;&quot;
.. currentmodule:: pylayers.signal.bsignal

.. autosummary::
    :toctree: generated

Bsignal Class
=============

.. autoclass:: Bsignal
    :members:

Usignal Class
=============

.. autoclass: Usignal
    :members:

TBsignal Class
==============

.. autoclass:: TBsignal
    :members:

TUsignal Class
==============

.. autoclass:: TUsignal
    :members:

FBsignal Class
==============

.. autoclass:: FBsignal
    :members:


FUsignal Class
==============

.. autoclass:: FUsignal
    :members:

FHsignal Class
================

.. autolass:: FHsignal
    :members:

Noise Class
===========

.. autoclass:: Noise
    :members:

&quot;&quot;&quot;
import doctest
import os
import pdb
import numpy as np
import scipy as sp
import scipy.interpolate as interp
import numpy.fft as fft
import pandas as pd
import matplotlib.gridspec as gridspec
from copy import *
import matplotlib.pylab as plt
import matplotlib.gridspec as gridspec
from mpl_toolkits.mplot3d import Axes3D
from pylayers.util.pyutil import *
from pylayers.util.plotutil import *
import scipy.io as ios
from scipy.signal import cspline1d, cspline1d_eval, iirfilter, iirdesign, lfilter, firwin , correlate
import seaborn as sns
#from sklearn import mixture
import scipy.stats as st


<div class="viewcode-block" id="Bsignal"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal">[docs]</a>class Bsignal(PyLayers):
    r&quot;&quot;&quot; Signal with an embedded time base

    This class gathers a 1D signal and its axis indexation.

    The x base is not necessarily uniform

    x has 1 axis

    x and the last axes of y have the same length

    By construction shape(y)[-1] :=len(x), len(x) takes priority in case of observed conflict

    &quot;&quot;&quot;

    def __init__(self, x=np.array([]), y=np.array([]),label=[]):
        r&quot;&quot;&quot; object constructor

        Parameters
        ----------

        x : ndarray (,Nx)
            primary axis (time or frequency)

        y : ndarray
            values  (...,Nx)
            the number of dimensions of y is arbitrary.
            the last dimension of y must be the primary axis
        label : list of labels

        &quot;&quot;&quot;
        self.x = x.astype(float)
        self.y = y.astype(complex)
        ndim = self.y.ndim
        if ndim==1:
            self.y=self.y.reshape((1,len(self.y)))
            ndim = 2
        assert((len(x)==self.y.shape[-1])or (self.y.shape[-1]==1) ),&quot; Dimension problem&quot;
        # default naming of the axis
        if label==[]:
            self.label=[]
            for k in range(ndim):
                self.label.append(&#39;ax&#39;+str(k))
        else:
            self.label=label

        shx = np.shape(self.x)
        shy = np.shape(self.y)
        self.N = shx[0]
        ly  = shy[-1]
        # multi axes indexation
        self.uax = np.hstack((np.ones(ndim-1),np.r_[self.N])).astype(&#39;int&#39;)
        # last dimension of y should be equal to first dimension of x
        #if (ly != self.N) :
        #    print &quot;Error in Bsignal : Dimension incompatibility &quot;
        #    print &quot;x : &quot;, self.N
        #    print &quot;y : &quot;, ly


    def __repr__(self):
        st = &#39;%s :  %s  %s &#39; % (
                            self.__class__.__name__,
                            str(np.shape(self.x)),
                            str(np.shape(self.y)))

        #for k in range(self.y.ndim):
        #    st = st + &#39;\n&#39; +self.label[k]+ &#39; : &#39; + str(self.y.shape[k])

        return(st)

<div class="viewcode-block" id="Bsignal.mean"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.mean">[docs]</a>    def mean(self):
        &quot;&quot;&quot; mean value of the signal
        &quot;&quot;&quot;
        S = type(self)()
        S.__dict__=self.__dict__
        S.x = self.x
        S.y = np.mean(self.y,axis=0)[None,:]
        return(S)</div>

<div class="viewcode-block" id="Bsignal.min"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.min">[docs]</a>    def min(self):
        &quot;&quot;&quot; min value of the signal (module if complex)
        &quot;&quot;&quot;
        S = type(self)()
        S.__dict__=self.__dict__
        S.x = self.x
        if np.iscomplex(self.y).any():
            S.y = np.min(np.abs(self.y),axis=0)[None,:]
        else:
            S.y = np.min(self.y,axis=0)[None,:]
        return(S)</div>

<div class="viewcode-block" id="Bsignal.max"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.max">[docs]</a>    def max(self):
        &quot;&quot;&quot; max value of the signal (module if complex)
        &quot;&quot;&quot;
        S = type(self)()
        S.__dict__=self.__dict__
        S.x = self.x
        if np.iscomplex(self.y).any():
            S.y = np.max(np.abs(self.y),axis=0)[None,:]
        else:
            S.y = np.max(self.y,axis=0)[None,:]

        return(S)</div>

<div class="viewcode-block" id="Bsignal.append"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.append">[docs]</a>    def append(self,bs):
        &quot;&quot;&quot; append bs to Bsignal
        &quot;&quot;&quot;
        assert((self.x==bs.x).all())
        self.y = np.vstack((self.y,bs.y))</div>

<div class="viewcode-block" id="Bsignal.extract"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.extract">[docs]</a>    def extract(self,u):
        r&quot;&quot;&quot; extract a subset of signal from index

        Parameters
        ----------

        u : np.array

        Returns
        -------

        O : Usignal

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; from pylayers.signal.bsignal import *
            &gt;&gt;&gt; import numpy as np
            &gt;&gt;&gt; x = np.arange(0,1,0.01)
            &gt;&gt;&gt; y = np.sin(2*np.pi*x)
            &gt;&gt;&gt; s = Bsignal(x,y)
            &gt;&gt;&gt; su = s.extract(np.arange(4,20))
            &gt;&gt;&gt; f,a = s.plot()
            &gt;&gt;&gt; f,a = su.plot()

        &quot;&quot;&quot;
        O = copy(self)
        O.x = O.x[u]
        O.y = O.y[...,u]
        return(O)</div>

<div class="viewcode-block" id="Bsignal.save"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.save">[docs]</a>    def save(self, filename):
        r&quot;&quot;&quot; save Bsignal in Matlab File Format

        Parameters
        ----------

        filename : string

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; from pylayers.signal.bsignal import *
            &gt;&gt;&gt; import matplotlib.pyplot as plt
            &gt;&gt;&gt; e = TUsignal()
            &gt;&gt;&gt; e.EnImpulse(feGHz=100)
            &gt;&gt;&gt; fig,ax = e.plot(typ=[&#39;v&#39;])
            &gt;&gt;&gt; tit1 = plt.title(&#39;original waveform&#39;)
            &gt;&gt;&gt; e.save(&#39;impulse.mat&#39;)
            &gt;&gt;&gt; del e
            &gt;&gt;&gt; h = TUsignal()
            &gt;&gt;&gt; h.load(&#39;impulse.mat&#39;)
            &gt;&gt;&gt; fig,ax = h.plot(typ=[&#39;v&#39;])
            &gt;&gt;&gt; tit2 = plt.title(&#39;retrieved waveform&#39;)

        See Also
        --------

        Bsignal.load

        &quot;&quot;&quot;

        d = {}
        d[&#39;x&#39;] = self.x
        d[&#39;y&#39;] = self.y
        ios.savemat(filename, d)</div>

<div class="viewcode-block" id="Bsignal.load"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.load">[docs]</a>    def load(self, filename):
        r&quot;&quot;&quot; load a Bsignal from a Matlab File

        Parameters
        ----------

        filename : string


        See Also
        --------

        Bsignal.save

        &quot;&quot;&quot;
        d = ios.loadmat(filename)
        self.x = d[&#39;x&#39;][0,:]
        self.y = d[&#39;y&#39;]
        if self.y.ndim==1:
            self.y = self.y[None,:]
        self.N = len(self.x)</div>

<div class="viewcode-block" id="Bsignal.setx"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.setx">[docs]</a>    def setx(self, x):
        r&quot;&quot;&quot; setx : set x vector

        Parameters
        ----------

        x : np.array

        Notes
        -----

        y is set to a zero vector

        Use __set__ instead

        &quot;&quot;&quot;
        self.x = x
        Np = len(self.x)
        self.y = np.zeros(Np, dtype=float)</div>

<div class="viewcode-block" id="Bsignal.sety"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.sety">[docs]</a>    def sety(self, fun):
        r&quot;&quot;&quot; sety : set y vector

        Parameters
        ----------

        fun : function

        &quot;&quot;&quot;
        self.y = fun(self.x)</div>

<div class="viewcode-block" id="Bsignal.stem"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.stem">[docs]</a>    def stem(self, **kwargs):
        r&quot;&quot;&quot; stem display

        Parameters
        ----------

        color : string
            default &#39;b-&#39;

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; from pylayers.signal.bsignal import *
            &gt;&gt;&gt; import matplotlib.pyplot as plt
            &gt;&gt;&gt; si = Bsignal()
            &gt;&gt;&gt; si.x= np.arange(100)
            &gt;&gt;&gt; si.y= np.arange(100)[None,:]
            &gt;&gt;&gt; f,a = si.stem()

        &quot;&quot;&quot;

        ndim = self.y.ndim

        if &#39;fig&#39; not in kwargs:
            fig = plt.figure()
        else:
            fig = kwargs[&#39;fig&#39;]

        if &#39;ax&#39; not in kwargs:
            ax = fig.gca()
        else:
            ax = kwargs[&#39;ax&#39;]

        if ndim &gt; 1:
            nl = len(self.y)
            for k in range(nl):
                ax.stem(self.x, self.y[k].squeeze(), **kwargs)
        else:
            ax.stem(self.x, self.y,**kwargs)
        return(fig,ax)</div>

<div class="viewcode-block" id="Bsignal.step"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.step">[docs]</a>    def step(self, color=&#39;b&#39;):
        r&quot;&quot;&quot; plot steps display

        Parameters
        ----------

        color : string
            default &#39;b-&#39;

        &quot;&quot;&quot;
        if ndim &gt; 1:
            nl = len(self.y)
            for k in range(nl):
                plt.plot(self.x, self.y[k], color, linestyle=&#39;steps&#39;)
        else:
            plt.plot(self.x, self.y, color, linestyle=&#39;steps&#39;)</div>

<div class="viewcode-block" id="Bsignal.cformat"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.cformat">[docs]</a>    def cformat(self,**kwargs):
        r&quot;&quot;&quot; complex format

        Parameters
        ----------

        sax : list
            selected output axis from y default [0,1]
            typ : string
            &#39;m&#39;   : modulus
            &#39;v&#39;   : value
            &#39;l10&#39; : dB (10 log10)
            &#39;l20&#39; : dB (20 log10)
            &#39;d&#39;   : phase degrees
            &#39;r&#39;   : phase radians
            &#39;du&#39;  : phase degrees unwrap
            &#39;ru&#39;  : phase radians unwrap
            &#39;gdn&#39; : group delay (ns)
            &#39;gdm&#39; : group distance (m)
            &#39;re&#39;  : real part
            &#39;im&#39;  : imaginary part
        sel  : list of ndarray()
            data selection along selected axis, all the axis void
            default [[],[]]
        ik : fixed axis value default (0)

        Returns
        -------

        a0 : first data axis
            this axis can be self.x or not
        a1 : second data axis
        dt : data

        ylabels : string
            label for the selected complex data format

        Notes
        -----

        This function returns 2 arrays x and y and the corresponding labels
        Convention : the last axis of y has same dimension as x
        y can have an arbitrary number of axis i.e a MIMO channel matrix
        could be x :  f and y : t x r x f

        Examples
        --------

        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; S = Bsignal()
        &gt;&gt;&gt; x = np.arange(100)
        &gt;&gt;&gt; y = np.arange(400).reshape(2,2,100)+1j*np.arange(400).reshape(2,2,100)
        &gt;&gt;&gt; S.x = x
        &gt;&gt;&gt; S.y = y
        &gt;&gt;&gt; S.cformat()
        (array([[-240.        ,   43.01029996],
               [  49.03089987,   52.55272505]]), &#39;Magnitude (dB)&#39;)



        &quot;&quot;&quot;
        defaults = {&#39;sax&#39; : [0,1],
                    &#39;typ&#39;:&#39;l20&#39;,
                    &#39;sel&#39; : [[],[]],
                    &#39;ik&#39; : 0
                   }

        for key, value in defaults.items():
            if key not in kwargs:
                kwargs[key] = value

        # shape of y and number of dimensions

        sely = np.squeeze(self.y)
        shy = sely.shape
        naxy = len(shy)

        # 2 axis selection
        ax = kwargs[&#39;sax&#39;]
        assert(len(ax)==2)

        # selected range on axis
        sel = kwargs[&#39;sel&#39;]
        ik  = kwargs[&#39;ik&#39;]

        # data selection on first axis
        if sel[0]==[]:
            # whole range
            us = 0
            uf = shy[ax[0]]
        else:
            # subset of values
            us = sel[0][0]
            uf = sel[0][-1]

        # data selection on second axis
        if sel[1]==[]:
            # whole range
            vs = 0
            vf = shy[ax[1]]
        else:
            # subset of values
            vs = sel[1][0]
            vf = sel[1][-1]


        # radians to degree conversion
        rtd = 180./np.pi

        t = kwargs[&#39;typ&#39;]

        if naxy ==1:
            dt = self.y[us:uf]
        elif naxy==2:
            dt = self.y[us:uf,vs:vf]
        elif naxy==3:
            if ((ax[0]==0) &amp; (ax[1]==1)):
                dt = sely[us:uf,vs:vf,ik]
            if ((ax[0]==0) &amp; (ax[1]==2)):
                dt = sely[us:uf,ik,vs:vf]
            if ((ax[0]==1) &amp; (ax[1]==2)):
                dt = sely[ik,us:uf,vs:vf]
        elif naxy==4:
            if ((ax[0]==0) &amp; (ax[1]==1)):
                dt = sely[0,us:uf,vs:vf,ik]
            if ((ax[0]==0) &amp; (ax[1]==2)):
                dt = sely[0,us:uf,ik,vs:vf]
            if ((ax[0]==1) &amp; (ax[1]==2)):
                dt = sely[0,ik,us:uf,vs:vf]

        if t==&#39;m&#39;:
            ylabels=&#39;Magnitude&#39;
            dt = np.abs(dt)
        if t==&#39;v&#39;:
            ylabels=&#39;Amplitude&#39;
            dt = dt
        if t==&#39;l10&#39;:
            ylabels=&#39;Magnitude (dB)&#39;
            dt = 10*np.log10(np.abs(dt)+1e-12)
        if t==&#39;l20&#39;:
            ylabels=&#39;Magnitude (dB)&#39;
            dt = 20*np.log10(np.abs(dt)+1e-12)
        if t==&#39;d&#39;:
            ylabels=&#39;Phase (deg)&#39;
            dt = np.angle(dt)*rtd
        if t==&#39;r&#39;:
            ylabels=&#39;Phase (rad)&#39;
            dt = np.angle(dt)
        if t==&#39;du&#39;:
            ylabels=&#39;Unwrapped Phase (deg)&#39;
            dt = np.unwrap(np.angle(dt))*rtd
        if t==&#39;ru&#39;:
            ylabels=&#39;Unwrapped Phase (rad)&#39;
            dt = np.unwrap(np.angle(dt))
        if t==&#39;re&#39;:
            ylabels=&#39;Real part&#39;
            dt = np.real(dt)
        if t==&#39;im&#39;:
            ylabels=&#39;Imaginary part&#39;
            dt = np.imag(dt)
        if t==&#39;gdn&#39;:
            ylabels=&#39;Group delay (ns)&#39;
            df  = self.x[1]-self.x[0]
            dt  = -np.diff(np.unwrap(np.angle(dt)))/(2*np.pi*df)
        if t==&#39;gdm&#39;:
            ylabels=&#39;Group distance (m)&#39;
            df  = self.x[1]-self.x[0]
            dt = -0.3*np.diff(np.unwrap(np.angle(dt)))/(2*np.pi*df)
        if &#39;ylabels&#39;  in kwargs:
            ylabels = kwargs[&#39;ylabels&#39;]

        return(dt,ylabels)</div>

<div class="viewcode-block" id="Bsignal.imshow"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.imshow">[docs]</a>    def imshow(self,**kwargs):
        r&quot;&quot;&quot; imshow of y matrix

        Parameters
        ----------

        interpolation : string
            &#39;none&#39;|&#39;nearest&#39;|&#39;bilinear&#39;
        cmap : colormap
            plt.cm.jet
        aspect : string
            &#39;auto&#39; (default) ,&#39;equal&#39;,&#39;scalar&#39;
        function : string
            {&#39;imshow&#39;|&#39;pcolormesh&#39;}
        typ : string
            &#39;l20&#39;,&#39;l10&#39;
        vmin : min value
        vmax : max value
        sax  : list
            select axe
        bindex

        Examples
        --------


        &gt;&gt;&gt; f = np.arange(100)
        &gt;&gt;&gt; y = np.random.randn(50,100)+1j*np.random.randn(50,100)
        &gt;&gt;&gt; F = FUsignal(f,y)

        &quot;&quot;&quot;
        defaults = {&#39;interpolation&#39;:&#39;none&#39;,
                    &#39;cmap&#39;:plt.cm.jet,
                    &#39;aspect&#39;:&#39;auto&#39;,
                    &#39;fontsize&#39;:20,
                    &#39;typ&#39;:&#39;l20&#39;,
                    &#39;function&#39;:&#39;imshow&#39;,
                    &#39;sax&#39;:[0,1],
                    &#39;bindex&#39;:[],
                    &#39;xlabel&#39;:&#39;&#39;,
                    &#39;ylabel&#39;:&#39;&#39;}

        for k in defaults.keys():
            if not k in kwargs:
                kwargs[k]=defaults[k]

        if not &#39;fig&#39; in kwargs:
            fig = plt.figure()
        else:
            fig = kwargs[&#39;fig&#39;]

        if not &#39;ax&#39; in kwargs:
            ax = fig.add_subplot(111)
        else:
            ax = kwargs[&#39;ax&#39;]

        #
        # bindex bound index [ixmin,ixmax,iamin,iamax]
        # 
        if kwargs[&#39;bindex&#39;]==[]:
            ixmin=0
            ixmax=len(self.x)-1
            iamin=0 
            iamax=np.shape(np.squeeze(self.y))[0]-1
        else:
            ixmin = kwargs[&#39;bindex&#39;][0]
            ixmax = kwargs[&#39;bindex&#39;][1]
            iamin = kwargs[&#39;bindex&#39;][2]
            iamax = kwargs[&#39;bindex&#39;][3]

        # axis selection with sax
        sax = kwargs[&#39;sax&#39;]

        # convert y data in desired format
        dt,ylabels = self.cformat(**kwargs)

        if &#39;vmin&#39; not in kwargs:
            vmin = dt.min()
        else:
            vmin = kwargs[&#39;vmin&#39;]

        if &#39;vmax&#39; not in kwargs:
            vmax = dt.max()
        else:
            vmax = kwargs[&#39;vmax&#39;]

        xmin = self.x[ixmin]
        xmax = self.x[ixmax]
        
        if hasattr(self,&#39;a&#39;): 
            ymin = self.a[iamin]
            ymax = self.a[iamax]
        else:
            ymin = max(iamin,0)
            imax = np.squeeze(dt).shape[0]
            ymax = min(iamax,imax)


        if kwargs[&#39;function&#39;]==&#39;imshow&#39;:
            im = ax.imshow(np.squeeze(dt)[iamin:iamax,ixmin:ixmax],
                       origin = &#39;lower&#39;,
                       vmin = vmin,
                       vmax = vmax,
                       aspect = kwargs[&#39;aspect&#39;],
                       extent = (xmin,xmax,ymin,ymax),
                       interpolation=kwargs[&#39;interpolation&#39;],
                       cmap = kwargs[&#39;cmap&#39;],
                       )

        ax.set_xlabel(kwargs[&#39;xlabel&#39;],fontsize=kwargs[&#39;fontsize&#39;])
        ax.set_ylabel(kwargs[&#39;ylabel&#39;],fontsize=kwargs[&#39;fontsize&#39;])

        ll = ax.get_xticklabels()+ax.get_yticklabels()
        for l in ll:
            l.set_fontsize(kwargs[&#39;fontsize&#39;])


        if kwargs[&#39;function&#39;] ==&#39;pcolormesh&#39;:
            im = ax.pcolormesh(xn,np.arange(dt.shape[0]),dt)

        cb = fig.colorbar(im)
        cb.set_label(ylabels,size=kwargs[&#39;fontsize&#39;])

        for t in cb.ax.get_yticklabels():
            t.set_fontsize(kwargs[&#39;fontsize&#39;])

        plt.axis(&#39;auto&#39;)
        fig.tight_layout()

        return fig, ax</div>

<div class="viewcode-block" id="Bsignal.plot"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.plot">[docs]</a>    def plot(self, **kwargs):
        r&quot;&quot;&quot; plot signal Bsignal

        Parameters
        ----------

        iy    : index of the waveform to plot (-1 = all)
        col   : string
            default  &#39;black&#39;
        vline : ndarray
        hline : ndarray
        unit1 : string
            default &#39;V&#39;
        unit2 : string
            default &#39;V&#39;
        xmin  : float
        xmax  : float
        ax    : axes instance or []
        dB    : boolean
            default False
        dist  : boolean
            default False
        display : boolean
            default True
        logx  : boolean
            defaut False
        logy  : boolean
            default False

        Returns
        -------

        fig : figure
        ax : np.array of axes

        See Also
        --------

        pylayers.util.plotutil.mulcplot


        &quot;&quot;&quot;

        iy = kwargs.pop(&#39;iy&#39;,-1)
        vline = kwargs.pop(&#39;vline&#39;,np.array([]))
        hline = kwargs.pop(&#39;hline&#39;,np.array([]))
        idx = kwargs.pop(&#39;idx&#39;,[0,0,0,0,0,0,0])
        unit1 = kwargs.pop(&#39;unit1&#39;,&#39;V&#39;)
        unit2 = kwargs.pop(&#39;unit2&#39;,&#39;V&#39;)
        xmin = kwargs.pop(&#39;xmin&#39;,-1e15)
        xmax = kwargs.pop(&#39;xmax&#39;,1e15)
        dist = kwargs.pop(&#39;dist&#39;,False)
        logx = kwargs.pop(&#39;logx&#39;,False)
        logy = kwargs.pop(&#39;logy&#39;,False)
        # filtering kwargs argument for plot function
        args = {}
        for k in kwargs:
            args[k]=kwargs[k]

        conversion = 1.0
        if ((unit1 == &#39;V&#39;) &amp; (unit2 == &#39;mV&#39;)):
            conversion = 1000

        # restriction of x support
        u = np.nonzero((self.x &gt; xmin) &amp; (self.x &lt; xmax))[0]

        #
        # convert ns in meter if dist=True
        #
        if dist:
            x = 0.3 * self.x[u]
        else:
            x = self.x[u]

        ndim = self.y.ndim
        #
        # if ndim(y) &gt; 1
        #

        if ndim == 4:
            Nmeas = self.y.shape[0]
            Nr = self.y.shape[1]
            Nt = self.y.shape[2]

            if iy==-1:
                fig,ax = plt.subplots(Nr,Nt)
                if ((Nr==1) and (Nt==1)):
                    ax = np.array([[ax]])

                for k in range(Nr):
                    for l in range(Nt):
                        for ix in idx:
                            yx = self.y[ix,k,l,u]
                            fig,a = mulcplot(self.x[u],yx*conversion,fig=fig,ax=ax[k,l],**args)
            else:
                fig = plt.gcf()
                ax = np.array([[plt.gca()]])
                yx = self.y[iy[0],iy[1],iy[2],u]
                fig,a = mulcplot(self.x[u],yx*conversion,fig=fig,ax=ax[0,0],**args)


        if ndim == 3:
            shy = self.y.shape
            yx = self.y.reshape(shy[0]*shy[1],shy[2])[:,u]
            fig,ax = mulcplot(self.x[u],yx*conversion,**args)
        if ndim == 2:
            if iy==-1:
                yx = self.y[:,u]
            else:
                yx = self.y[idx[0],u]
            fig,ax = mulcplot(self.x[u],yx*conversion,**args)
        if ndim == 1:
            fig,ax = mulcplot(self.x[u],self.y[u]*conversion,**args)

        #
        # Draw vertical and horizontal lines
        #
        # To be added in mulcplot
        #

        tcolor = [&#39;red&#39;, &#39;green&#39;, &#39;green&#39;, &#39;green&#39;, &#39;black&#39;, &#39;black&#39;, &#39;black&#39;]
        nl,nc = np.shape(ax)
        for l in range(nl):
            for c in range(nc):
                for i in range(len(vline)):
                    ax[l,c].axvline(vline[i], color=tcolor[i])
                for i in range(len(hline)):
                    ax.axhline(hline[i] * conversion, color=&#39;red&#39;)

        return(fig,ax)</div>

<div class="viewcode-block" id="Bsignal.flatteny"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.flatteny">[docs]</a>    def flatteny(self,yrange=[],reversible=False):
        r&quot;&quot;&quot; flatten y array

        Parameters
        ----------

        yrange : array of y index values to be flattenned
        reversible : boolean
            if True the sum is place in object member yf
            else y is smashed
        &quot;&quot;&quot;
        if self.y.ndim&gt;1:
            if yrange==[]:
                yrange = np.arange(self.y.shape[0])
            if reversible:
                self.yf = np.sum(self.y[yrange,:],axis=0)
            else:
                self.y = np.sum(self.y[yrange,:],axis=0)</div>

<div class="viewcode-block" id="Bsignal.gating"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.gating">[docs]</a>    def gating(self, xmin, xmax):
        r&quot;&quot;&quot; gating between xmin and xmax

        Parameters
        ----------

        xmin : float
        xmax : float

        Returns
        -------
            nothing self is modified

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; import numpy as np
            &gt;&gt;&gt; import matplotlib.pyplot as plt
            &gt;&gt;&gt; from pylayers.signal.bsignal import *
            &gt;&gt;&gt; x = np.linspace(-10,10,100)
            &gt;&gt;&gt; y = np.sin(2*np.pi*12*x)+np.random.normal(0,0.1,len(x))
            &gt;&gt;&gt; s = TUsignal(x,y)
            &gt;&gt;&gt; fig,ax = s.plot(typ=[&#39;v&#39;])
            &gt;&gt;&gt; txt1 = plt.title(&#39;before gating&#39;)
            &gt;&gt;&gt; plt.show()
            &gt;&gt;&gt; s.gating(-3,4)
            &gt;&gt;&gt; fig,ax=s.plot(typ=[&#39;v&#39;])
            &gt;&gt;&gt; txt2 = plt.title(&#39;after gating&#39;)
            &gt;&gt;&gt; plt.show()

        Warnings
        --------

            When a gating is applied the removed information is lost

        &quot;&quot;&quot;

        u = np.nonzero((self.x &gt; xmin) &amp; (self.x &lt; xmax))[0]
        Nx = len(self.x)
        shy = np.shape(self.y)
        if len(shy) &gt; 1:
            if shy[0] == Nx:
                Ny = shy[1]
                ind = 0
            else:
                Ny = shy[0]
                ind = 1

        w = np.zeros(Nx)
        w[u] = np.ones(len(u))
        if len(shy) &gt; 1:
            if ind == 0:
                w = np.outer(w, np.ones(Ny))
            else:
                w = np.outer(np.ones(Ny), w)
        self.y = self.y * w</div>

<div class="viewcode-block" id="Bsignal.len"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Bsignal.len">[docs]</a>    def len(self):
        r&quot;&quot;&quot; returm length of x axis
        &quot;&quot;&quot;
        return(len(self.x))</div></div>

<div class="viewcode-block" id="Usignal"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal">[docs]</a>class Usignal(Bsignal):
    r&quot;&quot;&quot; Signal with an embedded uniform Base

        This class inheritate from Bsignal. The only difference
        is that the x base is supposed to be uniform

    &quot;&quot;&quot;

    def __repr__(self):
        s = Bsignal.__repr__(self)
        return(s)

<div class="viewcode-block" id="Usignal.setx"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.setx">[docs]</a>    def setx(self, start, stop, dx):
        r&quot;&quot;&quot; set the x array of the Usignal (y=0)

        Parameters
        ----------
        start  : float
        stop   : float
        dx     : float

        Examples
        --------

        &gt;&gt;&gt; u = Usignal()
        &gt;&gt;&gt; u.setx(0,10,0.1)

        &quot;&quot;&quot;
        self.x = np.arange(start, stop, dx)
        Np = len(self.x)
        self.y = 1.0 * np.zeros(Np)</div>

<div class="viewcode-block" id="Usignal.dx"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.dx">[docs]</a>    def dx(self):
        r&quot;&quot;&quot;  get the time step of Usignal.x

        Examples
        ---------

        &gt;&gt;&gt; from pylayers.signal.bsignal import *
        &gt;&gt;&gt; u = Usignal()
        &gt;&gt;&gt; u.setx(0,10,0.1)
        &gt;&gt;&gt; assert(u.dx()==0.1)

        &quot;&quot;&quot;
        if (len(self.x)&gt;1):
            return(self.x[1] - self.x[0])
        else:
            return(0)</div>

<div class="viewcode-block" id="Usignal.resample"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.resample">[docs]</a>    def resample(self, x_new, kind=&#39;linear&#39;):
        &quot;&quot;&quot; resample the Usignal with a new x base

        x_new needs to be strictly included in the original x base of the Usignal.

        x is a 1D array
        y is a 2D array

        if y is complex the interpolation is done on module and unwrapped
        phase separately

        Parameters
        ----------

        x_new : ndarray
        kind  : string
            &#39;linear&#39; |&#39;spline&#39;
        &quot;&quot;&quot;
        if kind == &#39;linear&#39;:
            if np.iscomplex(self.y).any():
                module = abs(self.y)
                argu = np.unwrap(np.arctan2(np.imag(self.y), np.real(self.y)))
                fm = interp.interp1d(self.x, module)
                fa = interp.interp1d(self.x, argu)

                mod_new = fm(x_new)
                arg_new = fa(x_new)
                y_new = mod_new * (np.cos(arg_new) + 1j * np.sin(arg_new))
            else:
                f = interp.interp1d(self.x, self.y)
                y_new = f(x_new)

        if kind == &#39;spline&#39;:
            if np.iscomplex(self.y).any():
                module = abs(self.y)
                argu = unwrap(np.arctan2(np.imag(y), np.real(y)))
                coefm = splrep(self.x, module, s=0)
                coefa = splrep(self.x, argu, s=0)

                mod_new = splev(x_new, coefm, der=0)
                arg_new = splev(x_new, coefa, der=0)
                y_new = mod_new * (np.cos(arg_new) + 1j * np.sin(arg_new))
            else:
                coef = splrep(self.x, self.y, s=0)
                y_new = splev(x_new, coef, der=0)

        U = type(self)(x_new, y_new)
        return(U)</div>

<div class="viewcode-block" id="Usignal.alignc"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.alignc">[docs]</a>    def alignc(self, u2):
        &quot;&quot;&quot; align 2 Usignal

        alignc &lt;=&gt; intersection
        alignc : align two Usignal on a same base
            return a list which contains the two aligned signals

        Returns
        -------

        L : Usignal
            concatenated signal L1.y and L2.y


        &quot;&quot;&quot;
        u1 = self
        # shape analysis
        sh1 = list(u1.y.shape)
        sh2 = list(u2.y.shape)
        naxis1 = len(sh1)
        naxis2 = len(sh2)
        if naxis2==naxis1+1: # Ctt(2) x F(3)
            u1.y=u1.y[:,None,:]
        elif naxis2==naxis1+2: # w(2) x H (4)
            u1.y=u1.y[:,None,None,:]
        elif naxis2!=naxis1:
            print(&quot;alignement not allowed&quot;)

        #   Function to determine iuf 2 shape are compatible
        #    if naxis1&gt;naxis2:
        #        shs = sh2
        #        shl = sh1
        #    else:
        #        shs = sh1
        #        shl = sh2
        #    for k in range(len(shl)):
        #        sht = copy.copy(shs)
        #        sht.insert(k,1)
        #        g = list(np.array(sht)-np.array(shl)).pop(k)
        #        if np.sum(np.abs(np.array(g)))==0:
        #            u1.y = u1.y




        # nothing to align
        if len(u1.x)==len(u2.x):
            if (u1.x==u2.x).all():
                return u1.x,u1.y,u2.y

        #assert(naxis1==naxis2),

        dx1 = u1.dx()
        dx2 = u2.dx()

        u1_start = u1.x[0]
        u2_start = u2.x[0]
        u1_stop = u1.x[-1]
        u2_stop = u2.x[-1]

        # it starts at the maximum of both signal
        #    stops  at the minimum of both signal

        xstart = max(u1_start, u2_start)
        xstop = min(u1_stop, u2_stop)

        assert(xstop&gt;=xstart), &quot;error the 2 signal have disjoint support&quot;

        dx = min(dx1, dx2)
        if tstincl(u1.x, u2.x) == 0:
            print(&#39;Warning: impossible to align the 2 signals&#39;)

        if (dx1 &lt;= dx2):

            xnew = ininter(u1.x, xstart, xstop)

            dim1 = u1.len()
            #pstart1 = findpos(u1.x, xnew[0])
            pstart1 = np.where(u1.x==xnew[0])[0]
            #pstop1 = pstart1 + findpos(u1.x[pstart1:dim1], xnew[-1])
            pstop1 = pstart1 + np.where(u1.x[pstart1:dim1]==xnew[-1])[0]
            u1 = u1.truncate(pstart1, pstop1 + 1)

            u2 = u2.resample(xnew)

        if (dx2 &lt; dx1):

            xnew = ininter(u2.x, xstart, xstop)

            dim2 = u2.len()
            #pstart2 = findpos(u2.x, xnew[0])
            pstart2 = np.where(u2.x==xnew[0])[0]
            #pstop2 = pstart2 + findpos(u2.x[pstart2:dim2], xnew[-1])
            pstop2 = pstart2 + np.where(u2.x[pstart2:dim2] == xnew[-1])[0]

            u2 = u2.truncate(pstart2, pstop2 + 1)
            u1 = u1.resample(xnew)
        #L   = Usignal()
        #L.x = u1.x
        #L.y = np.vstack((u1.y,u2.y))
        #u1.y=u1.y[...,None]
        #u2.y=u2.y[...,None]
        #pdb.set_trace()
        #L.y = np.concatenate((u1.y,u2.y),axis=naxis1)

        return(u1.x,u1.y,u2.y)</div>

<div class="viewcode-block" id="Usignal.width"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.width">[docs]</a>    def width(self):
        r&quot;&quot;&quot; get the extension support of the Usignal

        width is conventionnaly equal to the difference between extremities + dx

        Returns
        -------

        w : float

        &quot;&quot;&quot;
        w = self.x[-1] - self.x[0] + self.dx()
        return(w)</div>

<div class="viewcode-block" id="Usignal.expand"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.expand">[docs]</a>    def expand(self, a):
        &quot;&quot;&quot; expand the time support by a scale factor a

        Parameters
        ----------
        a  : float
            expansion factor

        Returns
        -------

        Usignal  : support extended signal

        return a new Usignal with expanded factor a

        &quot;&quot;&quot;
        dx = self.dx()
        T1 = self.width()
        T2 = a * T1
        N3 = np.ceil((T2 - T1) / (2 * dx))
        s = self
        xstart = self.x[0] - N3 * dx
        xstop = self.x[-1] + N3 * dx
        sl = Usignal()
        sr = Usignal()
        sl.setx(xstart, self.x[0], dx)
        sr.setx(self.x[-1], xstop, dx)
        som = sl + s + sr
        return(som)</div>

<div class="viewcode-block" id="Usignal.max"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.max">[docs]</a>    def max(self):
        &quot;&quot;&quot;  maximum of Usignal

        Returns
        -------

        m : maximum value of self.y

        &quot;&quot;&quot;
        y = self.y
        nd = np.ndim(y)
        if nd == 1:
            m = y.max()
        else:
            m = y.max(axis=1)

        return (m)</div>

<div class="viewcode-block" id="Usignal.min"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.min">[docs]</a>    def min(self):
        &quot;&quot;&quot;  minimum of Usignal

        Returns
        -------

        m : maximum value of self.y

        &quot;&quot;&quot;
        y = self.y
        nd = np.ndim(y)
        if nd == 1:
            m = y.min()
        else:
            m = y.min(axis=1)

        return (m)</div>

<div class="viewcode-block" id="Usignal.truncate"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.truncate">[docs]</a>    def truncate(self, imin, imax,axis=-1):
        &quot;&quot;&quot; truncate USignal in range [posmin, posmax]

        Parameters
        ----------

        imin  : int
        imax  : int
        axis  : axis to truncate (default -1)

        Returns
        -------

        Usignal

        &quot;&quot;&quot;

        t = type(self).__name__
        shap = self.y.shape

        if axis==-1:
            x_new = self.x[imin:imax]
        else:
            x_new = self.x

        if (axis==-1):
            y_new = self.y[..., imin:imax]
        if (axis==0):
            y_new = self.y[imin:imax,...]
        if (axis==1):
            y_new = self.y[...,imin:imax,...]

        U = type(self)(x_new, y_new)

        return(U)</div>


<div class="viewcode-block" id="Usignal.abs"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.abs">[docs]</a>    def abs(self):
        &quot;&quot;&quot; return the absolute value of an Usignal

        Returns
        -------

        Usignal

        &quot;&quot;&quot;
        A = Usignal(self.x, abs(self.y))
        return(A)</div>

<div class="viewcode-block" id="Usignal.eprfl"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.eprfl">[docs]</a>    def eprfl(self,axis=-1):
        r&quot;&quot;&quot; Energy profile

        Parameters
        ----------

        axis : int

        Notes
        -----


        if axis==0

        $$\delta_x \sum_l |y(l,k)|^2$$

        if axis==1

        $$\delta_x \sum_k |y(l,k)|^2$$

        See Also
        --------

        cut

        &quot;&quot;&quot;

        eprfl = np.real(np.sum(self.y * np.conj(self.y),axis=axis))*self.dx()
        return eprfl</div>

<div class="viewcode-block" id="Usignal.energy"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.energy">[docs]</a>    def energy(self,axis=0):
        &quot;&quot;&quot; calculate the energy of an Usignal

        Parameters
        ----------

        axis : int
            (default : 0)

        Returns
        -------

        energy : float

        &quot;&quot;&quot;
        shy = self.y.shape
        nay = len(shy)
        energy = self.dx() * np.sum(self.y * np.conj(self.y),axis=nay-1)
        return(energy)</div>

<div class="viewcode-block" id="Usignal.fftshift"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.fftshift">[docs]</a>    def fftshift(self):
        self.y = fft.fftshift(self.y,axes=1)</div>

<div class="viewcode-block" id="Usignal.zright"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.zright">[docs]</a>    def zright(self, xmax):
        &quot;&quot;&quot; add zeros on the right until xmax

        Parameters
        ----------
        xmax : float

        &quot;&quot;&quot;
        dx = self.dx
        cmax = max(self.x)
        assert xmax &gt; cmax, &#39;Warning xmax &lt;= cmax&#39;
        xadd = np.linspace(cmax + dx, xmax, dx)
        yadd = np.zeros(len(xadd))
        self.x = np.hstack((self.x, xadd))
        self.y = np.hstack((self.y, yadd))</div>

<div class="viewcode-block" id="Usignal.zleft"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.zleft">[docs]</a>    def zleft(self, xmin):
        &quot;&quot;&quot; add zeros on the left  until xmin

        Parameters
        ----------
        xmin : float

        &quot;&quot;&quot;
        dx = self.dx
        cmin = min(self.x)
        assert xmin &lt; cmin, &#39;Warning xmin &gt;= cmin&#39;
        xadd = np.linspace(xmin, cmin - dx, dx)
        yadd = np.zeros(len(xadd))
        self.x = np.hstack((xadd, self.x))
        self.y = np.hstack((yadd, self.y))</div>

<div class="viewcode-block" id="Usignal.zlr"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.zlr">[docs]</a>    def zlr(self, xmin, xmax):
        &quot;&quot;&quot;  add zeros to the left and to the right

        Parameters
        ----------

        xmin : float
            add zeros before xmin
        xmax : float
            add zeros after xmax

        Notes
        -----

        This corresponds to a gating between xmin and xmax

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; from pylayers.signal.bsignal import *
            &gt;&gt;&gt; from matplotlib.pylab import *
            &gt;&gt;&gt; ip = TUsignal()
            &gt;&gt;&gt; ip.EnImpulse()
            &gt;&gt;&gt; f,a = ip.plot(typ=[&#39;v&#39;])
            &gt;&gt;&gt; ip.zlr(-10,10)
            &gt;&gt;&gt; f,a = ip.plot(typ=[&#39;v&#39;])

        &quot;&quot;&quot;
        dx = self.dx()
        cmin = min(self.x)
        cmax = max(self.x)
        shy = self.y.shape
        shyl = shy[0:-1]
        if cmin &gt; xmin:
            xaddl = np.arange(xmin, cmin - dx, dx)
            nshy = list(shyl)+[len(xaddl)]
            yaddl = np.zeros(nshy)
            self.x = np.hstack((xaddl, self.x))
            self.y = np.concatenate((yaddl, self.y))
        else:
            u = np.nonzero(self.x &gt;= xmin)
            self.x = self.x[u[0]]
            self.y = self.y[...,u[0]]

        if cmax &lt; xmax:
            xaddr = np.arange(cmax + dx, xmax, dx)
            nshy = list(shyl)+[len(xaddr)]
            yaddr = np.zeros(nshy)
            self.x = np.hstack((self.x, xaddr))
            self.y = np.concatenate((self.y, yaddr))
        else:
            u = np.nonzero(self.x &lt;= xmax)
            self.x = self.x[u[0]]
            self.y = self.y[...,u[0]]</div>

<div class="viewcode-block" id="Usignal.window"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Usignal.html#pylayers.signal.bsignal.Usignal.window">[docs]</a>    def window(self, win=&#39;hamming&#39;):
        &quot;&quot;&quot; windowing Usignal
        Parameters
        ----------

        win : string
            window type (&#39;hamming&#39;,&#39;blackman&#39;,&#39;hanning&#39;)

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; import numpy as np
            &gt;&gt;&gt; import matplotlib.pyplot as plt
            &gt;&gt;&gt; from pylayers.signal.bsignal import *
            &gt;&gt;&gt; x = np.arange(2,8,0.1)
            &gt;&gt;&gt; y = np.ones(len(x))
            &gt;&gt;&gt; U = Usignal(x,y)
            &gt;&gt;&gt; fig,ax = U.plot()
            &gt;&gt;&gt; U.window(&#39;hamming&#39;)
            &gt;&gt;&gt; fig,ax = U.plot()


        &quot;&quot;&quot;
        if win==&#39;rect&#39;:
            exit
        if win == &#39;hamming&#39;:
            w = np.hamming(len(self.x))[None,:]
        if win == &#39;blackman&#39;:
            w = np.blackman(len(self.x))[None,:]
        if win == &#39;hanning&#39;:
            w = np.hanning(len(self.x))[None,:]
        self.windowed = True
        self.y = self.y * w</div></div>

<div class="viewcode-block" id="TBsignal"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TBsignal">[docs]</a>class TBsignal(Bsignal):
    &quot;&quot;&quot;  Based signal in Time domain


    &quot;&quot;&quot;
    def __init__(self, x=np.array([]), y=np.array([]),label=[]):
        Bsignal.__init__(self, x, y)
        self.label = &#39;time (ns)&#39;

    def __repr__(self):
        s = Bsignal.__repr__(self)
        return(s)

<div class="viewcode-block" id="TBsignal.plot"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TBsignal.plot">[docs]</a>    def plot(self,**kwargs):
        &quot;&quot;&quot; plot TBsignal

        Parameters
        ----------

        unit1 : actual unit of data
        unit2 : unit for display
        dist : boolean
        xmin : float
        xmax : float
        logx : boolean
        logy :boolean

        Examples
        --------

        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from pylayers.signal.bsignal import *
        &gt;&gt;&gt; from matplotlib.pylab import *
        &gt;&gt;&gt; x = np.array( [ 1, 3 , 6 , 11 , 18])
        &gt;&gt;&gt; y = np.array( [ 0,1 ,-5, 8 , 10])
        &gt;&gt;&gt; s = Bsignal(x,y)
        &gt;&gt;&gt; fi = figure()
        &gt;&gt;&gt; fig,ax=s.plot(typ=[&#39;v&#39;])
        &gt;&gt;&gt; ti = title(&#39;TBsignal : plot&#39;)
        &gt;&gt;&gt; show()

        &quot;&quot;&quot;
        defaults = {&#39;iy&#39;  :  -1,
                  &#39;vline&#39; : np.array([]),
                  &#39;hline&#39; : np.array([]),
                  &#39;unit1&#39; : &#39;V&#39;,
                  &#39;unit2&#39; : &#39;V&#39;,
                  &#39;dist&#39;  : False ,
                  &#39;xmin&#39;  :-1e15,
                  &#39;xmax&#39;  : 1e15,
                  &#39;logx&#39;  : False,
                  &#39;logy&#39;  : False
                 }

        for key, value in defaults.items():
            if key not in kwargs:
                kwargs[key] = value

#        if tmin != -1e5:
#            xmin = tmin
#        else:
#            xmin = -1e5
#
#        if tmax != 1e5:
#            xmax = tmax
#        else:
#            xmax = tmax

        if kwargs[&#39;dist&#39;]:
            kwargs[&#39;xlabels&#39;]=[&#39;distance (m)&#39;]
        else:
            kwargs[&#39;xlabels&#39;]=[&#39;Time (ns)&#39;]


#        if kwargs[&#39;unit2&#39;] == &#39;mV&#39;:
#            if kwargs[&#39;type&#39;]==&#39;l20&#39;:
#                kwargs[&#39;ylabel&#39;]=[&#39;Voltage (dBmV)&#39;]
#            if kwargs[&#39;type&#39;]==&#39;v&#39;:
#                kwargs[&#39;ylabel&#39;]=[&#39;Voltage (mV)&#39;]
#
#        if kwargs[&#39;unit2&#39;] == &#39;V&#39;:
#            if kwargs[&#39;type&#39;]==&#39;l20&#39;:
#                kwargs[&#39;ylabel&#39;]=[&#39;Voltage (dBmV)&#39;]
#            if kwargs[&#39;type&#39;]==&#39;v&#39;:
#                plt.ylabel(&#39;Voltage (mV)&#39;)

        fig,ax = Bsignal.plot(self,**kwargs)
        #fig,ax = self.plot(**kwargs)

        return(fig,ax)</div>

<div class="viewcode-block" id="TBsignal.integ"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TBsignal.integ">[docs]</a>    def integ(self,Tns,Tsns=50):
        &quot;&quot;&quot; integation of alphak tauk of TBsignal

        used energy detector for IEEE 802.15.6 standard

        Parameters
        ----------

        Tns :
        Tsns :


        &quot;&quot;&quot;
        u1 = np.where(self.x&lt;(self.x[0]+Tns))[0]
        u2 = np.where((self.x&lt;(self.x[0]+Tsns+Tns)) &amp;
                      (self.x&gt;=(self.x[0]+Tsns)))[0]
        Hp = np.sum((self.y[u1])**2)
        Hi = np.sum((self.y[u2])**2)

        return(Hp,Hi)</div>

<div class="viewcode-block" id="TBsignal.translate"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TBsignal.translate">[docs]</a>    def translate(self, tau):
        &quot;&quot;&quot;  translate TBsignal signal by tau

        Parameters
        ----------
        tau : float
            delay for translation

        Warnings
        --------

        Once translated original signal and translated signal might not be on the same grid

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; from pylayers.signal.bsignal import *
            &gt;&gt;&gt; from matplotlib.pylab import *
            &gt;&gt;&gt; ip = TUsignal()
            &gt;&gt;&gt; ip.EnImpulse()
            &gt;&gt;&gt; ip.translate(-10)
            &gt;&gt;&gt; fig,ax=ip.plot(typ=[&#39;v&#39;])
            &gt;&gt;&gt; show()


        &quot;&quot;&quot;
        self.x = self.x + tau</div>

<div class="viewcode-block" id="TBsignal.b2tu"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TBsignal.b2tu">[docs]</a>    def b2tu(self, N):
        &quot;&quot;&quot; conversion from TBsignal to TUsignal

        Parameters
        ----------

        N : integer
            Number of points

        Returns
        -------

        U : TUsignal


        Notes
        -----

        This function exploits linear interp1d

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; from pylayers.signal.bsignal import *
            &gt;&gt;&gt; import matplotlib.pyplot as plt
            &gt;&gt;&gt; x = np.array( [ 1, 3 , 6 , 11 , 18])
            &gt;&gt;&gt; y = np.array( [ 0,1 ,-5, 8 , 10])
            &gt;&gt;&gt; sb = TBsignal(x,y)
            &gt;&gt;&gt; su20 = sb.b2tu(20)
            &gt;&gt;&gt; su100 = sb.b2tu(100)
            &gt;&gt;&gt; fi = plt.figure()
            &gt;&gt;&gt; st = sb.stem()
            &gt;&gt;&gt; fig,ax = su20.plot(color=&#39;k&#39;)
            &gt;&gt;&gt; fig,ax = su100.plot(color=&#39;r&#39;)
            &gt;&gt;&gt; ti = plt.title(&#39;b2tu : sb(blue) su20(black) su200(red)&#39;)

        &quot;&quot;&quot;

        fi = interp.interp1d(self.x, self.y, kind=&#39;linear&#39;)
        xn = np.linspace(self.x[0], self.x[-1], N)
        yn = fi(xn)
        U  = TUsignal(xn, yn)

        return U</div>

<div class="viewcode-block" id="TBsignal.b2tu2"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TBsignal.b2tu2">[docs]</a>    def b2tu2(self, fsGHz ,Tobsns):
        &quot;&quot;&quot; conversion from TBsignal to TUsignal

        Parameters
        ----------

        N : integer
            Number of points

        Returns
        -------

        U : TUsignal


        Notes
        -----

        This function exploits linear interp1d

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; from pylayers.signal.bsignal import *
            &gt;&gt;&gt; import matplotlib.pyplot as plt
            &gt;&gt;&gt; x = np.array( [ 1, 3 , 6 , 11 , 18])
            &gt;&gt;&gt; y = np.array( [ 0,1 ,-5, 8 , 10])
            &gt;&gt;&gt; sb = TBsignal(x,y)
            &gt;&gt;&gt; su20 = sb.b2tu(20)
            &gt;&gt;&gt; su100 = sb.b2tu(100)
            &gt;&gt;&gt; fi = plt.figure()
            &gt;&gt;&gt; st = sb.stem()
            &gt;&gt;&gt; fig,ax = su20.plot(color=&#39;k&#39;)
            &gt;&gt;&gt; fig,ax = su100.plot(color=&#39;r&#39;)
            &gt;&gt;&gt; ti = plt.title(&#39;b2tu : sb(blue) su20(black) su200(red)&#39;)

        &quot;&quot;&quot;
        Nf = np.round(fsGHz*Tobsns)
        dfGHz = fsGHz/(1.0*Nf)
        fGHz = np.linspace(0,fsGHz,Nf)
        tns = np.arange(0,Tobsns,1./fsGHz)
        assert(len(tns)==len(fGHz))
        uf = np.sum(self.y.T * np.exp(-2*1j*np.pi*fGHz[None,:]*self.x[:,None]),axis=0)
        ut = np.fft.ifft(uf)
        U = TUsignal(tns, ut)

        return U</div>

<div class="viewcode-block" id="TBsignal.tap"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TBsignal.tap">[docs]</a>    def tap(self,fcGHz,WGHz,Ntap):
        &quot;&quot;&quot; Back to baseband

        Parameters
        ----------
        fcGHz : float
            center frequency
        WGHz : float
            bandwidth
        Ntap : int
            Number of tap

        Notes
        -----

        Implement formula (2.52) from D.Tse book page 50

        &quot;&quot;&quot;
        # self.x : tauk   (,Nx)
        # self.y : alphak (1,Nx)
        # yb : 1 x delay x 1
        yb = self.y[...,None]*np.exp(-2 * 1j * np.pi *self.x[None,:,None] * fcGHz )
        # create a tap axis index l
        # l : 1 x 1 x tap
        l   = np.arange(Ntap)[None,None,:]
        # get delay
        # tau : 1 x delay x 1
        tau = self.x[None,:,None]
        # S : 1 x delay x tap
        S   = np.sinc(l-tau*WGHz)
        # htap : 1 x delay x tap
        htap  = np.sum(yb*S,axis=0)
        # htapi : integrates over delays
        # 1 x tap 
        htapi = np.sum(htap,axis=1)
        U = TUsignal(x=l,y=htapi)</div></div>

<div class="viewcode-block" id="TUsignal"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal">[docs]</a>class TUsignal(TBsignal, Usignal):
    &quot;&quot;&quot; Uniform signal in time domain

    This class inheritates from TBsignal and Usignal

    The signal can either be complex or real 

    &quot;&quot;&quot;
    def __init__(self, x=np.array([]), y=np.array([]),label=[]):
        super(TUsignal,self).__init__(x,y,label)

    def __add__(self, u):
        t = type(u).__name__
        if ((t == &#39;int&#39;) | (t == &#39;float&#39;)):
            U = type(self)(self.x, self.y + u)
        if type(u)==type(self):
            x,y1,y2 = self.align(u)
            U = type(self)()
            U.x = x
            #U.y = y1 + y2
            U.y = np.vstack((y1,y2))
        return(U)

    def __sub__(self, u):
        t = type(u).__name__
        if ((t == &#39;int&#39;) | (t == &#39;float&#39;)):
            U = type(self)(self.x, self.y - u)
        if type(u)==type(self):
            x,y1,y2 = self.align(u)
            U = type(self)()
            U.x = x
            U.y = y1 - y2
        return(U)

    def __mul__(self, u):
        t = type(u).__name__
        if ((t == &#39;int&#39;) | (t == &#39;float&#39;) | (t== &#39;float64&#39;) ):
            U = type(self)()
            U.x = self.x
            U.y = self.y*u
        if issubclass(type(self),type(u)):
            x,y1,y2 = self.align(u)
            U = type(self)()
            U.x = x
            U.y = y1 * y2

        return(U)


<div class="viewcode-block" id="TUsignal.diff"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.diff">[docs]</a>    def diff(self):
        &quot;&quot;&quot; numerical differentiation TUsignal

        Warnings
        ---------
            the number of points is reduced by one

        Examples
        --------

        .. plot::
            :source-include:

            #&gt;&gt;&gt; import numpy as np
            #&gt;&gt;&gt; from pylayers.signal.bsignal import *
            #&gt;&gt;&gt; from matplotlib.pyplot import *
            #&gt;&gt;&gt; x  = np.arange(0,1.0,0.1)
            #&gt;&gt;&gt; y  = x**3
            #&gt;&gt;&gt; su = TUsignal(x,y)
            #&gt;&gt;&gt; dsu   = su.diff()
            #&gt;&gt;&gt; ddsu  = dsu.diff()
            #&gt;&gt;&gt; dddsu = ddsu.diff()
            #&gt;&gt;&gt; fi = plt.figure()
            #&gt;&gt;&gt; fig,ax=su.plot(typ=[&#39;v&#39;] ,color=&#39;k&#39;)
            #&gt;&gt;&gt; fig,ax=dsu.plot(typ=[&#39;v&#39;],color=&#39;g&#39;,fig=fig,ax=ax)
            #&gt;&gt;&gt; fig,ax=ddsu.plot(typ=[&#39;v&#39;],color=&#39;r&#39;,fig=fig,ax=ax)
            #&gt;&gt;&gt; fig,ax=dddsu.plot(typ=[&#39;v&#39;],color=&#39;b&#39;,fig=fig,ax=ax)
            #&gt;&gt;&gt; ti = plt.title(&#39;TUsignal : diff&#39;)
            #&gt;&gt;&gt; plt.show()

        &quot;&quot;&quot;
        V = TUsignal()
        V.y = np.diff(self.y)
        V.x = self.x[0:-1]
        return(V)</div>

<div class="viewcode-block" id="TUsignal.info"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.info">[docs]</a>    def info(self):
        &quot;&quot;&quot; display information about TUsignal

        &quot;&quot;&quot;
        print(&#39;TUsignal&#39;)
        print(&#39;--------&#39;)
        print(&#39;shx : &#39;, np.shape(self.x))
        print(&#39;shy : &#39;, np.shape(self.y))
        print(&#39;dx :  &#39;, self.dx())
        print(&#39;xmin :&#39;, self.x.min())
        print(&#39;xmax :&#39;, self.x.max())
        print(&#39;ymin :&#39;, self.y.min())
        print(&#39;ymax :&#39;, self.y.max())</div>



<div class="viewcode-block" id="TUsignal.fft"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.fft">[docs]</a>    def fft(self, shift=False):
        &quot;&quot;&quot;  forward fast Fourier transform of TUsignal


        Parameters
        ----------
        shift : boolean
            default False

        Warnings
        --------

        This fft is a scaled fft and takes into account the value of the sampling period.

        Returns
        -------

        FHsignal

        Examples
        --------

        &gt;&gt;&gt; from pylayers.signal.bsignal import *
        &gt;&gt;&gt; e = TUsignal()
        &gt;&gt;&gt; e.EnImpulse()
        &gt;&gt;&gt; E = e.fft()

        &quot;&quot;&quot;
        Np = len(self.x)
        te = self.x[1] - self.x[0]
        fe = 1.0 / te
        f = np.linspace(0, fe, Np, endpoint=False)
        y = fft.fft(self.y)
        S = FHsignal()
        S.x = f
        S.y = y
        S.y = S.y * te
        return(S)</div>

<div class="viewcode-block" id="TUsignal.fftsh"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.fftsh">[docs]</a>    def fftsh(self):
        &quot;&quot;&quot; returns an FHsignal

        Warnings
        --------

        This fft is a scaled fft and takes into account the value of the
        sampling period.

        Returns
        -------

        FHsignal : Frequency signal with enforced Hermitian symetry

        &quot;&quot;&quot;
        Np = len(self.x)
        te = self.x[1] - self.x[0]
        fe = 1.0 / te
        f = np.linspace(0, fe, Np, endpoint=False)
        #y = fft(self.y)
        #y = fftshift(y)
        y = fft.fftshift(self.y)
        y = fft.fft(y)
        S = FHsignal()
        S.x = f
        S.y = y
        S.y = S.y * te
        return(S)</div>


<div class="viewcode-block" id="TUsignal.align"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.align">[docs]</a>    def align(self, u2):
        &quot;&quot;&quot; align two TUsignal on a same base

        returns a list which contains the two aligned signals

        It is assume that both signal u1 and u2 share the same dx
        This function can be improved regarding time granularity

        Parameters
        ----------

        u2 : TUsignal

        Returns
        -------

        TUsignal y extended TU signal, x bases are adjusted

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; import matplotlib.pylab as plt
            &gt;&gt;&gt; from pylayers.signal.bsignal import *
            &gt;&gt;&gt; i1 = TUsignal()
            &gt;&gt;&gt; i2 = TUsignal()
            &gt;&gt;&gt; i1.EnImpulse()
            &gt;&gt;&gt; i2.EnImpulse()
            &gt;&gt;&gt; i2.translate(-10)
            &gt;&gt;&gt; i3 = i1.align(i2)
            &gt;&gt;&gt; fig,ax=i3.plot(typ=[&#39;v&#39;])
            &gt;&gt;&gt; plt.show()

        &quot;&quot;&quot;
        # copy object
        u1 = self

        # get the time termination of both signals
        u1_start = u1.x[0]
        u1_stop = u1.x[-1]

        u2_start = u2.x[0]
        u2_stop = u2.x[-1]

        # get dimensions
        #if u1.y.ndim&gt;1:
        #    N1 = self.y.shape[0]
        #    M1 = self.y.shape[1]
        #else:
        #    N1 = 1
        #    M1 = len(u1.y)
        #    u1.y = u1.y.reshape(1,M1)
        #
        #if u2.y.ndim&gt;1:
        #    N2 = u2.y.shape[0]
        #    M2 = u2.y.shape[1]
        #else:
        #    N2 = 1
        #    M2 = len(u2.y)
        #    u2.y = u2.y.reshape(1,M2)

        # get left shape and number of points on the last axis (time)

        shl1 = u1.y.shape[0:-1]
        M1 = u1.y.shape[-1]

        shl2 = u2.y.shape[0:-1]
        M2 = u2.y.shape[-1]

        # test if both signals share the same time support
        bool1 = abs(u1_start - u2_start) &lt; 1e-10
        bool2 = abs(u1_stop - u2_stop) &lt; 1e-10

        bool = bool1 &amp; bool2

        if (bool):
        # same x support (concatenation is direct)
        #    L = Usignal(u1.x, np.vstack((u1.y,u2.y)))
            #L = Usignal(x = u1.x,
            #            y = np.concatenate((u1.y,u2.y),axis=-1))
            #L = Usignal(x = u1.x,
            #            y = np.concatenate((u1.y,u2.y),axis=0))
            U1 = Usignal(x=u1.x,y=u1.y)
            U2 = Usignal(x=u1.x,y=u2.y)
        else:
        # different x support
        # =&gt; extension to the largest interval
            xstart = min(u1_start, u2_start)
            xstop = max(u1_stop, u2_stop)

            b1i = abs(xstart - u1.x[0]) &lt; 1e-15
            b2i = abs(xstart - u2.x[0]) &lt; 1e-15
            b1f = abs(xstop - u1.x[-1]) &lt; 1e-15
            b2f = abs(xstop - u2.x[-1]) &lt; 1e-15

            if (b1i &amp; b2f):
            # u1 is left u2 is right
                dx = u1.dx()
                T = xstop - xstart
                N = int(np.floor(T / dx))
                x = xstart + dx * np.arange(N)

                #Y1 = np.zeros((N1,N), dtype=float)
                #Y2 = np.zeros((N2,N), dtype=float)
                Y1 = np.zeros(list(shl1)+[N], dtype=float)
                Y2 = np.zeros(list(shl2)+[N], dtype=float)

                yleft   = u1.y
                yright  = u2.y
                Nleft  = min(N,M1)
                Nright = min(N,M2)
                Y1[...,0:Nleft] = yleft[...,0:Nleft]
                Y2[...,-Nright:] = yright[...,0:Nright]
                U1 = Usignal(x, Y1[...,0:N])
                U2 = Usignal(x, Y2[...,0:N])

            if (b2i &amp; b1f):
            # u2 is left u1 is right
                dx = u1.dx()
                T = xstop - xstart
                N = int(np.floor(T / dx))
                x = xstart + dx * np.arange(N)
                Y1 = np.zeros(list(shl1)+[N], dtype=float)
                Y2 = np.zeros(list(shl2)+[N], dtype=float)
                #Y1 = np.zeros((N1,N), dtype=float)
                #Y2 = np.zeros((N2,N), dtype=float)
                yleft = u2.y
                yright = u1.y
                Nleft = min(N, M2)
                Nright = min(N, M1)
                Y2[...,0:Nleft] = yleft[...,0:Nleft]
                Y1[...,-Nright:] = yright[...,0:Nright]
                U1 = Usignal(x, Y1[...,0:N])
                U2 = Usignal(x, Y2[...,0:N])

            if (b1i &amp; b1f):
            # u2 is included in u1
                U1 = u1
                x = u1.x
                indx = np.where((x &gt;= u2_start) &amp; (x &lt;= u2_stop))[0]
                U2 = Usignal(x=x,
                             y = np.zeros(list(shl2)+[len(x)] ))
                U2.y[...,indx] = u2.y[..., 0:np.shape(indx)[0]]

            if (b2i &amp; b2f):
            # u1 is included in u2
                U2 = u2
                x = u2.x
                indx = np.where((x &gt;= u1_start) &amp; (x &lt;= u1_stop))[0]
                U1 = Usignal(x=x,
                             y = np.zeros(list(shl1)+[len(x)]))
                U1.y[...,indx] = u1.y[...,0:np.shape(indx)[0]]

            #L = [U1, U2]
            #L   = Usignal()
            #L.x = U1.x
            #L.y = np.vstack((U1.y,U2.y))
        return U1.x,U1.y,U2.y</div>

<div class="viewcode-block" id="TUsignal.filter"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.filter">[docs]</a>    def filter(self, order=4, wp=0.3, ws=0.4, ftype=&#39;butter&#39;):
        &quot;&quot;&quot; TUsignal filtering

        Parameters
        ----------

        order : int
        wp    : float
        ws    : float
        ftype : string

        Returns
        -------

        O : Output filtered TUsignal


        &quot;&quot;&quot;
        O = TUsignal()
        #ba  = iirfilter(order,[wp,ws],ftype=ftype)
        print(&quot;wp = &quot;, wp)
        print(&quot;ws = &quot;, ws)
        #ba  = iirdesign(wp,ws,1,40,ftype=ftype)
        h = firwin(1001, [wp, ws])
        O.y = lfilter(h, 1, self.y)
        O.x = self.x
        return(O)</div>

<div class="viewcode-block" id="TUsignal.ftshift"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.ftshift">[docs]</a>    def ftshift(self):
         &quot;&quot;&quot; return the associated FUsignal

         Returns
         -------

         H : FUsignal

         See Also
         --------

         pylayers.signal.bsignal.TUsignal.fftsh
         pylayers.signal.waveform.ip_generic

         &quot;&quot;&quot;
         A  = self.fftsh()
         AU = A.unrex()
         return(AU)</div>


<div class="viewcode-block" id="TUsignal.psd"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.psd">[docs]</a>    def psd(self, Tpns=100, R=50,periodic=True):
        &quot;&quot;&quot; calculate TUsignal power spectral density

        Parameters
        ----------

        R    : Resistance (default 50 Ohms)
        Tpns : real
            PRP (default 100 ns)

        .. note::

            If time is in ns the resulting PSD is expressed in dBm/MHz (~10-9)

        &quot;&quot;&quot;
        P = self.esd(mode=&#39;unilateral&#39;)
        if periodic:
            P.y = P.y / (R * Tpns)
        return(P)</div>


<div class="viewcode-block" id="TUsignal.showpsd"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.showpsd">[docs]</a>    def showpsd(self,fig=[],ax=[],display=True,PRPns=100):
        &quot;&quot;&quot;  show psd

        Parameters
        ----------

        fig
        ax
        display

        See Also
        ---------

        pylayers.signal.bsignal.TUsignal.psd
        pylayers.signal.bsignal.Usignal.zlr

        &quot;&quot;&quot;
        if fig == []:
            fig = plt.gcf()

        Y = self.psd(PRPns)
        kboltzmann = 1.3806503e-23
        T = 300
        # +30 dBW/Hz -&gt; dBm/MHz
        N0dB = 10*np.log10(kboltzmann*T)+30

        u      = np.nonzero(Y.y&gt;N0dB)
        Pnoise = sum(Y.y[u])*Y.dx()

        ax1 = fig.add_subplot(121)
        self.plot()
        ax1.axhline(3*np.sqrt(Pnoise),color=&#39;r&#39;,linewidth=2)
        ax1.axhline(-3*np.sqrt(Pnoise),color=&#39;r&#39;,linewidth=2)
        plt.grid()
        ax2 = fig.add_subplot(122)
        #self.zlr(0,150)
        # unilateral
        plt.plot(Y.x, 10 * np.log10(Y.y), &#39;k&#39;)
        plt.xlabel(&#39;Frequency (GHz)&#39;)
        plt.xlim([1,10])
        ax2.axhline(N0dB,color=&#39;r&#39;,linewidth=2)
        plt.ylabel(&#39;PSD (dBm/MHz) assuming PRP=&#39;+str(PRPns)+&#39; ns&#39;)
        plt.grid()
        if display:
            plt.show()

        return(fig,[ax1,ax2])</div>

<div class="viewcode-block" id="TUsignal.esd"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.esd">[docs]</a>    def esd(self, mode=&#39;bilateral&#39;):
        &quot;&quot;&quot;  Calculate the energy spectral density of the U signal

        Parameters
        ----------

        mode : string
            &#39;unilateral&#39; | &#39;bilateral&#39;

        Returns
        -------

        FHsignal : if mode == &#39;bilateral&#39;
        FUsignal : if mode == &#39;unilateral&#39;

        See Also
        --------

        FHsignal.unrex

        &quot;&quot;&quot;
        te = self.dx()
        Y  = self.fft()
        #YY  = (te*te)*abs(Y.y)**2
        YY = abs(Y.y) ** 2
        O = FHsignal(Y.x, YY)
        if mode == &#39;unilateral&#39;:
            Ou = O.unrex()
            Ou.y = 2 * Ou.y
            return(Ou)
        return(O)</div>


<div class="viewcode-block" id="TUsignal.shift"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.shift">[docs]</a>    def shift(self, tau):
        &quot;&quot;&quot; shift the Usignal by tau (expressed in the same unit as Bsignal.x)

        This method uses fft and ifft to produce a shift which is not necessarily a
        multiple of the time step dx.

        Parameters
        ----------

        tau : float

        &quot;&quot;&quot;
        t = self.x
        S = self.fft()
        N = len(t)
        f = S.x
        Y = S.y
        arg = (2 * np.pi * f * tau) % (2 * np.pi)
        E = np.exp(-1j * arg)
        SD = Y * E
        cc = np.array([SD[0]])
        ze = np.array([0])
        if N % 2 == 0:
            U = SD[1:N / 2 + 1]
            V = np.concatenate((cc, U, np.flipud(np.conjugate(U[0:-1]))), 1)
        else:
            U = SD[1:(N - 1) / 2 + 1]
            V = np.concatenate((cc, U, np.flipud(np.conjugate(U))), 1)
        self.y = np.real(ifft(V))
        return(self)</div>

<div class="viewcode-block" id="TUsignal.correlate"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.correlate">[docs]</a>    def correlate(self, s, normalized = True):
        &quot;&quot;&quot; correlates with an other TUsignal

        Parameters
        ----------

        s : TUsignal
        normalized : boolean
            default True

        Notes
        -----
            The time step dx should be the same

            The chosen time reference is the one of the self signal
            This means that this function can be used to detect events appearing
            in the self signal by correlating with signal ..math:`s`, maximum of
            the correlation function appears in the proper time of the self signal
            history.

            **Interpretation of the correlation levels**

            We assume that s1 is the self signal and s2 is the correlating signal

            s1 = a1 * sn(t-tau)   where sn is normalized in energy
            s2 = a2 * sn(t)             &quot;   &quot;   &quot;   &quot;  &quot;

            the maximum of correlation appears at time tau and its value is

                    max (s1.correlate(s2,True)) = a1*a2

            In the case of the propagation simulation we have
                    s1 : the time domain UWB received waveform
                    s2 : the corresponding emitted waveform s2,

            To determine the ratio a1/a2 or a2/a1 in order to evaluate the propagation Loss L = 20 log10(a2/a1)

            This calculus assumes implicitely that the shape of the transmitted signal
            has not been modified during the propagation, which is a strong hypothesis.
            This calculus is then a minorant of the received energy.

            L = max(s1.correlate(s2,True)/s1.Energy)   with a1**2 = sum(s1**s1)*dx
    &quot;&quot;&quot;

        x = self.x
        xcorr = np.correlate(self.y, s.y, mode=&#39;full&#39;)
        dx = self.dx()
        Ns = len(s.x)
        Nxc = len(xcorr)
        t_left = x[0] + dx * (-np.arange(Ns / 2))[-1:0:-1]
        t = np.concatenate((t_left, x))
        Nt = len(t)
        Nright = Nxc - Nt
        t_right = x[-1] + dx + dx * np.arange(Nright)
        t = np.concatenate((t, t_right))
        phi = TUsignal()
        phi.x = t
        if normalized:
            phi.y = xcorr * dx
        else:
            phi.y = xcorr
        return(phi)</div>

<div class="viewcode-block" id="TUsignal.corrgauss"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.corrgauss">[docs]</a>    def corrgauss(self, sigma):
        &quot;&quot;&quot; Correlate TUsignal with a normalized gaussian of standard deviation sigma

        Parameters
        ----------
        sigma : float
            standard deviation of Gaussian

        &quot;&quot;&quot;
        dx = self.dx()
        t = np.arange(-10 * sigma, 10 * sigma, dx)
        gn = TUsignal(t, 1. / (np.sqrt(2 * np.pi) * sigma) *
                      np.exp(-(t ** 2) / (2 * sigma ** 2)))
        pcorr = self.correlate(gn)
        fac = np.sqrt(2) * 1.15
        p = TUsignal(pcorr.x, pcorr.y * fac)
        return p</div>

<div class="viewcode-block" id="TUsignal.Efirst_loc"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.Efirst_loc">[docs]</a>    def Efirst_loc(self, nint, E0):
        &quot;&quot;&quot; find the Efirst using the mean like

        Parameters
        ----------
        nint
        E0
        &quot;&quot;&quot;
        x = self.x
        y = self.y
        M = max(self.y)
        step = M / 1e2
        thre = M - step
        while step &gt; M / 1e5:
            u = np.nonzero(self.y &gt; thre)[0]
            if nbint(u) &lt; nint:
                thre = thre - step
            else:
                thre = thre + step
                step = step / 2

        w = u[1:] - u[0:-1]
        w0 = np.nonzero(w != 1)[0]
        vv = u[0:w0[0] + 1]
        ff = max(y[vv])
        Efirst = ff / E0
        Efirst = 20 * np.log10(Efirst)
        return(Efirst)</div>


<div class="viewcode-block" id="TUsignal.ft"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.ft">[docs]</a>    def ft(self):
        &quot;&quot;&quot; return the associated FUsignal
        &quot;&quot;&quot;
        A = self.fft()
        AU = A.unrex()
        return(AU)</div>

<div class="viewcode-block" id="TUsignal.convolve"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.convolve">[docs]</a>    def convolve(self, u):
        &quot;&quot;&quot; time domain convolution
        &quot;&quot;&quot;
        dx = u.dx()
        i0 = np.nonzero((u.x &lt; dx) &amp; (u.x &gt; -dx))[0]
        ind0 = i0[0]
        N1 = len(self.x)
        N2 = len(u.x)
        t0 = self.x[0]
        t = np.arange(t0 - ind0 * dx, t0 + (N1 + N2 - 1 - ind0) * dx, dx)
        y = convolve(self.y, u.y)
        v = TUsignal(t[0:len(y)], convolve(self.y, u.y))
        return(v)</div>

<div class="viewcode-block" id="TUsignal.Yadd_zeros2l"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.Yadd_zeros2l">[docs]</a>    def Yadd_zeros2l(self, N):
        &quot;&quot;&quot; time domain extension on the left with N zeros

        Parameters
        ----------

        N : integer
            number of additinal zero values

        See Also
        --------

        Yadd_zeros2r


        Work only for single y
        &quot;&quot;&quot;
        te = self.dx()
        self.y = np.hstack((np.zeros(N), self.y))
        aux = np.arange(N) * te
        t0 = self.x[0]
        self.x = np.hstack((aux - (aux[-1] - t0 + te), self.x))</div>

<div class="viewcode-block" id="TUsignal.Yadd_zeros2r"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.Yadd_zeros2r">[docs]</a>    def Yadd_zeros2r(self, N):
        &quot;&quot;&quot; time domain extension on right with N zeros

        Parameters
        ----------

        N : integer
            number of additinal zero values

        See Also
        --------

        Yadd_zeros2l

        &quot;&quot;&quot;
        te = self.dx()
        self.y = np.hstack((self.y, np.zeros(N)))
        aux = np.arange(N) * te
        t1 = self.x[-1]
        self.x = np.hstack((self.x, aux - (aux[0] - t1 - te)))</div>

#    def window(self,**kwargs):
#        &quot;&quot;&quot;
#        &quot;&quot;&quot;
#        defaults = {&#39;kind&#39;:&#39;rect&#39;,
#                    &#39;fGHz&#39;:[]}
#
#        for k in defaults:
#            if k not in kwargs:
#                kwargs[k]=defaults[k]
#

<div class="viewcode-block" id="TUsignal.Impulse"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.Impulse">[docs]</a>    def Impulse(self,**kwargs):
        &quot;&quot;&quot;
        Create a Gaussian impulse (Usignal)

        Parameters
        ----------

        fcGHz : float
        WGHz : float
        threshdB : float
        feGHz : float

        &quot;&quot;&quot;

        fcGHz = kwargs.pop(&#39;fcGHz&#39;,26)
        fsGHz = kwargs.pop(&#39;feGHz&#39;,100)
        t0 = kwargs.pop(&#39;t0&#39;,1)

        Ts = 1.0 / fsGHz
        Tww = 10 * t0

        Ni = int(round(Tww / (2 * Ts)))
        Tww = 2 * Ts * Ni

        x = np.linspace(-0.5 * Tww, 0.5 * Tww, 2 * Ni + 1)

        y = np.exp(-(x / (np.sqrt(2)*t0)) ** 2) * np.cos(2 * np.pi * fcGHz * x)
        self.x = x
        self.y = y[None,:]

        self.fcGHz = fcGHz</div>

<div class="viewcode-block" id="TUsignal.EnImpulse"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.EnImpulse">[docs]</a>    def EnImpulse(self,**kwargs):
        &quot;&quot;&quot;
        Create an energy normalized Gaussian impulse (Usignal)

        Parameters
        ----------

        fcGHz : float
        WGHz : float
        threshdB : float
        feGHz : float

        &quot;&quot;&quot;
        defaults = {&#39;fcGHz&#39; : 4,
                    &#39;WGHz&#39; : 3,
                    &#39;threshdB&#39; : 10,
                    &#39;fsGHz&#39; : 20
                   }

        for k in defaults:
            if k not in kwargs:
                kwargs[k]=defaults[k]

        WGHz = kwargs.pop(&#39;WGHz&#39;)
        fcGHz = kwargs.pop(&#39;fcGHz&#39;)
        fsGHz = kwargs.pop(&#39;fsGHz&#39;)
        threshdB = kwargs.pop(&#39;threshdB&#39;)

        #TUsignal.__init__(self)
        Tp = (2 / (WGHz * np.pi)) * np.sqrt(abs(threshdB) * np.log(10) /20.)
        coeff = np.sqrt(2 * np.sqrt(2)/ (Tp * np.sqrt(np.pi)))

        ts = 1.0 / fsGHz
        Tww = 10 * Tp
        Ni = int(round(Tww / (2 * ts)))
        # Tww/2 multiple de ts
        Tww = 2 * ts * Ni
        x = np.linspace(-0.5 * Tww, 0.5 * Tww, 2 * Ni + 1)

        y = coeff * np.exp(-(x / Tp) ** 2) * np.cos(2 * np.pi * fcGHz * x)
        self.x = x
        self.y = y[None,:]
        self.Tp = Tp
        self.fcGHz = fcGHz</div>


<div class="viewcode-block" id="TUsignal.MaskImpulse"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.TUsignal.MaskImpulse">[docs]</a>    def MaskImpulse(self,**kwargs):
        &quot;&quot;&quot;
        MaskImpulse : Create an Energy normalized Gaussian impulse (Usignal)
        &quot;&quot;&quot;

        def __init__(self, x=np.array([]), fc=4, band=3, thresh=10, Tp=100, Pm=-41.3, R=50, fe=100):
            &quot;&quot;&quot;

            Parameters
            ----------
            fc     : center frequency (GHz)
            band   : bandwidth (GHz)
            Tp     : Pulse repetion rate
            R      : Resistance
            Pm     : PSD max
            fe     : sampling freqeuncy
            thresh : definition of band at Pm - thresh (dB)

            &quot;&quot;&quot;
            self.fc = fc
            self.band = band
            self.thresh = thresh
            self.Tp = Tp
            self.Pm = Pm
            self.R = R
            self.fe = fe

            Usignal.__init__(self)
            #alpha  = 1./(2*np.sqrt(abs(thresh)*np.log(10)/20))
            alpha = 1. / (2 * np.sqrt(abs(thresh) * np.log(10) / 10))
            tau = 1 / (alpha * band * np.pi * np.sqrt(2))
            A = np.sqrt(2 * R * Tp * 10 ** (Pm / 10)) / (tau * np.sqrt(np.pi))
            if len(x) == 0:
                te = 1.0 / fe
                Tw = 10. / band
                Ni = int(round(Tw / (2 * te)))
                # Tww/2 multiple de te
                Tww = 2 * te * Ni
                x = np.linspace(-0.5 * Tww, 0.5 * Tww, 2 * Ni + 1)

            y = A * np.exp(-(x / tau) ** 2) * np.cos(2 * np.pi * fc * x)
            self.x = x
            self.y = y</div></div>


<div class="viewcode-block" id="FBsignal"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FBsignal">[docs]</a>class FBsignal(Bsignal):
    &quot;&quot;&quot;
    FBsignal : Base signal in Frequency domain

    plot     : plot modulus and phase
    plotri   : plot real part and imaginary part
    plotdB   : plot modulus in dB
    &quot;&quot;&quot;
    def __init__(self, x=np.array([]), y=np.array([]),label=[]):
        Bsignal.__init__(self, x, y)
        self.label=&#39;Frequency (GHz)&#39;

    def __repr__(self):
        s = Bsignal.__repr__(self)
        return(s)

<div class="viewcode-block" id="FBsignal.plotri"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FBsignal.plotri">[docs]</a>    def plotri(self, nb=-1):
        &quot;&quot;&quot; plot real and imaginary part

        Parameters
        ----------
        nb : int

        &quot;&quot;&quot;
        ndim = self.y.ndim
        if ndim &gt; 1:
            # plot all
            if (nb == -1):
                nl = len(self.y)
                for k in range(nl):
                    plt.subplot(211)
                    plt.plot(self.x, np.real(self.y[k]))
                    plt.xlabel(&#39;Frequency (GHz)&#39;)
                    plt.ylabel(&#39;Real part&#39;)
                    plt.subplot(212)
                    plt.plot(self.x, np.imag(self.y[k]))
                    plt.xlabel(&#39;Frequency (GHz)&#39;)
                    plt.ylabel(&#39;Imaginary part&#39;)
            # plot nb only
            else:
                plt.subplot(211)
                plt.plot(self.x, np.real(self.y[nb]))
                plt.xlabel(&#39;Frequency (GHz)&#39;)
                plt.ylabel(&#39;Real part&#39;)
                plt.subplot(212)
                plt.plot(self.x, np.imag(self.y[nb]))
                plt.xlabel(&#39;Frequency (GHz)&#39;)
                plt.ylabel(&#39;Imaginary part&#39;)
        else:
            plt.subplot(211)
            plt.stem(self.x, np.real(self.y))
            plt.xlabel(&#39;Frequency (GHz)&#39;)
            plt.ylabel(&#39;Real part&#39;)
            plt.subplot(212)
            #plot(self.x,np.unwrap(np.angle(self.y)))
            plt.stem(self.x, np.imag(self.y))
            plt.xlabel(&#39;Frequency (GHz)&#39;)
            plt.ylabel(&#39;Imaginary part&#39;)</div>

<div class="viewcode-block" id="FBsignal.plot"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FBsignal.plot">[docs]</a>    def plot(self, **kwargs):
        &quot;&quot;&quot; plot FBsignal

        Parameters
        ----------

        phase : boolean
            default True
        dB : boolean
            default True
        iy : index of y value to be displayed
        typ : string
            [&#39;l10&#39;,&#39;m,&#39;l20&#39;,&#39;d&#39;,&#39;r&#39;,&#39;du&#39;,&#39;ru&#39;]
        xlabels
        ylabels

        Examples
        --------

        &gt;&gt;&gt; from pylayers.signal.bsignal import *
        &gt;&gt;&gt; from numpy import *
        &gt;&gt;&gt; from scipy import *
        &gt;&gt;&gt; S = FBsignal()
        &gt;&gt;&gt; S.x = arange(100)
        &gt;&gt;&gt; S.y = cos(2*pi*S.x)+1j*sin(3*pi*S.x+pi/3)
        &gt;&gt;&gt; fig,ax = S.plot()
        &gt;&gt;&gt; plt.show()

        See Also
        --------

        Bsignal.plot
        pylayers.util.plotutil.mulcplot

        &quot;&quot;&quot;

        if &#39;typ&#39; not in kwargs:
            kwargs[&#39;typ&#39;] = [&#39;l20&#39;]
            kwargs[&#39;xlabels&#39;] = [&#39;Frequency (GHz)&#39;]

        fig,ax = Bsignal.plot(self,**kwargs)

        return fig,ax</div>

<div class="viewcode-block" id="FBsignal.plotdB"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FBsignal.plotdB">[docs]</a>    def plotdB(self, mask=False, n=2, phase=True):
        &quot;&quot;&quot; usage : plotdB()

        Parameters
        ----------
        mask :
        n :
        phase :

        &quot;&quot;&quot;
        ndim = self.y.ndim
        if ndim &gt; 1:
            nl = len(self.y)
            for k in range(nl):
                if phase:
                    plt.subplot(211)
                    plt.plot(self.x, 10 * n * np.log10(
                        abs(self.y[k]) + 1.0e-15))
                    plt.xlabel(&#39;Frequency (GHz)&#39;)
                    plt.ylabel(&#39;Modulus (dB)&#39;)
                    plt.subplot(212)
                    plt.plot(self.x, np.unwrap(np.angle(self.y[k])))
                    plt.xlabel(&#39;Frequency (GHz)&#39;)
                    plt.ylabel(&#39;Phase&#39;)
                else:
                    plt.plot(self.x, 10 * n * np.log10(
                        abs(self.y[k]) + 1.0e-15))
                    plt.xlabel(&#39;Frequency (GHz)&#39;)
                    plt.ylabel(&#39;Modulus (dB)&#39;)

        else:
            if mask:
                n = 1
                xfcc = np.array([0., 0.96, 0.96, 0.96, 0.96, 1.61, 1.61, 1.61, 1.61,
                                 1.99, 1.99, 1.99, 1.99, 3.1, 3.1, 3.1, 3.1, 10.6, 10.6, 10.6, 10.6, 15])
                xcept = np.array([0., 1.61, 1.61, 1.61, 1.61, 3.8, 3.8, 3.8, 3.8, 6.,
                                  6, 6, 6, 8.5, 8.5, 8.5, 8.5, 10.6, 10.6, 10.6, 10.6, 15])
                ycept = np.array([-90, -90, -90, -85, -85, -85, -85, -70, -70, -70, -70,
                                  -41.3, -41.3, -41.3, -41.3, -65, -65, -65, -65, -85, -85, -85])
                yfcc = np.array([-41.3, -41.3, -41.3, -75.3, -75.3, -75.3, -75.3, -53.3, -53.3,
                                 -53.3, -53.3, -51.3, -51.3, -51.3, -51.3, -41.3, -41.3, -41.3, -41.3, -51.3, -51.3, -51.3])
                xnoise = np.array([0., 15])
                ynoise = np.array([-114., -114])
                plt.step(xfcc, yfcc, &#39;b&#39;, linewidth=2)
                plt.step(xcept, ycept, &#39;r&#39;, linewidth=2)
                plt.step(xnoise, ynoise, &#39;k&#39;, linewidth=2)
                phase = False
                plt.axis([0, 15, -120, -40])
            plt.xlabel(&#39;Frequency (GHz)&#39;)
            plt.ylabel(&#39;PSD (dBm/MHz)&#39;)
            if phase:
                plt.subplot(211)
            plt.plot(self.x, 10 * n * np.log10(abs(self.y) + 1.0e-15),linewidth=0.3)
            if phase:
                plt.subplot(212)
                plt.plot(self.x, np.unwrap(np.angle(self.y)))
                plt.xlabel(&#39;Frequency (GHz)&#39;)
                plt.ylabel(&#39;Phase&#39;)</div>

<div class="viewcode-block" id="FBsignal.stem"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FBsignal.stem">[docs]</a>    def stem(self, color=&#39;b-&#39;):
        &quot;&quot;&quot; stem plot

        Parameters
        ----------
        color : string

        &quot;&quot;&quot;

        ndim = self.y.ndim
        if ndim &gt; 1:
            nl = len(self.y)
            for k in range(nl):

                plt.subplot(211)
                plt.stem(self.x, np.real(self.y[k].squeeze()), color)
                plt.xlabel(&#39;Frequency (GHz)&#39;)
                plt.ylabel(&#39;real part)&#39;)
                plt.subplot(212)
                plt.stem(self.x, np.imag(self.y[k].squeeze()), color)
                plt.xlabel(&#39;Frequency (GHz)&#39;)
                plt.ylabel(&#39;imaginary part)&#39;)
        else:

            plt.subplot(211)
            plt.stem(self.x, np.real(self.y), color)
            plt.xlabel(&#39;Frequency (GHz)&#39;)
            plt.ylabel(&#39;real part)&#39;)
            plt.subplot(212)
            plt.stem(self.x, np.imag(self.y), color)
            plt.xlabel(&#39;Frequency (GHz)&#39;)
            plt.ylabel(&#39;imaginary part)&#39;)</div></div>


<div class="viewcode-block" id="FUsignal"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal">[docs]</a>class FUsignal(FBsignal,Usignal):
    &quot;&quot;&quot;
    FUsignal : Uniform signal in Frequency Domain

    Attributes
    ----------

    x  : nd.array((1xN))
    y  : Complex nd.array((... x N )


    Methods
    -------

    symH     : force Hermitian symetry --&gt; FHsignal
    symHz    : force Hermitian symetry with zero padding --&gt; FHsignal
    align    : align two FUsignal on a same frequency base
    enthrsh  : Energy thresholding thresh = 99.99 %
    dBthrsh  : dB thresholding thresh  = 40dB
    ift      : Inverse Fourier transform
    resample : resampling with a new base
    newdf    : resampling with a new df
    zp       : zero padding until len(x) = N
    plotri   : plot real part and imaginary part
    plotdB   : plot modulus in dB
    get      : get k th ray
    window   :

    &quot;&quot;&quot;
    def __init__(self, x=np.array([]), y=np.array([]),label=[]):
        super(FUsignal,self).__init__(x,y,label)
        self.isFriis = False

    def __repr__(self):
        s = FBsignal.__repr__(self)
        return(s)

    def __add__(self, u):
        x,y1,y2 = self.alignc(u)
        U = FUsignal(x, y1 + y2)
        return(U)

    def __sub__(self, u):
        x,y1,y2 = self.alignc(u)
        U = FUsignal(x, y1 - y2)
        return(U)

    def __mul__(self, u):
        x,y1,y2 = self.alignc(u)
        U = FUsignal(x, y1 * y2)
        return(U)

    def __div__(self, u):
        x,y1,y2 = self.alignc(u)
        U = FUsignal(x, y1 / y2)
        return(U)


<div class="viewcode-block" id="FUsignal.applyFriis"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.applyFriis">[docs]</a>    def applyFriis(self):
        r&quot;&quot;&quot; apply Friis factor

        The Friis factor is multiplied to y

        .. math::
            y := \( \frac{-j c}{4 \pi f} \) y

            x is frequency in GHz

        boolean `isFriis` is set to `True`

        &quot;&quot;&quot;

        if not self.isFriis:
            factor = -1j*0.3/(4*np.pi*self.x)
            factor = factor.reshape(self.uax)
            self.y = self.y*factor
            self.isFriis = True</div>

<div class="viewcode-block" id="FUsignal.electrical_delay"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.FUsignal.html#pylayers.signal.bsignal.FUsignal.electrical_delay">[docs]</a>    def electrical_delay(self,tauns):
        self.y = self.y * np.exp(-2*1j*np.pi*self.x[None,:]*tauns)</div>

<div class="viewcode-block" id="FUsignal.get"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.get">[docs]</a>    def get(self, k):
        &quot;&quot;&quot;
        get the kth signal from the FUsignal

        Parameters
        ----------
        k : indes to get

        Returns
        -------

        G : FUsignal

        &quot;&quot;&quot;
        G = FUsignal()
        G.x = self.x
        G.y = self.y[k, :]
        return(G)</div>

<div class="viewcode-block" id="FUsignal.info"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.info">[docs]</a>    def info(self):
        &quot;&quot;&quot;
        Display Information about the FUsignal
        &quot;&quot;&quot;
        N = len(self.x)
        sh = np.shape(self.y)
        fmin = self.x[0]
        fmax = self.x[-1]
        df = self.x[1] - self.x[0]
        T = 1.0 / df
        print(&#39;FUsignal&#39;)
        print(&#39;--------&#39;)
        print(&#39;N Freq    &#39;, N)
        print(&#39;shape(y)  &#39;, sh)
        print(&#39;Fmin (GHz) : &#39;, fmin)
        print(&#39;Fmax (GHz) : &#39;, fmax)

        print(&#39;Frequency sampling step : &#39;, df)</div>

<div class="viewcode-block" id="FUsignal.energy"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.energy">[docs]</a>    def energy(self,axis=-1,Friis=False,mode=&#39;mean&#39;):
        r&quot;&quot;&quot; calculate energy along a given axis of the FUsignal

        Parameters
        ----------

        axis : (default 0)
        Friis : boolean
        mode : string
            mean (default)  | center | integ | first | last

        Examples
        --------

        &gt;&gt;&gt; ip = TUsignal()
        &gt;&gt;&gt; ip.EnImpulse()
        &gt;&gt;&gt; En1 = ip.energy()
        &gt;&gt;&gt; assert((En1&gt;0.99) &amp; (En1&lt;1.01))

        Notes
        -----

        If Friis is true energy is multiplied by

        :math:`\frac{-j*c}{4 pi fGHz}`

        axis = 0 is ray axis

        if mode == &#39;mean&#39;

        :math:`E=\frac{1}{K} \sum_k |y_k|^2`

        if mode == &#39;integ&#39;

        :math:`E=\delta_x \sum_k |y_k|^2`

        if mode == &#39;center&#39;

        :math:`E= |y_{K/2}|^2`

        &quot;&quot;&quot;

        H = self.y

        if Friis:
            factor = -1.j*0.3/(4*np.pi*self.x)
            H = H*factor[...,:]

        MH2 = abs(H * np.conjugate(H))

        if mode==&#39;mean&#39;:
            EMH2  = MH2.mean(axis=-1)

        if mode==&#39;integ&#39;:
            EMH2  = MH2.sum(axis=-1)*(self.x[1]-self.x[0])

        if mode==&#39;center&#39;:
            EMH2  = MH2[...,int(len(self.x)/2)]

        if mode==&#39;first&#39;:
            EMH2  = MH2[...,0]

        if mode==&#39;last&#39;:
            EMH2  = MH2[...,-1]

        return(EMH2)</div>


<div class="viewcode-block" id="FUsignal.enthrsh"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.enthrsh">[docs]</a>    def enthrsh(self, thresh=99.99):
        &quot;&quot;&quot; Energy thresholding of an FUsignal

        Parameters
        ----------

        thresh : float
            threshold in percentage (default 99.99)

        Returns
        -------

        EMH2 : cumul energie H

        &quot;&quot;&quot;
        H = self.y
        MH2 = abs(H * np.conjugate(H))
        EMH2 = MH2.sum(axis=1)
        EMH2max = EMH2.max()

        ind1 = EMH2.argsort()
        ind1rev = ind1[::-1, ]
        EMH2sorted = EMH2[ind1rev]

        EMH2cum = EMH2sorted.cumsum()
        EMH2cumnor = EMH2cum * 100 / EMH2cum[-1]
        ind2 = np.nonzero(EMH2cumnor &lt; thresh)[0]
        indices = ind1rev[ind2]

        self.indices = indices
        self.y = H[indices, :]
        self.taud = self.taud[indices]

        return indices</div>

<div class="viewcode-block" id="FUsignal.dBthrsh"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.dBthrsh">[docs]</a>    def dBthrsh(self, threshdB=40):
        &quot;&quot;&quot;
        dBthrsh : dB thresholding of an FUsignal
        &quot;&quot;&quot;
        H = self.y
        MH2 = abs(H * np.conjugate(H))
        EMH2 = MH2.sum(axis=1)
        EMH2dB = 10 * np.log10(EMH2)
        EMH2dBmax = EMH2dB.max()
        ind1 = EMH2.argsort()
        EMH2dBsorted = EMH2dB[ind1]
        ind2 = np.nonzero(EMH2dBsorted &gt; (EMH2dBmax - threshdB))[0]
        indices = ind1[ind2]
        return indices</div>

<div class="viewcode-block" id="FUsignal.zp"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.zp">[docs]</a>    def zp(self, N):
        &quot;&quot;&quot; zero padding until length N

        Parameters
        ----------
        N : int

        Returns
        -------
        FUsignal

        &quot;&quot;&quot;
        N0 = len(self.x)
        sh = np.shape(self.y)
        ndim = np.shape(sh)[0]
        if (ndim &gt; 1):
            N1 = sh[0]
            N2 = sh[1]
        dx = self.dx()
        if N0 &lt; N:
            M = N - N0
            ex = np.linspace(self.x[-1] + dx, self.x[-1] + M * dx, M)
            if (ndim &gt; 1):
                ey = np.zeros((N1, M))
            else:
                ey = np.zeros(M)
            x_new = np.hstack((self.x, ex))
            y_new = np.hstack((self.y, ey))
        U = FUsignal(x_new, y_new)
        return(U)</div>

<div class="viewcode-block" id="FUsignal.newdf"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.newdf">[docs]</a>    def newdf(self, df):
        &quot;&quot;&quot; resample the FUsignal using phase and module interpolation

        Parameters
        ----------
            df
        Returns
        -------
            U : FUsignal

        &quot;&quot;&quot;
        module = abs(self.y)
        df0 = self.x[1] - self.x[0]
        argu = np.unwrap(np.arctan2(np.imag(self.y), np.real(self.y)))
        fm = interp.interp1d(self.x, module)
        fa = interp.interp1d(self.x, argu)
        f_new = np.arange(self.x[0], self.x[-1], df)
        mod_new = fm(f_new)
        arg_new = fa(f_new)
        y_new = mod_new * (np.cos(arg_new) + 1j * np.sin(arg_new)
                           ) * np.exp(-1j * f_new * 2 * np.pi * 100)
        U = FUsignal(f_new, y_new)
        return(U)</div>

<div class="viewcode-block" id="FUsignal.dftresamp"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.dftresamp">[docs]</a>    def dftresamp(self, df_new):
        &quot;&quot;&quot; non finished

        Parameters
        ----------

        df_new :

        &quot;&quot;&quot;
        FH = self.symH(0)
        fh = FH.ifft()</div>



<div class="viewcode-block" id="FUsignal.symH"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.symH">[docs]</a>    def symH(self, parity=0):
        &quot;&quot;&quot; enforce Hermitian symetry

        Parameters
        ----------

        parity : integer
            0 even 1 odd

        Returns
        -------

        V  : FHsignal

        &quot;&quot;&quot;
        #assert self.x[0]!=0
        f = self.x
        U = self.y
        N = len(f)

        ys = U.shape
        ze_x = np.array([0])
        ze_y = np.zeros((ys[0],1))

        if parity == 0:
            Up = np.concatenate((ze_y, U, np.flipud(np.conjugate(U[:, 0:-1]))), 1)
            fp = np.concatenate((ze_x, f, f[0:-1] + f[-1]))
        else:
            Up = np.concatenate((ze_y, U, np.flipud(np.conjugate(U))), 1)
            fp = np.concatenate((ze_x, f, f + f[-1]))

        V = FHsignal(fp, Up)
        return V</div>

<div class="viewcode-block" id="FUsignal.symHz"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.symHz">[docs]</a>    def symHz(self,Nz,scale=&#39;extract&#39;):
        r&quot;&quot;&quot; Force Hermitian symmetry with zero padding

        Parameters
        ----------

        Nz :  int
            Number of zero above f[-1]
        scale : string
            default : &#39;extract&#39; | &#39;cir&#39;

        Returns
        -------

        SH : FHsignal

        Warnings
        --------

        The signal is rescaled in order to conserve energy

        Let denotes the FUsignal as :math:`mathcal{X}_d`
        The Fourier matrix is :math:`\left[ \matrix{\mathbb{1}\\
                                                    \mathbb{W}_d\\
                                                    \mathbb{W}_u}\right]`


        See Also
        --------

        FHSignal

        Examples
        --------

        &gt;&gt;&gt; N     = 11
        &gt;&gt;&gt; x     = np.linspace(2,11,N)
        &gt;&gt;&gt; y1    = sp.randn(N)+1j*sp.rand(N)
        &gt;&gt;&gt; y2    = sp.randn(N)+1j*sp.rand(N)
        &gt;&gt;&gt; y1[0] = 0
        &gt;&gt;&gt; y2[0] = 0
        &gt;&gt;&gt; y     = np.vstack((y1,y2))
        &gt;&gt;&gt; S     = FUsignal(x,y)
        &gt;&gt;&gt; FH =  S.symHz(10)

        &quot;&quot;&quot;
        f = self.x
        df = self.dx()
        if df == 0:
            df = 1.
        U = self.y[:]
        N = len(f)
        Nl = np.int(np.ceil(f[0] / df))

        ndim = U.ndim
        #
        # nline first dimension of self.y
        #
        nline = np.shape(U)[0:-1]
        if ndim &gt; 1:
            zl   = np.zeros(list(nline)+[Nl])
            zlm1 = np.zeros(list(nline)+[Nl-1])
        else:
            zl = np.zeros(Nl)
            zlm1 = np.zeros(Nl-1)

        if  Nz &gt; 0:
            if ndim &gt; 1:
                zh = np.zeros(list(nline)+[Nz])
                UZ = np.concatenate((U, zh), -1)
                #UZF = np.fliplr(np.conjugate(UZ))
                UZF = np.conjugate(UZ)[...,::-1]
            else:
                zh = np.zeros(Nz)
                UZ = np.concatenate((U, zh), 1)
                UZF = np.flipud(np.conjugate(UZ))
        #
        # frequency base is divided into two parts
        #
        # fl [ 0 , (Nl-1) *df ]
        # fh [ f[-1]+df , f[-1] + Nz *df ]
        #a
        fl = np.linspace(0, (Nl-1) * df, Nl)
        fh = np.linspace(f[-1] + df, f[-1] + Nz * df, Nz)
        fz = np.concatenate((f, fh), 0)
        #Up = np.concatenate((zl, UZ, UZF, zl), 1)
        #fp = np.concatenate((fl, fz, fz + fz[-1], fl + 2 * fz[-1]), 0)
        Up = np.concatenate((zl, UZ, UZF,zlm1), -1)
        fp = np.concatenate((fl, fz, fz + fz[-1], fl[0:-1] + 2 * fz[-1]), 0)

        Nfp = len(fp)
        if scale==&#39;extract&#39;:
            scale = np.sqrt(Nfp/(2.*N))

        if scale==&#39;cir&#39;:
            Df = df*Nfp
            #scale = ((Nfp-1)/(2*N))/Df
            scale = ((Nfp-1)/(2.*N))/Df

        #self.hermitian=True
        #self.x = fp
        #self.y = Up*scale
        V = FHsignal(fp, Up * scale)

        return V</div>


<div class="viewcode-block" id="FUsignal.ifft"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.ifft">[docs]</a>    def ifft(self, Npt=-1):
        r&quot;&quot;&quot; Inverse Fourier transform

        Parameters
        ----------

        Npt : int
            default -1 (same number as x)

        Returns
        -------

        tc : TUsignal

        Notes
        -----

        .. math::
            x = \textrm{linspace}(0,\frac{1}{\delta f},N)

        .. math::
            y = [0,\mathbb{X}_u^T]

        &quot;&quot;&quot;
        if Npt == -1:
            Npt = len(self.x)

        Y = self.y
        y = fft.ifft(Y, Npt,axis=-1)
        df = self.dx()
        x = np.linspace(0, 1 / df, Npt)
        tc = TUsignal(x, y)
        return tc</div>

<div class="viewcode-block" id="FUsignal.ift"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.ift">[docs]</a>    def ift(self, Nz=1, ffts=0 ,beta = 0):
        &quot;&quot;&quot; Inverse Fourier Transform - returns the associated TUsignal

        Parameters
        ----------

        Nz   : Number of zeros (-1) No forcing
        ffts : 0 (no fftshift 1:fftshift)
        beta : kaiser window shape 
            0   : rectangular 
            5   : similar to a Hamming
            6   : similar to a Hanning
            8.6 : similar to a blackman

        Returns
        -------

        uh :

        Examples
        --------

        &gt;&gt;&gt; from pylayers.signal.bsignal import *
        &gt;&gt;&gt; e = TUsignal()
        &gt;&gt;&gt; e.EnImpulse()
        &gt;&gt;&gt; E  = e.fft()
        &gt;&gt;&gt; EU = E.unrex()

        Notes
        ------

        1 - Force Hermitian symmetry --&gt; FHsignal with or without zero padding
        2 - Inverse Fourier transform with or without fftshift

        See Also
        --------

        FHsignal.ifft, FUsignal.symH, FUsignal.symHz

        &quot;&quot;&quot;
        # enforce Hermitian Symetry
        if beta == 0 :
            V = FUsignal(self.x,self.y)
        else:
            window = np.kaiser(len(self.x),beta)
            V = FUsignal(self.x,self.y*window[...,:])
        # if (Nz == -1):
        #     UH = self.symH(1)
        # else:
            #UH = self.symHz(Nz,scale=&#39;cir&#39;)
        UH = V.symHz(Nz,scale=&#39;extract&#39;)
        # Back in time
        # UH is an FHsignal
        # uh is a TUsignal
        uh = UH.ifft(ffts)
        return(uh)</div>

<div class="viewcode-block" id="FUsignal.iftshift"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.iftshift">[docs]</a>    def iftshift(self, Nz=1):
        &quot;&quot;&quot; Return the associated TUsignal

        Notes
        -----

        apply the inverse fftshift operator to come back in time

        &quot;&quot;&quot;
        if (Nz == -1):
            UH = self.symH(1)
        else:
            #UH = self.symHz(Nz,scale=&#39;cir&#39;)
            UH = self.symHz(Nz,scale=&#39;extract&#39;)

        uh = UH.ifft(ffts=0)
        #uh.y=fliplr(fftshift(fliplr(uh.y)))
        uh.y = flipud(fftshift(flipud(uh.y)))
        return(uh)</div>

<div class="viewcode-block" id="FUsignal.show"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.show">[docs]</a>    def show(self,**kwargs):
        &quot;&quot;&quot; imshow visualization of Modulus and Phase

        vmin :
        vmax :
        cmap : colormap

        &quot;&quot;&quot;

        if &#39;fig&#39; not in kwargs:
            fig = plt.figure()
        else:
            fig = kwargs[&#39;fig&#39;]
            kwargs.pop(&#39;fig&#39;)

        ax1 = fig.add_subplot(121)
        fig,ax1 = self.imshow(typ=&#39;l20&#39;,fig=fig,ax=ax1,**kwargs)
        ax2 = fig.add_subplot(122)

        if &#39;vmin&#39; in kwargs:
            del kwargs[&#39;vmin&#39;]
        if &#39;vmax&#39; in kwargs:
            del kwargs[&#39;vmax&#39;]

        fig,ax2= self.imshow(typ=&#39;d&#39;,fig=fig,ax=ax2,**kwargs)

        return fig,[ax1,ax2]</div>

<div class="viewcode-block" id="FUsignal.decimate"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.decimate">[docs]</a>    def decimate(self, N=2):
        &quot;&quot;&quot; decimate FUsignal by N
        Parameters
        ----------
        N : int
            decimation factor (default 2)

        &quot;&quot;&quot;
        x = self.x
        y = self.y
        u = np.arange(0, len(x), N)
        xn = x[u]
        if len(np.shape(y)) == 2:
            yn = y[:, u]
        else:
            yn = y[u]

        V = FUsignal(xn, yn)

        return(V)</div>


<div class="viewcode-block" id="FUsignal.tap"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.FUsignal.tap">[docs]</a>    def tap(self,**kwargs):
        r&quot;&quot;&quot; calculates channel taps

        Parameters
        ----------

        fcGHz : float
            center frequency GHz
        WGHz :  float
            bandwidth GHz
        Ntap :  number of taps
        baseband : boolean
            default : True

        Returns
        -------

        htapi


        Notes
        -----

        [Tse] David Tse, http://www.eecs.berkeley.edu/~dtse/Chapters_PDF/Fundamentals_Wireless_Communication_chapter2.pdf page 26

        &quot;&quot;&quot;
        defaults = {&#39;fcGHz&#39;:4.5,
                    &#39;WMHz&#39;:1,
                    &#39;Ntap&#39;:100,
                    &#39;baseband&#39;:True}

        for key, value in defaults.items():
            if key not in kwargs:
                kwargs[key] = value

        fcGHz=kwargs[&#39;fcGHz&#39;]
        WGHz=kwargs[&#39;WMHz&#39;]
        Ntap=kwargs[&#39;Ntap&#39;]
        # yb : tau x f x 1
        if baseband:
            yb = self.y[:,:,np.newaxis]*np.exp(-2 * 1j * np.pi *self.taud[:,np.newaxis,np.newaxis] * fcGHz )
        else:
            yb = self.y[:,:,np.newaxis]
        # l : 1 x 1 x tap
        l  = np.arange(Ntap)[np.newaxis,np.newaxis,:]
        # l : tau x 1 x 1
        tau = self.taud[:,np.newaxis,np.newaxis]
        # S : tau x f x tap (form 2.34 [Tse])
        S   = np.sinc(l-tau*WMHz/1000.)
        # sum over tau : htap : f x tap
        htap = np.sum(yb*S,axis=0)
        # sum over frequency axis : htapi : tap
        # to be considered !! what about the frequency step
        htapi = np.sum(htap,axis=0)

        return htapi</div></div>



<div class="viewcode-block" id="FHsignal"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.FHsignal.html#pylayers.signal.bsignal.FHsignal">[docs]</a>class FHsignal(FUsignal):
    &quot;&quot;&quot;
    FHsignal : Hermitian uniform signal in Frequency domain

    Methods
    -------

    ifft  : inverse Fourier transform --&gt; TUsignal
    unrex : unredundant extraction    --&gt; FUsignal

    &quot;&quot;&quot;
    #def __init__(self, x=np.array([]), y=np.array([]),label=[]):
    #    FUsignal.__init__(self, x, y,label)

    def __repr__(self):
        s = FUsignal.__repr__(self)
        return(s)

    def __mul__(self, u):
        x = self.x
        # rescaling 19/05/2009
        #Df= x[1]-x[0]
        U = FHsignal(x, self.y * u.y)
        return(U)

<div class="viewcode-block" id="FHsignal.ifft"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.FHsignal.html#pylayers.signal.bsignal.FHsignal.ifft">[docs]</a>    def ifft(self, ffts=0, centered=True):
        &quot;&quot;&quot; Inverse Fourier Transform

        Parameters
        ----------

        ffts : int
            0 no fftshift (default)
            1 apply fftshift
        centered:  boolean

        Returns
        -------

        a real TUsignal

        Examples
        --------

        &gt;&gt;&gt; e  = TUsignal()
        &gt;&gt;&gt; e.EnImpulse(feGHz=200)
        &gt;&gt;&gt; E  = e.fft()
        &gt;&gt;&gt; ee = E.ifft()
        &gt;&gt;&gt; assert(abs(sum(e.y-ee.y).all())&lt;1e-13)


        &quot;&quot;&quot;
        Np = len(self.x)
        df = self.x[1] - self.x[0]
        Df = Np * df
        te = 1.0 / Df
        Tww = 1.0 / df
        if centered:
            t = np.linspace(-0.5 * Tww + te / 2, 0.5 *
                            Tww + te / 2, Np, endpoint=False)
        else:
            t = np.linspace(0, Tww, Np, endpoint=False)

        y = fft.ifft(self.y)
        s = TUsignal()
        s.x = t
        if (ffts == 0):
            s.y = np.real(y)
        else:
            nd = np.ndim(y)
            #print &quot;Nombre de dimensions : &quot;,nd
            #print &quot;shape (y)  : &quot;,shape(y)
            if (nd &gt; 1):
                s.y = np.real(fft.fftshift(y, axes=[-1]))
            else:
                s.y = np.real(fft.fftshift(y))

        s.y = s.y * Df
        return(s)</div>

<div class="viewcode-block" id="FHsignal.unrex"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.FHsignal.html#pylayers.signal.bsignal.FHsignal.unrex">[docs]</a>    def unrex(self):
        r&quot;&quot;&quot; extraction of the non redundant part of a real signal
        expressed in the frequency domain

        Examples
        --------

        &gt;&gt;&gt; x = np.arange(0,6,1)
        &gt;&gt;&gt; y = np.arange(0,6,1)
        &gt;&gt;&gt; s = TUsignal(x,y)
        &gt;&gt;&gt; S = s.fft()
        &gt;&gt;&gt; U = S.unrex()

        &quot;&quot;&quot;
        N = len(self.x)
        # even case
        if np.mod(N, 2) == 0:
            xu = self.x[1:int((N + 2) / 2)]
            yu = self.y[...,1:int((N + 2) / 2)]
        # odd case
        else:
            xu = self.x[1:int((N + 1) / 2)]
            yu = self.y[...,1:int((N + 1) / 2)]

        O = FUsignal(x=xu, y=yu)

        return(O)</div></div>

#class RefPulse154(TUsignal):
#       &quot;&quot;&quot;
#       Reference pulse of the IEEE 802.15.4a standard
#       &quot;&quot;&quot;
#   def __init__(self,x=np.array([]),numchanxxfc=4,band=3,thresh=10,fe=20):


<div class="viewcode-block" id="Noise"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Noise">[docs]</a>class Noise(TUsignal):
    &quot;&quot;&quot; Create noise
    &quot;&quot;&quot;
    def __init__(self,
                 ti = 0,
                 tf = 100,
                 fsGHz = 50,
                 PSDdBmpHz = -174,
                 NF = 0,
                 R = 50,
                 seed = 1):
        &quot;&quot;&quot; object constructor

        Parameters
        ----------

        ti        : float
            time start (ns)
        tf        : float
            time stop (ns)
        fsGHZ     : float
            sampling frequency
        PSDdBmpHz : float
            Power Spectral Density Noise (dBm/Hz)
        R         : float
            50 Ohms
        NF        : float
            (Default Value : 0)
        seed      : float

        &quot;&quot;&quot;
        TUsignal.__init__(self)
        self._tsns  = 1./fsGHz
        self._ti = ti
        self._tf = tf
        self._fsGHz = fsGHz
        self._PSDdBmpHz = PSDdBmpHz
        self._NF = NF
        self._R = R
        self._seed=seed
        self.eval()

    @property
    def ti(self):
        return(self._ti)

    @property
    def tf(self):
        return(self._tf)

    @property
    def tsns(self):
        return(self._tsns)

    @property
    def R(self):
        return(self._R)

    @property
    def seed(self):
        return(self._seed)

    @property
    def NF(self):
        return(self._NF)

    @property
    def PSDdBmpHz(self):
        return(self._PSDdBmpHz)

    @property
    def fsGHz(self):
        return(self._fsGHz)

    #-------

    @ti.setter
    def ti(self,ti):
        self._ti = ti
        self.eval()

    @tf.setter
    def tf(self,tf):
        self._tf = tf
        self.eval()

    @tsns.setter
    def tsns(self,tsns):
        self._tsns = tsns
        self._fsGHz = 1./tsns
        self.eval()

    @R.setter
    def R(self,R):
        self._R = R
        self.eval()

    @fsGHz.setter
    def fsGHz(self,fsGHz):
        self._fsGHz=fsGHz
        self._tsns=1./fsGHz
        self.eval()

    @NF.setter
    def NF(self,NF):
        self._NF = NF
        self.eval()

    @seed.setter
    def seed(self,seed):
        self._seed = seed
        np.random.seed(seed)
        self.eval()

    @PSDdBmpHz.setter
    def PSDdBmpHz(self,PSDdBmpHz):
        self._PSDdBmpHz = PSDdBmpHz
        #self.eval()


<div class="viewcode-block" id="Noise.eval"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Noise.eval">[docs]</a>    def eval(self):
        r&quot;&quot;&quot; noise evaluation

        $$N_0 = 4 \times 10^{-21}$$

        &quot;&quot;&quot;
        e  = self._PSDdBmpHz + self._NF
        emJ = 10 ** (e / 10.)  # DSP : dBm/Hz -&gt; mW/Hz
        eJ = emJ / 1e3         # DSP : mw/Hz  -&gt; W/Hz
        self.PW = eJ * (self._fsGHz * 1e9)   # Power : p * Bandwith Hz
        self.vrms = np.sqrt(self._R*self.PW)
        self.x = np.arange(self.ti, self.tf, self.tsns)
        N = len(self.x)
        n = self.vrms * np.random.randn(N)
        self.y   = n
        self.var = np.var(n)
        self.Pr  = self.var/self._R
        self.Er  = self.Pr/(self._fsGHz*1e9)</div>

    def __repr__(self):
        st = &#39;&#39;
        st = st+ &#39;Sampling frequency : &#39;+ str(self.fsGHz)+&#39; GHz\n&#39;
        st = st+ &#39;ti  : %.2f&#39; % self.ti+&#39;ns \n&#39;
        st = st+ &#39;tf  : %.2f&#39; % self.tf+&#39;ns \n&#39;
        st = st+ &#39;ts  : %.2f&#39; % self.tsns+&#39;ns \n&#39;
        st = st+ &#39;N   : %i &#39;  % len(self.x)+&#39;\n&#39;
        st = st + &#39;-------------\n&#39;
        st = st+ &#39;DSP : %.2f&#39; % self.PSDdBmpHz+ &#39; dBm/Hz\n&#39;
        st = st+ &#39;    : %.2e&#39; % 10**(self.PSDdBmpHz/10.)*1e-3+ &#39; Joules\n&#39;
        st = st + &#39;-------------\n&#39;
        st = st+ &#39;Noise Figure : %.2f &#39; % self.NF+ &#39; dB\n&#39;
        st = st+ &#39;Vrms : %.2e&#39; % self.vrms+ &#39; Volts\n&#39;
        st = st+ &#39;Variance :%.2e &#39; % self.var +  &#39; V^2\n&#39;
        st = st+ &#39;Power (dBm) / %.2f&#39; % self.R + &#39; Ohms : &#39;+ str(10*np.log10(self.PW)-60)+ &#39; dBm\n&#39;
        st = st+ &#39;Power realized / %.2f&#39;  % self.R + &#39; Ohms : &#39;+ str(10*np.log10(self.Pr)-60)+ &#39; dBm\n&#39;
        return(st)

<div class="viewcode-block" id="Noise.ppsd"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Noise.ppsd">[docs]</a>    def ppsd(self,mask=True):
        &quot;&quot;&quot; plot Power Spectral Density

        Parameters
        ----------

        mask : boolean
            True
        &quot;&quot;&quot;
        W = TUsignal.psd(self,periodic=False)
        W.plotdB(mask=mask)</div>

<div class="viewcode-block" id="Noise.amplify"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.Noise.html#pylayers.signal.bsignal.Noise.amplify">[docs]</a>    def amplify(self, GdB, NF):
        sel</div>

<div class="viewcode-block" id="Noise.fgating"><a class="viewcode-back" href="../../../api/references.html#pylayers.signal.bsignal.Noise.fgating">[docs]</a>    def fgating(self, fcGHz, WGHz, window=&#39;rect&#39;):
        &quot;&quot;&quot; apply a frequency gating

        Parameters
        ----------

        fcGHz : float
        WGHz  : float
        window : string
            &#39;rect&#39;

        &quot;&quot;&quot;
        N = self.fft()
        if len(self.x) % 2 == 0:
            parity = 0
        else:
            parity = 1
        U = N.unrex()
        f = U.x
        f1 = fcGHz - WGHz / 2.
        f2 = fcGHz + WGHz / 2.
        u = np.nonzero((f &gt; f1) &amp; (f &lt; f2))[0]
        gate = np.zeros(len(f))
        if window==&#39;rect&#39;:
            gate[u] = np.ones(len(u))

        G = FUsignal(f, gate)
        V = G * U
        NF = V.symH(parity)
        nf = NF.ifft()
        return(nf)</div></div>
        #fe = 1./(self.x[1]-self.x[0])
        #fN = fe/2
        #print &quot;fN : &quot;,fN
        #wp = (fcGHz-WGHz/2.)/fN
        #ws = (fcGHz+WGHz/2.)/fN
        #print &quot;fN : &quot;,wp
        #print &quot;fN : &quot;,ws
        #o  = self.iirfilter(order=4,wp=wp,ws=ws)
    #    self.x = o.x
    #    self.y = o.y



<div class="viewcode-block" id="test"><a class="viewcode-back" href="../../../api/pylayers.signal.bsignal.test.html#pylayers.signal.bsignal.test">[docs]</a>def test():
    dx1 = 0.01
    x1 = np.arange(-5, 5, dx1)
    s1 = TUsignal()
    s1 = s1.EnImpulse(x1, fcGHz=4, WGHz=2, feGHz=10)

    S1 = s1.fft()

    is1 = S1.ifft()

    S12 = S1 * S1
    s12 = S12.ifft(1)

# Nouveau signal moins echantillonne

    dx2 = 0.01
    x2 = np.arange(-3, 3, dx2)
    s2 = EnImpulse(x2, 4, 2, 10)
    S2 = s2.fft()

    U1 = S1.unrex()
    U2 = S2.unrex()

    U3 = U1 * U2

    H3 = U3.symH(1)
    # Comparer H3 et S12

    s3 = H3.ifft(1)
    plt.figure()
    plt.subplot(221)
    plt.title(&#39;s1&#39;)
    s1.plot()
    plt.subplot(222)
    s12.plot()
    plt.title(&#39;s12 = s1*s1&#39;)
    plt.subplot(223)
    s2.plot()
    plt.title(&#39;s2&#39;)
    plt.subplot(224)
    s3.plot()
    plt.title(&#39;s3= s1*s2&#39;)

    plt.figure()
    S1.plot()
    plt.title(&#39;S1&#39;)

    plt.figure()
    S12.plot()
    plt.title(&#39;S12 = S1*S1&#39;)

    plt.figure()
    S2.plot()
    plt.title(&#39;S2&#39;)

    plt.figure()
    H3.plot()
    plt.title(&#39;H3 &#39;)

    plt.show()</div>


    ##
#
#

if __name__ == &quot;__main__&quot;:
    pass
    #plt.ion()
    doctest.testmod()
    #ip1 = EnImpulse(fc=4.493,band=0.499,thresh=3,fe=40)
    #ip2 = EnImpulse(fc=4.493,band=0.499,thresh=3,fe=40)
    #ip2.translate(1.123)
    #ip3 = EnImpulse(fc=4.493,band=0.499,thresh=3,fe=40)
    #ip3.translate(2.067)
    #ip4 = EnImpulse(fc=4.493,band=0.499,thresh=3,fe=40)
    #ip4.translate(3.45677)
    #p = ip1+ip2+ip3+ip4
#       ip.zlr(-10,10)
#    s=TUsignal()
#    s.load(&#39;fitest.mat&#39;)
     #tau=s.toa()
     #print tau
#   print &quot;&gt; &quot;
#   print &quot;&gt; generate a normalized energy impulse&quot;
#   print &quot;&gt; &quot;
#   print &quot;i1=EnImpulse()&quot;
#   i1=EnImpulse()
#   print &quot;i1.plot()&quot;
#   i1.plot()
#   print &quot;&gt; &quot;
#   print &quot;&gt; translation of the signal acts only on x base &quot;
#   print &quot;&gt; &quot;
#   figure()
#   i1.translate(3)
#   print&quot;i1.translate(3)&quot;
#   i1.plot()
#   print &quot;&gt; &quot;
#   print &quot;&gt; I1 is the fft of i1 &quot;
#   print &quot;&gt; &quot;
#   I1=i1.fft()
#   print &quot;I1=i1.fft()&quot;
#   print &quot;&gt; &quot;
#   print &quot;&gt; Then we extract the unredundant part of I1 &quot;
#   print &quot;&gt; &quot;
#   U =I1.unrex()
#   print &quot;U =I1.unrex()&quot;
#   V =U.symH(1)
#       show()

#   W =U.symHz(4)

#       x = np.arange(-5,5,0.01)
#       s1 = EnImpulse(x,4,2,10)
#       s1.plot()
#       s2 = EnImpulse(x,5,3,10)
#       s2.translate(5)
#
#       u  = s1.convolve(s2)
#
#       S1 = s1.ft()
#       S2 = s2.ft()
#
#       S1S2  = S1*S2
#       S1S2H = S1S2.symHz(100)
#       s1s2h = S1S2H.ifft(1)
#       v = s1s2h
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team.
      Last updated on Jan 31, 2019.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>