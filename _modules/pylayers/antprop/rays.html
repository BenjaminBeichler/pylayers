

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.antprop.rays &mdash; PyLayers</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_issue314.html">Exemple of issue 314</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction_polar.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html">1&nbsp;&nbsp;&nbsp;pylayers.util.project Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.layout">2&nbsp;&nbsp;&nbsp;pylayers.gis.layout Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.selectl">3&nbsp;&nbsp;&nbsp;pylayers.gis.selectl Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.srtm">4&nbsp;&nbsp;&nbsp;pylayers.gis.srtm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.osmparser">5&nbsp;&nbsp;&nbsp;pylayers.gis.osmparser Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.ezone">6&nbsp;&nbsp;&nbsp;pylayers.gis.ezone Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antenna">7&nbsp;&nbsp;&nbsp;pylayers.antprop.antenna Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.aarray">8&nbsp;&nbsp;&nbsp;pylayers.antprop.aarray Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.spharm">9&nbsp;&nbsp;&nbsp;pylayers.antprop.spharm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antssh">10&nbsp;&nbsp;&nbsp;pylayers.antprop.antssh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antvsh">11&nbsp;&nbsp;&nbsp;pylayers.antprop.antvsh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.slab">12&nbsp;&nbsp;&nbsp;pylayers.antprop.slab Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.signature">13&nbsp;&nbsp;&nbsp;pylayers.antprop.signature Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.interactions">14&nbsp;&nbsp;&nbsp;pylayers.antprop.interactions Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffraction">15&nbsp;&nbsp;&nbsp;pylayers.antprop.diffraction Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffRT">16&nbsp;&nbsp;&nbsp;pylayers.antprop.diffRT Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.rays">17&nbsp;&nbsp;&nbsp;pylayers.antprop.rays Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.loss">18&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.channel">19&nbsp;&nbsp;&nbsp;pylayers.antprop.channel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id39">20&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coverage">21&nbsp;&nbsp;&nbsp;pylayers.antprop.coverage Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coeffModel">22&nbsp;&nbsp;&nbsp;pylayers.antprop.coeffModel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.link">23&nbsp;&nbsp;&nbsp;pylayers.simul.link Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit">24&nbsp;&nbsp;&nbsp;pylayers.simul.exploit Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit_simulnet">25&nbsp;&nbsp;&nbsp;pylayers.simul.exploit_simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simulnet">26&nbsp;&nbsp;&nbsp;pylayers.simul.simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simultraj">27&nbsp;&nbsp;&nbsp;pylayers.simul.simultraj Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.exploit.simnet">28&nbsp;&nbsp;&nbsp;pylayers.exploit.simnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesuwb">29&nbsp;&nbsp;&nbsp;pylayers.measures.mesuwb Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesmimo">30&nbsp;&nbsp;&nbsp;pylayers.measures.mesmimo Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.cormoran">31&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.vna.E5072A">32&nbsp;&nbsp;&nbsp;pylayers.measures.vna.E5072A Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.parker.smparker">33&nbsp;&nbsp;&nbsp;pylayers.measures.parker.smparker Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.bsignal">34&nbsp;&nbsp;&nbsp;pylayers.signal.bsignal Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.standard">35&nbsp;&nbsp;&nbsp;pylayers.signal.standard Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.device">36&nbsp;&nbsp;&nbsp;pylayers.signal.device Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.DF">37&nbsp;&nbsp;&nbsp;pylayers.signal.DF Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.waveform">38&nbsp;&nbsp;&nbsp;pylayers.signal.waveform Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.agent">39&nbsp;&nbsp;&nbsp;pylayers.mobility.agent Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.ban.body">40&nbsp;&nbsp;&nbsp;pylayers.mobility.ban.body Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id138">41&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pylayers.antprop.rays</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.antprop.rays</h1><div class="highlight"><pre>
<span></span># -*- coding: latin1 -*-
from __future__ import print_function
&quot;&quot;&quot;
.. currentmodule:: pylayers.antprop.rays

.. autosummary::
    :members:

&quot;&quot;&quot;
import doctest
import os
import sys
import glob
try:
#    from tvtk.api import tvtk
#    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi import mlab
except:
    print(&#39;Layout:Mayavi is not installed&#39;)
import pdb
import os
import copy
if sys.version_info.major==2:
    import ConfigParser
else:
    import configparser
import glob
import doctest
import networkx as nx
import numpy as np
import scipy as sp
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import struct as stru
import pylayers.util.geomutil as geu
import pylayers.util.pyutil as pyu
from pylayers.util.project import *
from pylayers.antprop.interactions import *
from pylayers.antprop.slab import *
from pylayers.antprop.channel import Ctilde
from pylayers.gis.layout import Layout
import pylayers.signal.bsignal as bs
import shapely.geometry as shg
import h5py
import operator


<div class="viewcode-block" id="Rays"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays">[docs]</a>class Rays(PyLayers, dict):
    &quot;&quot;&quot; Class handling a set of rays

    Attributes
    ----------

    pTx  : np.array
        transmitter (3,)
    pRx  : np.array
        receiver (3,)
    B    : IntB
    B0   : IntB
    I    : Interactions
    I.I  : np.array
        (f,nI,3,3)
    I.T  : IntT
    I.T.A : np.array
        (f,iT,3,3)
    I.R  : IntR
    I.R.A : np.array
        (f,iR,3,3)
    I.D  : IntD
    I.D.A : np.array
        (f,iD,3,3)
    Lfilename : string
        Layout name
    delays : np.array
        ray delays
    dis : np.array
        ray distance = delays*0.3
    nray : int
        number of rays
    evaluated : boolean
        are rays evaluated ?
    is3D : boolean
        are rays 2d or 3d rays ?
    isbased : boolean
        locbas has been applied ?
    filles : boolean
        filled  has been applied ?
    los : boolean
        Line of sight boolean
    fGHz : np.array
        frequency points for evaluation
    origin_sig_name : string
        signature file which produces the rays


    Notes
    -----

    The Rays object is obtained from a signature.
    It is a container for a set of rays between a source
    and a target point defining a radio link.

    Once a Rays object has been obtained in 2D, it is transformed
    in 3D via the **to3D** method. This method takes two parameters :
    the height from floor to ceil, and the number N of
    multiple reflections to account for.

    Once the 3d rays have been calculated,
    the local basis are evaluated along those rays. This is
    done through the **locbas** method

    Once the local basis have been calculated the different
    interactions along rays can be informed via the **fillinter**
    method.

    Once the interactions are informed the field along rays can
    be evaluated via the **eval** method

    &quot;&quot;&quot;
    def __init__(self, pTx, pRx):
        &quot;&quot;&quot; object constructor

        Parameters
        ----------

        pTx : np.array
            transmitter coordinates
        pRx : np.array
            receiver coordinates

        &quot;&quot;&quot;

        self.pTx = pTx
        self.pRx = pRx
        self.nray = 0
        self.nray2D = 0
        self.raypt = 0
        self.los = False
        self.is3D = False
        self.isbased = False
        self.filled = False
        self.evaluated = False

    def __len__(self):
        Nray = 0
        for k in self.keys():
            sh = np.shape(self[k][&#39;sig&#39;])
            Nray = Nray + sh[2]
        return Nray


    # def __add__(self,r):

    #     if (not r.is3D) and (not r.isbased) and (not self.is3D) and (not self.isbased) :
    #         raise AttributeError(&#39;both Ray structures must be 3D and based to be added&#39;)


    #     for ni in r:
    #         if self.has_key(ni):
    #             import ipdb
    #             ipdb.set_trace()
    #             #Â check if som rays already exists
    #             #Â if so, don&#39;t add them
    #             lur = np.array([])
    #             for ur in range(self[ni][&#39;pt&#39;].shape[2]):
    #                 udifferent = np.where(np.all(np.all(r[ni][&#39;pt&#39;][...,ur][...,None]!=self[ni][&#39;pt&#39;],axis=0),axis=0))[0]
    #                 lur = np.hstack((lur,udifferent ))
    #                 import ipdb
    #                 ipdb.set_trace()

    #             self[ni][&#39;pt&#39;] = np.concatenate((self[ni][&#39;pt&#39;],r[ni][&#39;pt&#39;]),axis=2)
    #             self[ni][&#39;sig&#39;] = np.concatenate((self[ni][&#39;sig&#39;],r[ni][&#39;sig&#39;]),axis=2)
    #             self[ni][&#39;si&#39;] = np.concatenate((self[ni][&#39;si&#39;],r[ni][&#39;si&#39;]),axis=1)
    #             self[ni][&#39;rayidx&#39;] = np.concatenate((self[ni][&#39;rayidx&#39;],r[ni][&#39;rayidx&#39;]),axis=0)
    #             self[ni][&#39;dis&#39;] = np.concatenate((self[ni][&#39;dis&#39;],r[ni][&#39;dis&#39;]),axis=0)
    #             self[ni][&#39;vsi&#39;] = np.concatenate((self[ni][&#39;vsi&#39;],r[ni][&#39;vsi&#39;]),axis=1)
    #             self[ni][&#39;nbrays&#39;] += 1
    #             if ni != 0:
    #                 self[ni][&#39;BiN&#39;] = np.concatenate((self[ni][&#39;BiN&#39;],r[ni][&#39;BiN&#39;]),axis=2)
    #                 self[ni][&#39;Bi&#39;] = np.concatenate((self[ni][&#39;Bi&#39;],r[ni][&#39;Bi&#39;]),axis=3)
    #                 self[ni][&#39;Bo&#39;] = np.concatenate((self[ni][&#39;Bo&#39;],r[ni][&#39;Bo&#39;]),axis=3)
    #                 self[ni][&#39;Bo0&#39;] = np.concatenate((self[ni][&#39;Bo0&#39;],r[ni][&#39;Bo0&#39;]),axis=2)
    #                 self[ni][&#39;scpr&#39;] = np.concatenate((self[ni][&#39;scpr&#39;],r[ni][&#39;scpr&#39;]),axis=1)
    #                 self[ni][&#39;norm&#39;] = np.concatenate((self[ni][&#39;norm&#39;],r[ni][&#39;norm&#39;]),axis=2)

    #             self[ni][&#39;B&#39;] = np.concatenate((self[ni][&#39;B&#39;],r[ni][&#39;B&#39;]),axis=3)
    #             self[ni][&#39;aod&#39;] = np.concatenate((self[ni][&#39;aod&#39;],r[ni][&#39;aod&#39;]),axis=1)
    #             self[ni][&#39;aoa&#39;] = np.concatenate((self[ni][&#39;aoa&#39;],r[ni][&#39;aoa&#39;]),axis=1)
    #             self[ni][&#39;theta&#39;] = np.concatenate((self[ni][&#39;theta&#39;],r[ni][&#39;theta&#39;]),axis=1)

    #             if r[ni].has_key(&#39;diffidx&#39;):
    #                 if self[ni].has_key(&#39;diffidx&#39;):
    #                     self[ni][&#39;diffidx&#39;] = np.concatenate((self[ni][&#39;diffidx&#39;],r[ni][&#39;diffidx&#39;]))
    #                     self[ni][&#39;diffvect&#39;] = np.concatenate((self[ni][&#39;diffvect&#39;],r[ni][&#39;diffvect&#39;]),axis=1)
    #                     self[ni][&#39;diffslabs&#39;].append(r[ni][&#39;diffslabs&#39;])
                        
    #                 else:
    #                     self[ni][&#39;diffidx&#39;] = r[&#39;diffidx&#39;]
    #                     self[ni][&#39;diffvect&#39;] = r[&#39;diffvect&#39;]
    #                     self[ni][&#39;diffslabs&#39;] = r[&#39;diffslabs&#39;]

    #         else:
    #             self[ni]=r[ni]






    def __repr__(self):
        s = &#39;&#39;
        ni = 0
        nl = 0
        lgi = list(self.keys())
        lgi.sort()
        if self.is3D:
            s = self.__class__.__name__ + &#39;3D\n&#39; + &#39;----------&#39;+&#39;\n&#39;

            for k in lgi:
                r = self[k][&#39;rayidx&#39;]
                nr = len(r)
                s = s + str(k)+&#39; / &#39;+str(nr)+ &#39; : &#39;+str(r)+&#39;\n&#39;
                ni = ni + nr*k
                nl = nl + nr*(2*k+1)
            nray2D = self.nray2D
        else:
            s = self.__class__.__name__ + &#39;2D\n&#39; + &#39;----------&#39;+&#39;\n&#39;
            nray2D = len(self)

        if self.los:
            s = s + &quot;LOS &quot;
        if self.isbased:
            s = s + &quot;based &quot;
        if self.filled:
            s = s + &quot;filled &quot;

        s = s + &#39;\n&#39;
        s = s + &#39;N2Drays : &#39;+ str(nray2D) + &#39;\n&#39;
        if hasattr(self,&#39;nb_origin_sig&#39;):
            s = s + &#39;from &#39;+ str(self.nb_origin_sig) + &#39; signatures\n&#39;
            s = s + &#39;#Rays/#Sig: &#39;+ str(nray2D/(1.*self.nb_origin_sig) )

        s = s + &#39;\npTx : &#39;+ str(self.pTx) + &#39;\npRx : &#39; + str(self.pRx)+&#39;\n&#39;

        if not self.is3D:
            ray_cpt = 0  
            for k in lgi:
                #sk = np.shape(self[k][&#39;sig&#39;])[2]
                s = s + str(k) + &#39;:\n&#39;
                sig = self[k][&#39;sig&#39;][0,:]
                sha0 = sig.shape[0]
                sha1 = sig.shape[1]
                #pdb.set_trace()
                for l in np.arange(sha1):
                    s = s + &#39;  &#39;+str(ray_cpt)+&#39;:&#39;
                    ray_cpt +=1
                    for n in np.arange(sha0):
                        s = s + &#39;      &#39;+str(sig[n,l])
                    s = s+&#39;\n&#39;
                #pdb.set_trace()
                #s = s + str(sk) + &#39;rays with&#39; + str(k) + &#39; interactions&#39;


        return(s)




<div class="viewcode-block" id="Rays.saveh5"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.saveh5">[docs]</a>    def saveh5(self,idx=0):
        &quot;&quot;&quot; save rays in hdf5 format

        Parameters
        ----------

        idx : int

        See Also
        --------

        loadh5

        &quot;&quot;&quot;

        filename = self.filename+&#39;_&#39;+str(idx)
        filenameh5=pyu.getlong(filename+&#39;.h5&#39;,pstruc[&#39;DIRR3D&#39;])



        # try/except to avoid loosing the h5 file if
        # read/write error
        try:
            f=h5py.File(filenameh5,&#39;w&#39;)
            # keys not saved as attribute of h5py file
            notattr = [&#39;I&#39;,&#39;B&#39;,&#39;B0&#39;,&#39;delays&#39;,&#39;dis&#39;]
            for a in self.__dict__.keys():
                if a not in notattr:
                    f.attrs[a]=getattr(self,a)

            for k in self.keys():
                f.create_group(str(k))
                for kk in self[k].keys():
                    if kk == &#39;sig2d&#39;:
                        # Need to find an efficient way to save the signatures
                        # 2d which have created the rays
                        pass
                    elif kk == &#39;nbrays&#39;:
                        f[str(k)].create_dataset(kk,shape=(1,),data=np.array([self[k][kk]]))
                    else:
                        f[str(k)].create_dataset(kk,shape=np.shape(self[k][kk]),data=self[k][kk])
            f.close()
        except:
            f.close()
            raise NameError(&#39;Rays: issue when writting h5py file&#39;)
        print(filenameh5)</div>


<div class="viewcode-block" id="Rays.loadh5"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.loadh5">[docs]</a>    def loadh5(self,filename=[],idx=0):
        &quot;&quot;&quot; load rays hdf5 format

        Parameters
        ----------

        idx : int 

        &quot;&quot;&quot;
        if filename == []:
            filenameh5 = self.filename+&#39;_&#39;+str(idx)+&#39;.h5&#39;
        else :
            filenameh5 = filename

        filename=pyu.getlong(filenameh5,pstruc[&#39;DIRR3D&#39;])
        print(filename)

        # try/except to avoid loosing the h5 file if
        # read/write error
        try:
            f = h5py.File(filename,&#39;r&#39;)
            for k in f.keys():
                self.update({eval(k):{}})
                for kk in f[k].keys():
                    self[eval(k)].update({kk:f[k][str(kk)][:]})

            for a,va in f.attrs.items():
                setattr(self,a,va)
            f.close()

        except:

            f.close()
            raise NameError(&#39;Rays: issue when reading h5py file&#39;)

        # fill if save was filled
        # temporary solution in order to avoid
        # creating save for Interactions classes

        if self.filled:
            #Lname = self.Lfilename
            Lname = &#39;_&#39;.join(self.filename.split(&#39;_&#39;)[0:-1]) + &#39;.lay&#39;
            #Lname = self.filename.split(&#39;_&#39;)[0] + &#39;.lay&#39;
            L=Layout(Lname)
            self.fillinter(L)

        if self.evaluated:
            return self.val(self.fGHz)</div>

    def _saveh5(self,filenameh5,grpname):
        &quot;&quot;&quot; Save rays h5py format compliant with Links Class

        Parameters
        ----------

        filenameh5 : string
            filename of the h5py file (from Links Class)
        grpname : string
            groupname of the h5py file (from Links Class)

        See Also
        --------

        pylayers.simul.links

        &quot;&quot;&quot;

        filenameh5=pyu.getlong(filenameh5,pstruc[&#39;DIRLNK&#39;])
        # try/except to avoid loosing the h5 file if
        # read/write error
        #try:

        fh5=h5py.File(filenameh5,&#39;a&#39;)
        if self.is3D:
            if not grpname in fh5[&#39;ray&#39;].keys():
                fh5[&#39;ray&#39;].create_group(grpname)
            else :
                print(&#39;ray/&#39;+grpname +&#39;already exists in &#39;+filenameh5)
            f = fh5[&#39;ray/&#39;+grpname]


        else:
            if not grpname in fh5[&#39;ray2&#39;].keys():
                fh5[&#39;ray2&#39;].create_group(grpname)
            else :
                print(&#39;ray2/&#39;+grpname +&#39;already exists in &#39;+filenameh5)
            f = fh5[&#39;ray2/&#39;+grpname]
        # keys not saved as attribute of h5py file
        notattr = [&#39;I&#39;,&#39;B&#39;,&#39;B0&#39;,&#39;dis&#39;]
        for a in self.__dict__.keys():
            if a not in notattr:
                if type(a)==str:
                    a.encode(&#39;utf-8&#39;)
                    if a==&#39;_luw&#39;:
                        la = [ x.encode(&#39;utf8&#39;) for x in getattr(self,a) ] 
                        f.attrs[a] = la
                    else:
                        f.attrs[a] = getattr(self,a)

        for k in self.keys():
            f.create_group(str(k))
            for kk in self[k].keys():
                if kk == &#39;sig2d&#39;:
                    # Need to find an efficient way to save the signatures
                    # 2d which have created the rays
                    pass
                elif kk == &#39;nbrays&#39;:
                    f[str(k)].create_dataset(kk,shape=(1,),data=np.array([self[k][kk]]))
                else:
                    if kk==&#39;diffslabs&#39;:
                        ldiffslabs = [ x.encode(&#39;utf8&#39;) for x in self[k][kk] ]
                        f[str(k)].create_dataset(kk,shape=np.shape(self[k][kk]),data=ldiffslabs)
                    else:
                        f[str(k)].create_dataset(kk,shape=np.shape(self[k][kk]),data=self[k][kk])
        fh5.close()
        #except:
        #    fh5.close()
        #    raise NameError(&#39;Rays: issue when writting h5py file&#39;)

    def _loadh5(self,filenameh5,grpname,**kwargs):
        &quot;&quot;&quot; load rays  h5py format compliant with Links Class

        Parameters
        ----------

        filenameh5 : string
            filename of the h5py file (from Links Class)
        grpname : string
            groupname of the h5py file (from Links Class)
        kwargs may contain a L: layout object
            if L =  [] the layout is loaded from the layout name stored
            into the h5 file
            if L = Layout the layout passed in arg is used

        See Also
        --------

        pylayers.simul.links

        &quot;&quot;&quot;


        filename=pyu.getlong(filenameh5,pstruc[&#39;DIRLNK&#39;])
        # try/except to avoid loosing the h5 file if
        # read/write error
        try:
            fh5=h5py.File(filename,&#39;r&#39;)

            if self.is3D:
                argfile = &#39;ray/&#39;+grpname
            else:
                argfile = &#39;ray2/&#39;+grpname

            f = fh5[argfile]

            for k in f.keys():
                self.update({eval(k):{}})
                for kk in f[k].keys():
                    self[eval(k)].update({kk:f[k][str(kk)][:]})

            for a,va in f.attrs.items():
                setattr(self,a,va)


            fh5.close()

        except:

            fh5.close()
            raise NameError(&#39;Rays: issue when reading h5py file&#39;)

        # fill if save was filled
        # temporary solution in order to avoid
        # creating save for Interactions classes

        if self.filled:
            if &#39;L&#39; in kwargs:
                self.L=kwargs[&#39;L&#39;]
            else:
                self.L = Layout(self.Lfilename,bbuild=True)
                try:
                    self.L.dumpr()
                except:
                    self.L.build()
                    self.L.dumpw()
            # L=Layout(self.Lfilename,bbuild=True)
            self.fillinter(self.L)

        # if self.evaluated:
        #     return self.eval(self.fGHz)


<div class="viewcode-block" id="Rays.reciprocal"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.reciprocal">[docs]</a>    def reciprocal(self):
        &quot;&quot;&quot; switch tx and rx

        &quot;&quot;&quot;

        r = Rays(self.pRx,self.pTx)
        r.is3D = self.is3D
        r.nray = self.nray
        r.origin_sig_name = self.origin_sig_name
        r.nb_origin_sig = self.nb_origin_sig

        for k in self:
            r[k]={}
            r[k][&#39;pt&#39;]=self[k][&#39;pt&#39;][:,::-1,:]
            r[k][&#39;sig&#39;]=self[k][&#39;sig&#39;][:,::-1,:]
        return(r)</div>


<div class="viewcode-block" id="Rays.check_reciprocity"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.check_reciprocity">[docs]</a>    def check_reciprocity(self,r):
        &quot;&quot;&quot; check ray reciprocity in comparing two reciprocal rays

        Parameters
        ----------

        r : rays reciprocal to self


        &quot;&quot;&quot;
        # permutation of all termination points
        assert (self.pTx==r.pRx).all()
        assert (self.pRx==r.pTx).all()
        # for all group of interctions
        for k in self:
            # same distances
            assert (np.allclose(self[k][&#39;dis&#39;],r[k][&#39;dis&#39;]))
            # same points when reading from right to left
            assert (np.allclose(self[k][&#39;pt&#39;],r[k][&#39;pt&#39;][:,::-1,:]))
            # same signature reading from right to left
            assert (np.allclose(self[k][&#39;sig&#39;],r[k][&#39;sig&#39;][:,::-1,:]))
            # if local basis have been evaluated
            if (self.isbased) &amp; (r.isbased):
                #assert (np.allclose(self[k][&#39;nstrwall&#39;],r[k][&#39;nstrwall&#39;][:,::-1,:]))
                assert (np.allclose(self[k][&#39;norm&#39;],r[k][&#39;norm&#39;][:,::-1,:])), &#39;interaction block:&#39; + str(k)
                #assert ((np.mod(self[k][&#39;aoa&#39;]-r[k][&#39;aod&#39;],2*np.pi)==0).all())
                #assert ((np.mod(self[k][&#39;aod&#39;]-r[k][&#39;aoa&#39;],2*np.pi)==0).all())
                # 1st output basis is equal to last input basis of the reciprocal ray
                assert (np.allclose(self[k][&#39;Bo0&#39;],r[k][&#39;BiN&#39;])), &#39;interaction block:&#39; + str(k)
                # last input basis is equal to 1st output basis of the reciprocal ray
                assert (np.allclose(self[k][&#39;BiN&#39;],r[k][&#39;Bo0&#39;])), &#39;interaction block:&#39; + str(k)
                # vsi vectors are inversed
                assert (np.allclose(self[k][&#39;vsi&#39;],-r[k][&#39;vsi&#39;][:,::-1,:])), &#39;interaction block:&#39; + str(k)
                assert (np.allclose(abs(self[k][&#39;scpr&#39;]),abs(r[k][&#39;scpr&#39;][::-1,:]))), &#39;interaction block:&#39; + str(k)
                assert (np.allclose(self[k][&#39;theta&#39;],r[k][&#39;theta&#39;][::-1,:])), &#39;interaction block:&#39; + str(k)
                assert (np.allclose(self[k][&#39;Bi&#39;],r[k][&#39;Bo&#39;][:,:,::-1,:])), &#39;interaction block:&#39; + str(k)
                assert (np.allclose(self[k][&#39;Bo&#39;],r[k][&#39;Bi&#39;][:,:,::-1,:])), &#39;interaction block:&#39; + str(k)
                assert (np.allclose(self[k][&#39;B&#39;],r[k][&#39;B&#39;][:,:,::-1,:].swapaxes(0,1))), &#39;interaction block:&#39; + str(k)

        if self.evaluated :

            for ir in range(self.nray):

                iint1 = self.ray(ir)
                iint2 = r.ray(ir)

                # check Interactions
                A1 = self.I.I[:, iint1, :, :]
                A2 = r.I.I[:, iint2, :, :][:,::-1,:,:]
                assert np.allclose(A1,A2),pdb.set_trace()

                # check bases
                #  ray 1 : B0   | B[0]   | B[1] | B[2] | B[3] | B[4]
                #  ray 2 : B[4] | B[3]  | B[2]  | B[1] | B[0] | B0
                assert np.allclose(self.B0.data[ir,:,:],r.B.data[iint2,:,:][-1,:,:].swapaxes(1,0))
                assert np.allclose(r.B0.data[ir,:,:],self.B.data[iint1,:,:][-1,:,:].swapaxes(1,0))
                assert np.allclose(self.B.data[iint1,:,:][:-1],r.B.data[iint2,:,:][:-1][::-1,:,:].swapaxes(2,1))</div>



<div class="viewcode-block" id="Rays.sort"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.sort">[docs]</a>    def sort(self):
        &quot;&quot;&quot; sort rays
        
        TODO : not finished 

        &quot;&quot;&quot;
        u = np.argsort(self.dis)</div>


<div class="viewcode-block" id="Rays.rayfromtyp_order"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.rayfromtyp_order">[docs]</a>    def rayfromtyp_order(self,nD=[1],nR=[1],nT=[1],llo=&#39;&amp;&amp;&#39;):
        &quot;&quot;&quot;
            Return rays from a given type (R|T|D) to a given order
            ( number of interaction)

            list logic operator : llo [&#39;op0op1&#39;] 

            nD &lt;op0&gt; nR &lt;op1&gt; nT


            Parameters
            ----------

                nD = list|int
                    requested number of Diffraction
                nR = list|int
                    requested number of Reflection
                nT = list|int
                    requested number of Transmission
                llo = list logic operator [op0,op1]
                    nD &lt;op0&gt; nR &lt;op1&gt; nT


            Returns
            -------

                lr : list
                    list of ray index matching the typ &amp; order conditions



        &quot;&quot;&quot;

        if not isinstance(nD,list):
            nD=[nD]
        if not isinstance(nR,list):
            nR=[nR]
        if not isinstance(nT,list):
            nT=[nT]

        op = {&#39;and&#39;:operator.and_,
              &#39;or&#39;:operator.or_,
              &#39;&amp;&#39;:operator.and_,
              &#39;|&#39;:operator.or_,
              }


        lr=[]
        for ur,r in enumerate(range(self.nray)):
            li = self.ray2ityp(r)
            nRli = li.count(&#39;R&#39;)
            nTli = li.count(&#39;T&#39;)
            nDli = li.count(&#39;D&#39;)



            cD = (nDli in nD)
            cR = (nRli in nR)
            cT = (nTli in nT)

            # if (nDli in nD) and (nRli in nR) and (nTli in nT) :
            if op[llo[1].lower()]( op[llo[0].lower()](cD,cR) , cT):
                lr.append(r)
            elif (self.los) and (1 in nT ) and (0 in nD) and (0 in nR) and (ur == 0):
                lr.append(r)
        return lr</div>


<div class="viewcode-block" id="Rays.extract_typ_order"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.extract_typ_order">[docs]</a>    def extract_typ_order(self,L,nD=[1],nR=[1],nT=[1],llo=&#39;&amp;&amp;&#39;):
        &quot;&quot;&quot; Extract group of rays from a certain type (R|T|D) 
            at a order ( &lt;=&gt; given number of interaction)

            list logic operator : llo [op0,op1]

            nD &lt;op0&gt; nR &lt;op1&gt; nT


        Parameters
            ----------

        L  : Layout
        nD = list|int
            requested number of Diffraction
        nR = list|int
            requested number of Reflection
        nT = list|int
            requested number of Transmission
        llo = list logic operator [op0,op1]
            nD &lt;op0&gt; nR &lt;op1&gt; nT

        Returns
        -------

        R : Rays object
            New Rays object containing rays matching 
            the typ/order conditions 


        &quot;&quot;&quot;

        lr = self.rayfromtyp_order(nD=nD,nR=nR,nT=nT,llo=llo)
        return self.extract(lr,L)</div>


<div class="viewcode-block" id="Rays.extract"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.extract">[docs]</a>    def extract(self,lnr,L):
        &quot;&quot;&quot; Extract a group of rays

        Parameters
        ----------

        lnr : list of rays indexes
        L  : Layout

        &quot;&quot;&quot;


        if not isinstance(lnr,list):
            lnr=[lnr]

        r = Rays(self.pTx,self.pRx)
        r.is3D = self.is3D

        for unr,nr in enumerate(lnr):
            #r.nray2D = 
            #r.nb_origin_sig = 1

            ni = self.ray2nbi(nr)
            ur = np.where(self[ni][&#39;rayidx&#39;]==nr)[0][0]




            if ni == 0:
                los = True
            else:
                los = False

            if &#39;D&#39; in self.typ(nr):
                diff=True
            else:
                diff=False


            if &#39;diffvect&#39; in self[ni]:
                # check if the ray has diffraction interaction
                inter = self.ray2iidx(nr)[:,0]
                uD = np.where([i in inter for i in self[ni][&#39;diffidx&#39;]])[0]
            else:
                uD=[]

            diffkey = [&#39;diffvect&#39;,&#39;diffidx&#39;,&#39;diffslabs&#39;]

            cray = {}


            for k in self[ni].keys():

                if ni ==0:

                    cray = self[ni]
                    break

                elif k not in [&#39;nbrays&#39;,&#39;rayidx&#39;,&#39;dis&#39;,&#39;nstrwall&#39;,&#39;nstrswall&#39;]:
                    tab  = self[ni][k]
                    if type(tab)==np.ndarray and k not in diffkey:
                            try:
                                cray[k] = tab[...,ur][...,np.newaxis]
                            except:
                                import ipdb
                                ipdb.set_trace()
                    if diff : 
                        if k in diffkey :
                            if k != &#39;diffslabs&#39;:
                                cray[k]=tab[...,uD][...,np.newaxis]
                            else:
                                if len(uD)&gt;0 :
                                    cray[k]=[tab[uD]]
                                else:
                                    cray[k]=[]


            cray[&#39;nbrays&#39;] = unr+1 # keep only one ray
            r.nray = unr+1
            #cray[&#39;rayidx&#39;]=np.array([self[ni][&#39;rayidx&#39;][nr]]) # ray index in the whole structure
            cray[&#39;rayidx&#39;] = np.array([unr])
            cray[&#39;dis&#39;] = np.array([self[ni][&#39;dis&#39;][ur]])


            if ni in r:

                # R[ni][&#39;sig2d&#39;].append(self[k][&#39;sig2d&#39;][ur])

                if not los :
                    r[ni][&#39;BiN&#39;] = np.concatenate((r[ni][&#39;BiN&#39;],cray[&#39;BiN&#39;]),axis=2)
                    r[ni][&#39;Bo&#39;] = np.concatenate((r[ni][&#39;Bo&#39;],cray[&#39;Bo&#39;]),axis=3)
                    r[ni][&#39;Bi&#39;] = np.concatenate((r[ni][&#39;Bi&#39;],cray[&#39;Bi&#39;]),axis=3)


                if diff:
                    if &#39;diffidx&#39; in r[ni]:
                        r[ni][&#39;diffidx&#39;] = np.concatenate((r[ni][&#39;diffidx&#39;],cray[&#39;diffidx&#39;]))
                        r[ni][&#39;diffvect&#39;] = np.concatenate((r[ni][&#39;diffvect&#39;],cray[&#39;diffvect&#39;]),axis=1)
                        r[ni][&#39;diffslabs&#39;].append(cray[&#39;diffslabs&#39;])

                    else:
                        r[ni][&#39;diffidx&#39;] = cray[&#39;diffidx&#39;]
                        r[ni][&#39;diffvect&#39;] = cray[&#39;diffvect&#39;]
                        r[ni][&#39;diffslabs&#39;] = cray[&#39;diffslabs&#39;]

                r[ni][&#39;nbrays&#39;] += 1
                r[ni][&#39;B&#39;] = np.concatenate((r[ni][&#39;B&#39;], cray[&#39;B&#39;]), axis=3)

                r[ni][&#39;pt&#39;] = np.concatenate((r[ni][&#39;pt&#39;], cray[&#39;pt&#39;]), axis=2)
                r[ni][&#39;rayidx&#39;] = np.concatenate((r[ni][&#39;rayidx&#39;], cray[&#39;rayidx&#39;]), axis=0)
                r[ni][&#39;Bo0&#39;] = np.concatenate((r[ni][&#39;Bo0&#39;],cray[&#39;Bo0&#39;]), axis=2)

                r[ni][&#39;scpr&#39;] = np.concatenate((r[ni][&#39;scpr&#39;], cray[&#39;scpr&#39;]), axis=1)
                r[ni][&#39;aod&#39;] = np.concatenate((r[ni][&#39;aod&#39;], cray[&#39;aod&#39;]), axis=1)
                r[ni][&#39;si&#39;] = np.concatenate((r[ni][&#39;si&#39;], cray[&#39;si&#39;]), axis=1)
                r[ni][&#39;sig&#39;] = np.concatenate((r[ni][&#39;sig&#39;], cray[&#39;sig&#39;]), axis=2)
                # r[ni][&#39;sig2d&#39;] = np.concatenate((r[ni][&#39;sig2d&#39;],cray[&#39;sig2d&#39;]),axis=2)
                r[ni][&#39;aoa&#39;] = np.concatenate((r[ni][&#39;aoa&#39;], cray[&#39;aoa&#39;]), axis=1)
                r[ni][&#39;vsi&#39;] = np.concatenate((r[ni][&#39;vsi&#39;], cray[&#39;vsi&#39;]), axis=2)
                r[ni][&#39;theta&#39;] = np.concatenate((r[ni][&#39;theta&#39;], cray[&#39;theta&#39;]), axis=1)
                r[ni][&#39;norm&#39;] = np.concatenate((r[ni][&#39;norm&#39;], cray[&#39;norm&#39;]), axis=2)
                r[ni][&#39;dis&#39;] = np.concatenate((r[ni][&#39;dis&#39;], cray[&#39;dis&#39;]), axis=0)

            else:
                r[ni] = cray

        # r[ni][&#39;rays&#39;] = to be done HERE


        r.locbas(L)
        r.fillinter(L)
        return(r)</div>

<div class="viewcode-block" id="Rays.extract_old"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.extract_old">[docs]</a>    def extract_old(self,nr,L):
        &quot;&quot;&quot; Extract a single ray

        Parameters
        ----------

        nr : ray index
        L  : Layout

        &quot;&quot;&quot;

        r = Rays(self.pTx,self.pRx)
        r.is3D = self.is3D

        r.nray2D = 1
        r.nb_origin_sig = 1

        #ni = self._ray2nbi[nr]
        #ur = np.where(self[ni][&#39;rayidx&#39;]==nr)[0][0]

        ni,ur = self.ir2a(nr)

        if &#39;D&#39; in self.typ(nr):
            diff=True
        else:
            diff=False

        if &#39;diffvect&#39; in self[ni]:
            # check if the ray has diffraction interaction
            inter = self.ray2iidx(nr)[:,0]
            uD = np.where([i in inter for i in self[ni][&#39;diffidx&#39;]])[0]
        else:
            uD=[]

        diffkey = [&#39;diffvect&#39;,&#39;diffidx&#39;,&#39;diffslabs&#39;]

        r[ni] = {}
        for k in self[ni].keys():
            if k not in [&#39;nbrays&#39;,&#39;rayidx&#39;,&#39;dis&#39;,&#39;nstrwall&#39;,&#39;nstrswall&#39;]:
                tab  = self[ni][k]
                if type(tab)==np.ndarray and k not in diffkey:
                        r[ni][k] = tab[...,ur][...,np.newaxis]
                if diff : 
                    if k in diffkey :
                        if k != &#39;diffslabs&#39;:
                            r[ni][k]=tab[...,uD][...,np.newaxis]
                        else:
                            if len(uD)&gt;0 :
                                r[ni][k]=tab[uD]
                            else:
                                r[ni][k]=[]

        r[ni][&#39;nrays&#39;] = 1 # keep only one ray
        r.nray = 1
        #r[ni][&#39;rayidx&#39;]=np.array([self[ni][&#39;rayidx&#39;][nr]]) # ray index in the whole structure
        r[ni][&#39;rayidx&#39;] = np.array([0])
        r[ni][&#39;dis&#39;] = np.array([self[ni][&#39;dis&#39;][ur]])
        r.locbas(L)
        r.fillinter(L)
        return(r)</div>



<div class="viewcode-block" id="Rays.show"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.show">[docs]</a>    def show(self,**kwargs):
        &quot;&quot;&quot;  plot 2D rays within the simulated environment

        Parameters
        ----------

        rlist : list  (default []= all rays)
            list of indices of ray in interaction group
        graph : string t
            type of graph to be displayed
            &#39;s&#39;,&#39;r&#39;,&#39;t&#39;,..
        fig : figure
        ax  : axis
        L   : Layout
        alpha : float
            1
        linewidth : float
            0.1
        color : string
            &#39;black&#39;
        ms : int
            marker size :  5
        layout : boolean
            True
        points : boolean
            True
        ER : ray energy

        &quot;&quot;&quot;
        defaults = {&#39;rlist&#39;: [],
                    &#39;fig&#39;: [],
                    &#39;ax&#39;: [],
                    &#39;L&#39;: [],
                    &#39;graph&#39;: &#39;s&#39;,
                    &#39;color&#39;: &#39;black&#39;,
                    &#39;alpha&#39;: 1,
                    &#39;linewidth&#39;: 0.5,
                    &#39;ms&#39;: 5,
                    &#39;vmin&#39;:0,
                    &#39;vmax&#39;:-70,
                    &#39;cmap&#39;: plt.cm.hot_r,
                    &#39;layout&#39;: True,
                    &#39;points&#39;: True,
                    &#39;labels&#39;: False,
                    &#39;bcolorbar&#39;: False
                   }

        for key, value in defaults.items():
            if key not in kwargs:
                kwargs[key] = value

        if kwargs[&#39;fig&#39;] ==[]:
            fig = plt.figure()

        if kwargs[&#39;ax&#39;] ==[]:
            ax = fig.add_subplot(111)

        #
        # display the Layout
        #
        if kwargs[&#39;layout&#39;] == True:
            if kwargs[&#39;L&#39;] != []:
                fig,ax = kwargs[&#39;L&#39;].showG(**kwargs)
            else :
                raise AttributeError(&#39;Please give a Layout file as argument&#39;)
        else:
            fig = kwargs[&#39;fig&#39;]
            ax = kwargs[&#39;ax&#39;]
        #
        # display Tx and Rx
        #
        if kwargs[&#39;points&#39;] ==True:
            ax.plot(self.pTx[0], self.pTx[1], &#39;or&#39;,ms=kwargs[&#39;ms&#39;])
            ax.plot(self.pRx[0], self.pRx[1], &#39;og&#39;,ms=kwargs[&#39;ms&#39;])
        # i=-1 all rays
        # else block of interactions i
        # plot all rays
        if kwargs[&#39;rlist&#39;] == []:

            # list of group of interactions
            lgrint = self.keys()

            for i in lgrint:
                # list of rays
                lray = range(len(self[i][&#39;pt&#39;][0, 0, :]))

                #if self.filled :
                #    ax.set_title(&#39;rays index :&#39;+ str(self[i][&#39;rayidx&#39;]))

                for j in lray:

                    addr_ray = (i,j)
                    index_ray = self.a2ir(addr_ray)

                    ray = np.hstack((self.pTx[0:2].reshape((2, 1)),
                                     np.hstack((self[i][&#39;pt&#39;][0:2, :, j],
                                     self.pRx[0:2].reshape((2, 1))))
                                     ))

                    if &#39;ER&#39; not in kwargs:
                        ax.plot(ray[0, :], ray[1, :],
                            alpha = kwargs[&#39;alpha&#39;],
                            color = kwargs[&#39;color&#39;],
                            linewidth = kwargs[&#39;linewidth&#39;])
                    else:
                        EdB = 10*np.log10(ER[index_ray])
                        ERdB = 10*np.log10(E)
                        vscale  = 1.-(max(ERdB)-EdB)/(max(ERdB)-min(ERdB))
                        linewidth = 3*vscale
                        alpha = vscale
                        cmap = cm.hot
                        color = cmap(vscale)
                        ax.plot(ray[0, :], ray[1, :],
                                alpha = alpha,
                                color = color,
                                linewidth = linewidth)

                    ax.axis(&#39;off&#39;)
                    #if self.filled :
                    #    ax.set_title(&#39;rays index :&#39;+ str(self[i][&#39;rayidx&#39;][lray]))
        else:
            rlist = kwargs[&#39;rlist&#39;]
            # 3D ray
            if self.is3D:
                nbi = self._ray2nbi[rlist]
                nr = np.array((nbi,rlist))
                unb = np.unique(nr[0,:])
                unr = {int(i):np.where(nr[0,:]==i)[0] for i in unb}

                for i in unb:
                    raynb = (nr[1,unr[i]]).astype(int)
                    nbr = len(raynb)
                    ptidx = [np.where(self[i][&#39;rayidx&#39;]==x)[0][0] for x in raynb]
                    for j in ptidx:

                        ray = np.hstack((self.pTx[0:2].reshape((2, 1)),
                                         np.hstack((self[i][&#39;pt&#39;][0:2, :, j],
                                         self.pRx[0:2].reshape((2, 1))))
                                         ))
                        ax.plot(ray[0, :], ray[1, :],
                                alpha = kwargs[&#39;alpha&#39;],
                                color = kwargs[&#39;color&#39;],
                                linewidth = kwargs[&#39;linewidth&#39;])
                        ax.axis(&#39;off&#39;)
            # 2D ray
            else:
                for i in rlist:
                    lray = range(len(self[i][&#39;pt&#39;][0, 0, :]))
                    #if self.filled :
                    #    ax.set_title(&#39;rays index :&#39;+ str(self[i][&#39;rayidx&#39;]))
                    for j in lray:
                        ray = np.hstack((self.pTx[0:2].reshape((2, 1)),
                                         np.hstack((self[i][&#39;pt&#39;][0:2, :, j],
                                         self.pRx[0:2].reshape((2, 1))))
                                         ))
                        ax.plot(ray[0, :], ray[1, :],
                                alpha=kwargs[&#39;alpha&#39;],
                                color=kwargs[&#39;color&#39;],
                                linewidth=kwargs[&#39;linewidth&#39;])
                        ax.axis(&#39;off&#39;)

        if kwargs[&#39;bcolorbar&#39;]:
            # axes : left , bottom , width , height
            sm = plt.cm.ScalarMappable(cmap = kwargs[&#39;cmap&#39;], norm = plt.Normalize(vmin=kwargs[&#39;vmin&#39;],vmax=kwargs[&#39;vmax&#39;]))
            sm._A = []  #Â necessary set_array
            cax = fig.add_axes([0.18,0.35, 0.35, 0.025])
            #cb = plt.colorbar(sm,cax=cax,orientation=&#39;horizontal&#39;)
            cb = plt.colorbar(sm,cax=cax,orientation=&#39;horizontal&#39;)
            cb.ax.tick_params(labelsize=24)
            cb.set_label(&#39;Level (dB)&#39;, fontsize=24)

        return(fig,ax)</div>

<div class="viewcode-block" id="Rays.mirror"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.mirror">[docs]</a>    def mirror(self, H=3, N=1, za = [], zb= []):
        &quot;&quot;&quot; mirror a ray termination

        Parameters
        ----------

        H : float
            ceil height (default 3m)
            if H=0 only floor reflection is calculated (outdoor case)
            if H=-1 floor and ceil reflection are inhibited (2D test case)
        N : int
            handle the number of mirror reflexions

        za : float
            height of the point where the parametrization starts ( e.g. pTx[2])

        zb : float
            height of the point where the parametrization ends ( e.g. pRx[2])


        Returns
        -------

        d : dict
            k : zm  v: alpham
            k : zp  v: alphap

        Examples
        --------

        &gt;&gt;&gt; ptx = np.array([1,1,1.5])
        &gt;&gt;&gt; prx = np.array([2,2,1.2])
        &gt;&gt;&gt; r = Rays(ptx,prx)
        &gt;&gt;&gt; d = r.mirror()
        &gt;&gt;&gt; d[-1.5]
        array([ 0.55555556])

        Notes
        -----

        d is a dictionnary whose keys are heights along the vertical from where
        are emanating the reflected rays. Values of d are the parameterization
        (0&lt; () &lt;1) along the ray where are situated the different reflection
        points.


        &quot;&quot;&quot;



        km = np.arange(-N+1, N+1, 1)
        kp = np.arange(-N, N+1, 1)
        #
        # heights of transmitter and receiver
        #
        if za == []:
            za=self.pTx[2]
        if zb == []:
            zb=self.pRx[2]
        ht = za
        hr = zb

        assert (hr&lt;H or H==0 or H == -1),&quot;mirror : receiver higher than ceil height&quot;
        assert (ht&lt;H or H==0 or H == -1),&quot;mirror : transmitter higher than ceil height&quot;

        zkp = 2*kp*H + ht
        zkm = 2*km*H - ht

        d = {}
        if H&gt;0:
            for zm in zkm:
                if zm &lt; 0:
                    bup = H
                    pas = H
                    km = int(np.ceil(zm/H))
                else:
                    bup = 0
                    pas = -H
                    km = int(np.floor(zm/H))
                thrm = np.arange(km*H, bup, pas)
                d[zm] = abs(thrm-zm)/abs(hr-zm)

            for zp in zkp:
                if zp &lt; 0:
                    bup = H
                    pas = H
                    kp = int(np.ceil(zp/H))
                else:
                    bup = 0
                    pas = -H
                    kp = int(np.floor(zp/H))
                thrp = np.arange(kp*H, bup, pas)
                d[zp] = abs(thrp-zp)/abs(hr-zp)
        elif H==0:
            d[-ht] = np.array([ht/(ht+hr)])
            d[ht] = np.array([])
        elif H==-1:
            d[ht] = np.array([])
            # print &quot;zp&quot;,zp
            # print &quot;kp&quot;,kp
            # print &quot;thrp&quot;,thrp
            # print &quot;alphap&quot;,d[zp]

        return d</div>

<div class="viewcode-block" id="Rays.to3D"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.to3D">[docs]</a>    def to3D(self, L, H=3, N=1, rmoutceilR=True):
        &quot;&quot;&quot; transform 2D ray to 3D ray

        Parameters
        ----------

        L : Layout object

        H : float
            ceil height (default 3m)
            if H= 0 only floor reflection is calculated (outdoor case)
            if H=-1 floor and ceil reflection are inhibited (2D test case)
        N : int
            number of mirror reflexions
        rmoutceilR : bool
            Remove ceil reflexions in cycles (Gt nodes)
            with indoor=False attribute

        Returns
        -------

        r3d : Rays

        See Also
        --------

        mirror

        &quot;&quot;&quot;

        if H==-1:
            rmoutceilR=False

        tx = self.pTx
        rx = self.pRx

        #
        # Phase 1 : calculate Tx images height and parameterization in the
        # vertical plane
        #

        d = self.mirror(H=H, N=N, za=tx[2], zb=rx[2])

        #
        # Elimination of invalid diffraction point 
        # If the diffaction point is a separation between 2 air wall 
        # it should be removed.


        #
        # Phase 2 : calculate 2D parameterization in the horizontal plane
        #

        # for all group of interactions
        for i in self:

            pts = self[i][&#39;pt&#39;][0:2, :, :]
            sig = self[i][&#39;sig&#39;]

            if pts.shape[2]!=0:
                # broadcasting of t and r
                t = self.pTx[0:2].reshape((2, 1, 1)) * \
                np.ones((1, 1, len(pts[0, 0, :])))
                r = self.pRx[0:2].reshape((2, 1, 1)) * \
                np.ones((1, 1, len(pts[0, 0, :])))
                pts1 = np.hstack((t, np.hstack((pts, r))))
            else:
                t = self.pTx[0:2].reshape((2, 1, 1))
                r = self.pRx[0:2].reshape((2, 1, 1))
                pts1 = np.hstack((t,r))
            # append t and r to interaction points in 2D


            si1 = pts1[:, 1:, :] - pts1[:, :-1, :]
            # array of all ray segments distances
            si = np.sqrt(np.sum(si1 * si1, axis=0))
            # array of cumulative distance of 2D ray
            al1 = np.cumsum(si, axis=0)

            # initialize parameterization parameter alpha
            self[i][&#39;alpha&#39;] = np.zeros(np.shape(si[:-1, :]))

            for j in range(len(self[i][&#39;alpha&#39;][:, 0])):
                # get alpha
                self[i][&#39;alpha&#39;][j, :] = np.sum(si[0:j+1, :], axis=0) \
                        /np.sum(si, axis=0)
                # get z coordinate
                self[i][&#39;pt&#39;][2, j, :] = tx[2] + self[i][&#39;alpha&#39;][j, :] \
                    * (rx[2] - tx[2])

        #
        #  Phase 3 : Initialize 3D rays dictionnary
        #
        r3d = Rays(tx, rx)
        r3d.los = self.los
        r3d.is3D = True
        r3d.nray2D = len(self)
        r3d.nb_origin_sig = self.nb_origin_sig
        #
        # Phase 4 : Fill 3D rays information
        #
        # Two nested loops
        #
        #      for all interaction group
        #          for all type of 3D rays
        #             1) extension
        #             2) sort
        #             3) coordinates as a function of parameter
        #
        for k in self:   # for all interaction group k
            # k = int(k)
            # Number of rays in interaction group k
            Nrayk = np.shape(self[k][&#39;alpha&#39;])[1]

            # get  2D horizontal parameterization
            a1 = self[k][&#39;alpha&#39;]

            #if (k==1):
            #    pdb.set_trace()
            # get  2D signature
            sig = self[k][&#39;sig&#39;]
            #print &quot;signatures 2D &quot;,sig
            #print &quot;----&quot;
            sigsave = copy.copy(sig)
            # add parameterization of tx and rx (0,1)
            a1 = np.concatenate((np.zeros((1, Nrayk)), a1, np.ones((1, Nrayk))))
            # reshape signature in adding tx and rx

            if sig.shape[0]!=0:
                sig = np.hstack((np.zeros((2, 1, Nrayk), dtype=int),
                             sig,
                             np.zeros((2, 1, Nrayk), dtype=int)))  # add signature of Tx and Rx (0,0))
            else:
                sig = np.hstack((np.zeros((2, 1, Nrayk), dtype=int),
                                 np.zeros((2, 1, Nrayk), dtype=int)))
            # broadcast tx and rx
            Tx = tx.reshape(3, 1, 1)*np.ones((1, 1, Nrayk))
            Rx = rx.reshape(3, 1, 1)*np.ones((1, 1, Nrayk))

            if k!=0:
                # pte is the sequence of point in 3D ndim =3   ( ndim x k x Nrayk)
                pte = self[k][&#39;pt&#39;]
                # ndim x k+2 x Nrayk
                pte = np.hstack((Tx, pte, Rx))
            else:
                 pte = np.hstack((Tx, Rx))

            # extension
            for l in d:                     # for each vertical pattern (C,F,CF,FC,....)
                #print k,l,d[l]
                Nint = len(d[l])            # number of additional interaction
                #if ((k==1) &amp; (l==5.0)):print
                if Nint &gt; 0:                # if new interaction ==&gt; need extension
                    # a1e : extended horizontal+vertical parameterization
                    a1e = np.concatenate((a1, d[l].reshape(len(d[l]), 1)*
                                          np.ones((1, Nrayk))))
                    # get sorted indices
                    ks = np.argsort(a1e, axis=0)
                    # a1es : extended sorted horizontal + vertical parameterization
                    a1es = np.sort(a1e, axis=0)

                    # #### Check if it exists the same parameter value in the horizontal plane
                    # #### and the vertical plane. Move parameter if so.

                    da1es = np.diff(a1es,axis=0)
                    pda1es = np.where(da1es&lt;1e-10)
                    a1es[pda1es]=a1es[pda1es]-1e-3


                    # prepare an extended sequence of points ( ndim x  (Nint+k+2) x Nrayk )
                    ptee = np.hstack((pte, np.zeros((3, Nint, Nrayk))))

                    #
                    # Boolean ceil/floor detector
                    #
                    # u is 4 (floor interaction )
                    #      5 (ceil interaction )
                    #  depending on the vertical pattern l.
                    #
                    #  l &lt;0 corresponds to last reflexion on floor
                    #  l &gt;0 corresponds to last reflexion on ceil
                    #
                    # u =0 (floor) or 1 (ceil)
                    # if l &lt; 0:
                    #     u = np.mod(range(Nint), 2)
                    # else:
                    #     u = 1 - np.mod(range(Nint), 2)


                    if l &lt; 0 and Nint%2 ==1: # l&lt;0 Nint odd
                        u = np.mod(range(Nint), 2)

                    elif l &gt; 0 and Nint%2 ==1: # l&gt;0 Nint odd
                        u = 1 - np.mod(range(Nint), 2)


                    elif l &lt; 0 and Nint%2 ==0: # l&lt;0 Nint even
                        u = 1 - np.mod(range(Nint), 2)

                    elif l &gt; 0 and Nint%2 ==0: # l&gt;0 Nint even
                        u = np.mod(range(Nint), 2)

                    #
                    u = u + 4
                    #
                    # At that point we introduce the signature of the new
                    # introduced points on the ceil and/or floor.
                    #
                    # A signature is composed of two lines
                    # esigs sup line : interaction number
                    # esigi inf line : interaction type
                    #
                    esigs = np.zeros((1, Nint, Nrayk), dtype=int)
                    esigi = u.reshape(1, Nint, 1)* np.ones((1, 1, Nrayk), dtype=int)
                    # esig : extension of the signature
                    esig = np.vstack((esigs, esigi))
                    # sige : signature extended  ( 2 x (Nint+k+2) x Nrayk )
                    sige = np.hstack((sig, esig))

                    #
                    # 2 x (Nint+k+2) x Nrayk
                    #
                    # sort extended sequence of points
                    # and extended sequence of signatures with the sorting
                    # index ks obtained from argsort of merge parametization
                    #
                    # sequence of extended sorted points
                    #
                    ptees = ptee[:, ks, range(Nrayk)]
                    siges = sige[:, ks, range(Nrayk)]

                    # extended and sorted signature
                    iint_f, iray_f = np.where(siges[ 1, :] == 4)  # floor interaction
                    iint_c, iray_c = np.where(siges[ 1, :] == 5)  # ceil interaction
                    #print siges
                    #
                    # find the list of the previous and next point around the
                    # new ceil or floor point. The case of successive ceil or
                    # floor reflexion make
                    #
                    # Tous les points prcdents qui ne sont pas des Ceils ou
                    # des floors et tous les points suivants qui ne sont pas
                    # des points de rflexion ceil ou floor
                    #
                    # Afin de tenir compte du rayon et du groupe d&#39;interactions
                    # concerne, il faut passer un tuple qui concatene la valeur
                    # de l&#39;indice d&#39;interaction floor ou ceil et l&#39;indice de
                    # rayons du groupe associe (d&#39;ou le zip)
                    #
                    # Cette sequence d&#39;instruction fixe le bug #133
                    #
                    # Antrieurement il y avait une hypothese de succession
                    # immediate d&#39;un point 2D renseigne.
                    #
                    try:
                        iintm_f = [ np.where( (siges[1,0:x[0],x[1]]!=4) &amp;
                                             (siges[1,0:x[0],x[1]]!=5))[0][-1]
                                   for x in  zip(iint_f,iray_f) ]
                        iintp_f = [ np.where( (siges[1,x[0]:,x[1]]!=4) &amp;
                                             (siges[1,x[0]:,x[1]]!=5))[0][0]+x[0]
                                   for x in  zip(iint_f,iray_f) ]
                        iintm_c = [ np.where( (siges[1,0:x[0],x[1]]!=4) &amp;
                                             (siges[1,0:x[0],x[1]]!=5))[0][-1]
                                   for x in zip(iint_c,iray_c) ]
                        iintp_c = [ np.where( (siges[1,x[0]:,x[1]]!=4) &amp;
                                             (siges[1,x[0]:,x[1]]!=5))[0][0]+x[0]
                                   for x in  zip(iint_c,iray_c) ]
                    except:
                        pdb.set_trace()

                    # Update coordinate in the horizontal plane
                    #
                    #
                    # The new interaction ceil or floor has no coordinates in
                    # the horizontal plane.
                    # Those coordinates are evaluated first by finding a sub
                    # parameterization of the point with respect to the two
                    # known adjascent interaction point j-1 and j+1 (Thales)
                    #

                    #iintm_f = iint_f - 1
                    #iintp_f = iint_f + 1

                    #iintm_c = iint_c - 1
                    #iintp_c = iint_c + 1


                    #
                    # If there are floor points
                    #

                    if len(iint_f)&gt;0:
                        a1esm_f = a1es[iintm_f, iray_f]
                        a1esc_f = a1es[iint_f, iray_f]
                        a1esp_f = a1es[iintp_f, iray_f]


                        pteesm_f = ptees[0:2, iintm_f, iray_f]
                        pteesp_f = ptees[0:2, iintp_f, iray_f]

                        coeff_f = (a1esc_f-a1esm_f)/(a1esp_f-a1esm_f)

                        ptees[0:2, iint_f, iray_f] = pteesm_f + coeff_f*(pteesp_f-pteesm_f)

                    #
                    # If there are ceil points
                    #
                    if len(iint_c)&gt;0:
                        a1esm_c = a1es[iintm_c, iray_c]
                        a1esc_c = a1es[iint_c, iray_c]
                        a1esp_c = a1es[iintp_c, iray_c]

                        pteesm_c = ptees[0:2, iintm_c, iray_c]
                        pteesp_c = ptees[0:2, iintp_c, iray_c]

                        coeff_c = (a1esc_c-a1esm_c)/(a1esp_c-a1esm_c)
                        ptees[0:2, iint_c, iray_c] = pteesm_c + coeff_c*(pteesp_c-pteesm_c)

                    if H != 0:
                        z  = np.mod(l+a1es*(rx[2]-l), 2*H)
                        pz = np.where(z &gt; H)
                        z[pz] = 2*H-z[pz]
                        ptees[2, :] = z
                    # case where ceil reflection are inhibited
                    elif H==0:
                        z  = abs(l+a1es*(rx[2]-l))
                        # pz = np.where(z &gt; H)
                        # z[pz] = 2*H-z[pz]
                        ptees[2, :] = z

                # recopy old 2D parameterization (no extension)
                else:
                    a1es = a1
                    ks = np.argsort(a1es, axis=0)
                    ptees = pte
                    # fixing bug
                    siges = copy.copy(sig)
                    #print siges

                #---------------------------------
                # handling multi segment (iso segments)
                #    Height of reflexion interaction
                #    Height of diffraction interaction
                #---------------------------------
                #
                #   ptes (3 x i+2 x r )
                if len(L.lsss)&gt;0:
                    #
                    # lsss : list of sub segments ( iso segments siges)
                    # lnss : list of diffaction point involving

                    lsss = np.array(L.lsss)
                    lnss = np.array(L.lnss)

                    # array of structure element (nstr) with TxRx extension  (nstr=0)
                    anstr = siges[0,:,:]
                    # type of interaction
                    typi = siges[1,:,:]

                    # lss : list of subsegments in the current signature
                    #
                    # scalability : avoid a loop over all the subsegments in lsss
                    #
                    lss = [ x for x in lsss if x in anstr.ravel()]

                    ray_to_delete = []
                    for s in lss:
                        u  = np.where(anstr==s)
                        if len(u)&gt;0:
                            zs = ptees[2,u[0],u[1]]
                            zinterval = L.Gs.node[s][&#39;z&#39;]
                            unot_in_interval = ~((zs&lt;=zinterval[1]) &amp; (zs&gt;=zinterval[0]))
                            ray_to_delete.extend(u[1][unot_in_interval])

                    # lns : list of diffraction points in the current signature
                    #       with involving multi segments (iso)
                    # scalability : avoid a loop over all the points in lnss
                    #
                    lns = [ x for x in lnss if x in anstr.ravel()]

                    #
                    # loop over multi diffraction points
                    #

                    for npt in lns:
                        # diffraction cornet in espoo.lay
                        #if npt==-225:
                        #    import ipdb
                        #    ipdb.set_trace()

                        u  = np.where(anstr==npt)
                        if len(u)&gt;0:
                           # height of the diffraction point
                            zp = ptees[2,u[0],u[1]]

                            #
                            # At which couple of segments belongs this height ?
                            # get_diffslab function answers that question
                            #

                            ltu_seg,ltu_slab = L.get_diffslab(npt,zp)

                            #
                            # delete rays where diffraction point is connected to
                            # 2 AIR segments
                            #

                            [ray_to_delete.append(u[1][i]) for i in range(len(zp))
                            if ((ltu_slab[i][0]==&#39;AIR&#39;) &amp; (ltu_slab[i][1]==&#39;AIR&#39;))]
                            # #zinterval = L.Gs.node[s][&#39;z&#39;]
                            # # if (zs&lt;=zinterval[1]) &amp; (zs&gt;=zinterval[0]):
                            # if ((tu_slab[0]!=&#39;AIR&#39;) &amp; (tu_slab[1]!=&#39;AIR&#39;)):
                            #     #print(npt , zp)
                            #     pass
                            # else:
                            #     ray_to_delete.append(u[1][0])

                    # # nstr : structure number
                    # nstr  = np.delete(nstr,ray_to_delete,axis=1)
                    # typi : type of interaction
                    typi  = np.delete(typi,ray_to_delete,axis=1)
                    # 3d sequence of points
                    ptees = np.delete(ptees,ray_to_delete,axis=2)
                    # extended (floor/ceil) signature
                    siges = np.delete(siges,ray_to_delete,axis=2)

                if rmoutceilR:
                    # 1 determine Ceil reflexion index
                    # uc (inter x ray)
                    uc = np.where(siges[1,:,:]==5)
                    ptc = ptees[:,uc[0],uc[1]]
                    if len(uc[0]) !=0:
                        P = shg.MultiPoint(ptc[:2,:].T)
                        # to determine the cycle where ceil reflexions append
                        # uinter(nb pt x nb cycles)
                        mapnode = list(L.Gt.nodes())
                        uinter = np.array([[L.Gt.node[x][&#39;polyg&#39;].contains(p) for x in mapnode if x&gt;0] for p in P])
                        # import ipdb
                        # ipdb.set_trace()
                        #[plt.scatter(p.xy[0],p.xy[1],c=&#39;r&#39;) for up,p in enumerate(P) if uinter[0,up]]
                        #[ plt.scatter(p.xy[0],p.xy[1],c=&#39;r&#39;) for up,p in enumerate(P) if uinter[0,up]]
                        # find points are indoor/outdoor cycles
                        upt,ucy = np.where(uinter)
                        uout = np.where([not L.Gt.node[mapnode[u+1]][&#39;indoor&#39;] for u in ucy])[0] #ucy+1 is to manage cycle 0
                        # 3 remove ceil reflexions of outdoor cycles
                        if len(uout)&gt;0:
                            ptees = np.delete(ptees,uc[1][uout],axis=2)
                            siges = np.delete(siges,uc[1][uout],axis=2)
                            sigsave = np.delete(sigsave,uc[1][uout],axis=2)

                if k+Nint in r3d:
                    r3d[k+Nint][&#39;pt&#39;]  = np.dstack((r3d[k+Nint][&#39;pt&#39;], ptees))
                    r3d[k+Nint][&#39;sig&#39;] = np.dstack((r3d[k+Nint][&#39;sig&#39;], siges))
                    r3d[k+Nint][&#39;sig2d&#39;].append(sigsave)
                else:
                    if ptees.shape[2]!=0:
                        r3d[k+Nint] = {}
                        r3d[k+Nint][&#39;pt&#39;] = ptees
                        r3d[k+Nint][&#39;sig&#39;] = siges
                        r3d[k+Nint][&#39;sig2d&#39;] = [sigsave]
                # ax=plt.gca()
                # uu = np.where(ptees[2,...]==3.0)
                # ax.plot(ptees[0,uu[0],uu[1]],ptees[1,uu[0],uu[1]],&#39;ok&#39;)
                # import ipdb
                # ipdb.set_trace()
        #
        # Add Line Of Sight ray information
        #   pt =  [tx,rx]
        #   sig = [0,0]
        #
        #pdb.set_trace()
        # if (self.los) &amp; (np.sqrt(np.sum((tx-rx)**2)) !=0) :
        #     r3d[0] = {}
        #     r3d[0][&#39;sig&#39;] = np.zeros((2,2,1))
        #     r3d[0][&#39;sig2d&#39;] = np.zeros((2,2,1))
        #     r3d[0][&#39;pt&#39;] = np.zeros((3,2,1))
        #     r3d[0][&#39;pt&#39;][:,0,:] = tx[:,np.newaxis]
        #     r3d[0][&#39;pt&#39;][:,1,:] = rx[:,np.newaxis]

        # r3d.nray = reduce(lambda x,y : y + np.shape(r3d[x][&#39;sig&#39;])[2],lnint)
        # count total number of ray
        # evaluate length of ray segment
        #
        # vsi
        # si
        # dis
        #
        val =0

        for k in r3d.keys():
            nrayk = np.shape(r3d[k][&#39;sig&#39;])[2]
            r3d[k][&#39;nbrays&#39;] = nrayk
            r3d[k][&#39;rayidx&#39;] = np.arange(nrayk)+val
            r3d.nray = r3d.nray + nrayk
            val=r3d[k][&#39;rayidx&#39;][-1]+1

            # 3 : x,y,z
            # i : interaction index
            # r : ray index
            #
            # k : group of interactions index
            #
            v = r3d[k][&#39;pt&#39;][:, 1:, :]-r3d[k][&#39;pt&#39;][:, 0:-1, :]
            lsi = np.sqrt(np.sum(v*v, axis=0))
            rlength = np.sum(lsi,axis=0)
            if (lsi.any()==0):
                pdb.set_trace()
            if not (lsi.all()&gt;0):
                pdb.set_trace()
            #assert(lsi.all()&gt;0)

            if (len(np.where(lsi==0.))==0) :
                pdb.set_trace()

            #
            # sort rays w.r.t their length
            #

            u = np.argsort(rlength)
            r3d[k][&#39;pt&#39;]  = r3d[k][&#39;pt&#39;][:,:,u]
            r3d[k][&#39;sig&#39;] = r3d[k][&#39;sig&#39;][:,:,u]
            #r3d[k][&#39;sig2d&#39;] = r3d[k][&#39;sig2d&#39;][:,:,u]
            si = v/lsi             # ndim , nint - 1 , nray

            # vsi : 3 x (i+1) x r
            r3d[k][&#39;vsi&#39;] = si[:,:,u]

            # si : (i+1) x r
            r3d[k][&#39;si&#39;]  = lsi[:,u]
            r3d[k][&#39;dis&#39;] = rlength[u]

        r3d.delays = np.zeros((r3d.nray))
        for k in r3d.keys():
            ir = r3d[k][&#39;rayidx&#39;]
            r3d.delays[ir] = r3d[k][&#39;dis&#39;]/0.3


        r3d.origin_sig_name = self.origin_sig_name
        r3d.Lfilename = L._filename
        r3d.filename = L._filename.split(&#39;.&#39;)[0] + &#39;_&#39; + str(r3d.nray)
        return(r3d)</div>


<div class="viewcode-block" id="Rays.get_rays_slabs"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.get_rays_slabs">[docs]</a>    def get_rays_slabs(self,L,ir):
        &quot;&quot;&quot; return the slabs for a given interaction index 


            Parameters
            ----------

            L : Layout
            ir : interaction block

            Returns
            -------

            numpy array of slabs strings at the shape (ir,r)
            ir : number of interactions ( of the interaction block)
            r : number of rays

        &quot;&quot;&quot;

        v=np.vectorize( lambda t: L.Gs.node[t][&#39;name&#39;] if (t!=0) and (t&gt;0) else &#39;_&#39;)
        return v(self[ir][&#39;sig&#39;][0])</div>


<div class="viewcode-block" id="Rays.remove_aw"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.remove_aw">[docs]</a>    def remove_aw(self,L):
        &quot;&quot;&quot; remove AIR interactions
        &quot;&quot;&quot;
        # def consecutive(data, stepsize=1):
        #     return np.split(data, np.where(np.diff(data) != stepsize)[0]+1)


        R = Rays(self.pTx,self.pRx)
        R.__dict__.update(self.__dict__)
        # R.is3D=True
        # R.nray = self.nray
        # R.nray2D = self.nray2D
        # R.nray2D = self.nray2D
        # R.nray2D = self.nray2D

        for k in self:
            lr = self[k][&#39;sig&#39;].shape[1]

            inter = self.get_rays_slabs(L,k)

            for ur,r in enumerate(inter.T):

                not_air_mask  = ~((r ==&#39;_AIR&#39;) | (r == &#39;AIR&#39; ))
                nb_air = sum(~not_air_mask)
                if nb_air != 0 :
                    new_bi = k-nb_air
                    #Â +2 : add tx &amp; rx interaciton
                    #Â -1 : 2 interactions correspond to 1 distance
                    lsi = new_bi + 2 - 1 
                    si = np.zeros(lsi) 
                    si_old = self[k][&#39;si&#39;][:,ur]

                    vsi = np.zeros((3,lsi)) 
                    vsi_old = self[k][&#39;vsi&#39;][...,ur]

                    sig = self[k][&#39;sig&#39;][:,not_air_mask,ur][...,None]
                    # sig2d = self[k][&#39;sig2d&#39;][0][...,ur]
                    pt = self[k][&#39;pt&#39;][:,not_air_mask,ur][...,None]

                    u = 0
                    si_aw = 0

                    # import ipdb
                    # ipdb.set_trace()

                    for uold,b in enumerate(not_air_mask[1:]):
                        if b:
                            #Â update new si with sum of all 
                            #Â distance from preceding airwall
                            si[u] = si_old[uold] + si_aw
                            #Â keep vsi from the last airwall
                            #Â because vsi don&#39;t change on an airwall
                            vsi[:,u] = vsi_old[:,uold] 
                            u += 1
                            si_aw=0
                        else:
                            si_aw += si_old[uold]
                    si = si[...,None]
                    vsi = vsi[...,None]
                    dis = np.array([np.sum(si)])
                    assert np.allclose(dis,np.sum(si_old))



                else:
                    #Â no air wall case, fill R with self values
                    new_bi = k
                    pt = self[k][&#39;pt&#39;][...,ur][...,None]
                    sig = self[k][&#39;sig&#39;][...,ur][...,None]
                    # sig2d = self[k][&#39;sig2d&#39;][0][...,ur]
                    si = self[k][&#39;si&#39;][:,ur][:,None]
                    vsi = self[k][&#39;vsi&#39;][...,ur][...,None]
                    dis = np.array([self[k][&#39;dis&#39;][ur]])

                if new_bi in R:

                    # R[new_bi][&#39;sig2d&#39;].append(self[k][&#39;sig2d&#39;][ur])
                    R[new_bi][&#39;pt&#39;] = np.concatenate((R[new_bi][&#39;pt&#39;],pt),axis=2)
                    R[new_bi][&#39;sig&#39;] = np.concatenate((R[new_bi][&#39;sig&#39;],sig),axis=2)
                    R[new_bi][&#39;rayidx&#39;] = np.concatenate((R[new_bi][&#39;rayidx&#39;],np.array([self[k][&#39;rayidx&#39;][ur]])))
                    R[new_bi][&#39;si&#39;] = np.concatenate((R[new_bi][&#39;si&#39;],si),axis=1)
                    R[new_bi][&#39;vsi&#39;] = np.concatenate((R[new_bi][&#39;vsi&#39;],vsi),axis=2)
                    R[new_bi][&#39;dis&#39;] = np.concatenate((R[new_bi][&#39;dis&#39;],dis),axis=0)
                else:
                    R[new_bi] = {}
                    # R[new_bi][&#39;sig2d&#39;] = [self[k][&#39;sig2d&#39;][0][...,ur]]
                    R[new_bi][&#39;pt&#39;] = pt
                    R[new_bi][&#39;sig&#39;] = sig
                    R[new_bi][&#39;rayidx&#39;] = np.array([self[k][&#39;rayidx&#39;][ur]])
                    R[new_bi][&#39;si&#39;] = si
                    R[new_bi][&#39;vsi&#39;] = vsi
                    R[new_bi][&#39;dis&#39;] = dis

        if 0 in R:
            R.los=True

        X = [[R[k][&#39;rayidx&#39;][u] for u in range(len(R[k][&#39;rayidx&#39;]))] for k in R]
        R._rayidx_aw = sum(X,[])

        return R</div>

<div class="viewcode-block" id="Rays.length"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.length">[docs]</a>    def length(self,typ=2):
        &quot;&quot;&quot; calculate length of rays

        Parameters
        ----------

        typ : int
            men1 : length of all segments
            2 : accumulated length
        &quot;&quot;&quot;
        dk = {}
        for k in self:   # for all interaction group k
            # 3 x Ni-1 x Nr
            vk = self[k][&#39;pt&#39;][:,1:,:]-self[k][&#39;pt&#39;][:,0:-1,:]
            d1 = np.sqrt(np.sum(vk*vk,axis=0))
            d2 = np.sum(d1,axis=0)
            if typ==1:
                dk[k] = d1
            if typ==2:
                dk[k] = d2
        return(dk)</div>

<div class="viewcode-block" id="Rays.simplify"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.simplify">[docs]</a>    def simplify(self):
        if not self.is3D:
            return None

        for ir in self:
            print(self[ik][&#39;si&#39;])</div>

<div class="viewcode-block" id="Rays.locbas"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.locbas">[docs]</a>    def locbas(self, L):
        &quot;&quot;&quot; calculate ray local bas

        Parameters
        ----------

        L : Layout

        Notes
        -----

        This method adds for each group of interactions the following members

        norm : np.array
            3 x i x r  (interaction vector)
        nstrwall : np.array
            nstr of interactions
        vsi : np.array
            3 x (i+1) x r
        aod : np.array
            2 x r
        aoa : np.array
            2 x r
        BoO : np.array
            3 x 3 x r
        Bi  : np.array
            3 x 3 x r
        Bo  : np.array
            3 x 3 x r
        BiN : np.array
            3 x 3 x r
        scpr : np.array
            i x r
        theta : np.array
            i x r
        rays  : int
        nbrays  : int
        rayidx : np.array
        diffslabs : list
        diffvect :  np.array
            (phi0,phi,beta,NN)


        &quot;&quot;&quot;

        #
        # extract normal in np.array
        #

        # nsegment x 3
        norm = np.array(list(nx.get_node_attributes(L.Gs,&#39;norm&#39;).values()))

        # nsegment x k
        key = np.array(list(dict(nx.get_node_attributes(L.Gs,&#39;norm&#39;)).keys()))

        # maximum number for refering to segment
        # not to be confused with a segment number

        nsmax = max(L.Gs.node.keys())

        mapping = np.zeros(nsmax+1, dtype=int)

        mapping[key] = np.arange(len(key), dtype=int)

        #
        # Structure number : nstr
        #   the structure number is &lt; 0 for points
        #                           &gt; 0 for segments
        # A segment can have several subsegments (until 100)
        #  nstrs is the nstr of the segment if subsegment :
        #  nstr  is the glabal which allows to recover the slab values
        #

        idx = np.array(())
        if self.los:
            idxts = 1
            nbrayt = 1
        else:
            idxts = 0
            nbrayt = 0

        # list of used wedges
        luw=[]

        lgi = list(self.keys())
        lgi.sort()
        for k in lgi:
            #
            # k is the number of interactions in the block
            #
            #print(k,self[11][&#39;rayidx&#39;])
            if k != 0:

                # structure number (segment or point)
                # nstr : i x r
                nstr = self[k][&#39;sig&#39;][0, 1:-1, :]

                # ityp : i x r
                ityp = self[k][&#39;sig&#39;][1, 1:-1, :]

                # nstr of underlying segment
                # position of interaction corresponding to a sub segment
                # print nstr
                #
                # uss : index of subsegment
                # subsegments are not nodes of Gs but have positive nstr index
                #

                uss   = np.where(nstr &gt; nsmax)

                # print uss

                nstrs = copy.copy(nstr)
                #
                # if subsegments have been found
                #
                if len(uss) &gt;0:
                    ind   = nstr[uss]- nsmax-1
                    nstrs[uss] = np.array(L.lsss)[ind]
                #    print nstr
                #print nstrs
                #pdb.set_trace()
                nray = np.shape(nstr)[1]

                uwall = np.where((ityp == 2) | (ityp == 3))
                udiff = np.where((ityp == 1))
                ufloor= np.where((ityp == 4))
                uceil = np.where((ityp == 5))

                nstrwall  = nstr[uwall[0], uwall[1]]   # nstr of walls
                nstrswall = nstrs[uwall[0], uwall[1]]   # nstrs of walls

                self[k][&#39;nstrwall&#39;]  = nstrwall    # store nstr without subsegment
                self[k][&#39;nstrswall&#39;] = nstrswall   # store nstr with subsegment
                self[k][&#39;norm&#39;] = np.zeros((3, k, nray))   # 3 x int x nray

                # norm : 3 x i x r
                #
                # norm is the vector associated to the interaction
                # For the diffraction case the normal is replaced by the unit
                # vector along the wedge directed upward.
                #

                self[k][&#39;norm&#39;][:, uwall[0], uwall[1]] = norm[mapping[nstrswall],:].T
                self[k][&#39;norm&#39;][2, ufloor[0], ufloor[1]] = np.ones(len(ufloor[0]))
                self[k][&#39;norm&#39;][2, uceil[0], uceil[1]] = -np.ones(len(uceil[0]))
                self[k][&#39;norm&#39;][2, udiff[0], udiff[1]] = np.ones(len(udiff[0]))

                normcheck = np.sum(self[k][&#39;norm&#39;]*self[k][&#39;norm&#39;],axis=0)

                assert normcheck.all()&gt;0.99,pdb.set_trace()



                # 3 : x,y,z
                # i : interaction index
                # r : ray index
                #
                # k : group of interactions index
                #
                #v = self[k][&#39;pt&#39;][:, 1:, :]-self[k][&#39;pt&#39;][:, 0:-1, :]
                #lsi = np.sqrt(np.sum(v*v, axis=0))
                #if (lsi.any()==0):
                #    pdb.set_trace()
                #assert(lsi.all()&gt;0)
                #if (len(np.where(lsi==0.))==0) :
                #    pdb.set_trace()

                #si = v/lsi             # ndim , nint - 1 , nray

                # si : 3 x (i+1) x r
                si = self[k][&#39;vsi&#39;]

                # si : (i+1) x r
                #self[k][&#39;si&#39;] = lsi
                #self[k][&#39;dis&#39;] = np.sum(lsi,axis=0)

                # normal : 3 x i x r
                vn = self[k][&#39;norm&#39;]
                # s_in : 3 x i x r
                s_in = si[:, 0:-1, :]

                # s_out : 3 x i x r
                s_out = si[:, 1:, :]

                #
                # AOD (rad)
                #

                # th : ,r
                thd = np.arccos(si[2, 0, :])

                # ph : ,r
                phd = np.arctan2(si[1, 0, :], si[0, 0, :])

                # aod : 2 x r  (radians)
                self[k][&#39;aod&#39;] = np.vstack((thd, phd))

                # eth : 3 x r
                eth = np.array([np.cos(thd) * np.cos(phd),
                               np.cos(thd) * np.sin(phd),
                                -np.sin(thd)])
                # eph : 3 x r
                eph = np.array([-np.sin(phd),
                                np.cos(phd),
                                np.zeros(len(phd))])

                # Bo0 : 3 x 3 x r
                Bo0 = np.concatenate((si[:, 0, None, :],
                                      eth[:, None, :],
                                      eph[:, None, :]), axis=1)

                self[k][&#39;Bo0&#39;] = Bo0

                #
                # scalar product si . norm
                #
                # vn   : 3 x i x r
                # s_in : 3 x i x r

                #
                # scpr : i x r
                #

                scpr = np.sum(vn*si[:,0:-1,:], axis=0)
                self[k][&#39;scpr&#39;] = scpr
                self[k][&#39;theta&#39;] = np.arccos(abs(scpr))  # *180/np.pi

                def fix_colinear(w):
                    &quot;&quot;&quot;
                    w : vector
                    &quot;&quot;&quot;
                    nw = np.sqrt(np.sum(w*w, axis=0))
                    u = np.where(nw==0)
                    if len(u[0])!=0:
                        logger.debug(&#39;colinear situation detected&#39;)
                        if (u[0].any() or u[1].any()) \
                            or (u[0].any()==0 or u[1].any()==0):

                            uu = np.array([u[0],u[1]]).T
                            #determine which interaction and rays
                            #present the colinearity issue
                            uvv = abs(vn[2,uu[:,0],uu[:,1]])&gt;0.99
                            # uv : nbi x nbr colinear index
                            uv = uu[uvv]
                            # uh : nbi x nbr anti-colinear index
                            uh = uu[np.logical_not(uvv)]
                            try:
                                #fix w for colinear index
                                w[:,uv[:,0],uv[:,1]] = np.array(([1,0,0]))[:,None]
                                # update normal
                                nw[uv[:,0],uv[:,1]] = np.sqrt(np.sum(
                                    w[:,uv[:,0],uh[:,1]]*w[:,uv[:,0],uv[:,1]],axis=0))
                            except:
                                pass
                            try:
                                # fix w for anti-colinear index
                                w[:,uh[:,0],uh[:,1]] = np.array(([0,0,1]))[:,None]
                                # update normal
                                nw[uh[:,0],uh[:,1]] = \
                                    np.sqrt(np.sum(w[:,uh[:,0],uh[:,1]]*w[:,uh[:,0],uh[:,1]],axis=0))
                            except:
                                pass
                    return w, nw
                #
                # Warning need to handle singular case when s_in // vn
                #
                # w : 3 x i x r
                #
                w = np.cross(s_in, vn, axisa=0, axisb=0, axisc=0)

                # nw : i x r
                w, nw = fix_colinear(w)

                wn = w/nw
                v = np.cross(wn, s_in, axisa=0, axisb=0, axisc=0)

                es_in = np.expand_dims(s_in, axis=1)

                ew = np.expand_dims(wn, axis=1)
                ev = np.expand_dims(v, axis=1)

                #  Bi 3 x 3 x i x r
                Bi = np.concatenate((es_in,ew,ev),axis=1)
                #  self[k][&#39;Bi&#39;] 3 x 3 x i x r
                self[k][&#39;Bi&#39;] = Bi
                ################################

                w = np.cross(s_out, vn, axisa=0, axisb=0, axisc=0)

                w, nw = fix_colinear(w)
                #wn = w/np.sqrt(np.sum(w*w, axis=0))
                wn = w/nw

                v = np.cross(wn, s_out, axisa=0, axisb=0, axisc=0)

                es_out = np.expand_dims(s_out, axis=1)
                ew = np.expand_dims(wn, axis=1)
                ev = np.expand_dims(v, axis=1)

                #  Bi 3 x 3 x i x r
                Bo = np.concatenate((es_out,ew,ev),axis=1)

                 # self[k][&#39;Bo&#39;] 3 x 3 x i x r
                self[k][&#39;Bo&#39;] = Bo
                #
                # AOA (rad)
                #

                # th : ,r
                # fix doa/dod reciprocity
                #th = np.arccos(si[2, -1, :])
                tha = np.arccos(si[2, -1, :])

                # th : ,r
                #ph = np.arctan2(si[1, -1, :], si[0, -1, :])
                pha = np.arctan2(si[1, -1, :], si[0, -1, :])

                # aoa : 2 x r  (radians)
                self[k][&#39;aoa&#39;] = np.vstack((tha, pha))
                eth = np.array([np.cos(tha) * np.cos(pha),
                               np.cos(tha) * np.sin(pha),
                                -np.sin(tha)])
                eph = np.array([-np.sin(pha),
                                np.cos(pha),
                                np.zeros(len(pha))])
                # Bo0 : 3 x 3 x r
                BiN = np.concatenate((si[:,-1,None,:],
                                      eth[:, None, :],
                                      eph[:, None, :]), axis=1)


                self[k][&#39;BiN&#39;] = BiN
                #self[k][&#39;BiN&#39;] = np.concatenate((-si[:,-1,np.newaxis,:],eth[:,np.newaxis,:],
                #                                   eph[:,np.newaxis,:]),axis=1)

                # Creation of B from Bi and Bo
                # is done after the potential diffraction
                # computation

                ## index creation
                ##################
                # create index for retrieving interactions

                # integer offset : total size idx

                idxts = idxts + idx.size

                idx = idxts + np.arange(ityp.size).reshape(np.shape(ityp),order=&#39;F&#39;)

                nbray = np.shape(idx)[1]

                self[k][&#39;rays&#39;] = idx
                self[k][&#39;nbrays&#39;] = nbray
                self[k][&#39;rayidx&#39;] = nbrayt + np.arange(nbray)

                # create a numpy array to relate the ray index to its corresponding
                # number of interactions
                #pdb.set_trace()
                _ray2nbi = np.ones((nbray), dtype=int)


                try:
                    self._ray2nbi = np.hstack((self._ray2nbi,_ray2nbi))
                except:
                    self._ray2nbi = _ray2nbi


                self._ray2nbi[self[k][&#39;rayidx&#39;]]  = k
                nbrayt = nbrayt + nbray
                self.raypt = self.raypt + self[k][&#39;nbrays&#39;]

                #################################
                # Start diffraction specific case
                #################################

                if len(udiff[0]) != 0 :
                    Z = np.where(ityp.T==1)
                    udiff=Z[1],Z[0]

                    # diffseg,udiffseg  = np.unique(nstr[udiff],return_inverse=True)
                    diffupt=nstr[udiff]
                    # position of diff seg (- because iupnt accept &gt; 0 reference to points)
                    #
                    # TO BE FIXED
                    #
                    #ptdiff = L.pt[:,L.iupnt[-diffupt]]
                    ptdiff = np.array([ (L.Gs.pos[x][0],L.Gs.pos[x][1])  for x in diffupt ]).T

                    self[k][&#39;diffidx&#39;] = idx[udiff[0],udiff[1]]
                    # get tail head position of seg associated to diff point
                    lair = L.name[&#39;AIR&#39;] + L.name[&#39;_AIR&#39;]
                    #aseg = map(lambda x : filter(lambda y : y not in lair,
                    #                     nx.neighbors(L.Gs,x)),
                    #                     diffupt)

                    aseg = [ [ y for y in nx.neighbors(L.Gs,x) if y not in lair ] for x in diffupt ]

                    #manage flat angle : diffraction by flat segment e.g. door limitation)
                    [aseg[ix].extend(x) for ix,x in enumerate(aseg) if len(x)==1]
                    # get points positions
                    #pdb.set_trace()
                    pts = np.array([ L.seg2pts([x[0],x[1]]) for x in aseg ])

                    #self[k][&#39;diffslabs&#39;]=[str(L.sl[L.Gs.node[x[0]][&#39;name&#39;]])+&#39;_&#39;
                    #                    + str(L.sl[L.Gs.node[x[1]][&#39;name&#39;]]]) for x in aseg]
                    self[k][&#39;diffslabs&#39;]=[ L.Gs.node[x[0]][&#39;name&#39;]+&#39;@&#39;
                                        +  L.Gs.node[x[1]][&#39;name&#39;] for x in aseg]

                    uwl = np.unique(self[k][&#39;diffslabs&#39;]).tolist()
                    luw.extend(uwl)


                    pt1 = pts[:,0:2,0] #tail seg1
                    ph1 = pts[:,2:4,0] #head seg1
                    pt2 = pts[:,0:2,1] #tail seg2
                    ph2 = pts[:,2:4,1] #head seg2


                    #pts is (nb_diffraction_points x 4 x 2)
                    #- The dimension 4 represent the 2x2 points: t1,h1 and t2,h2
                    # tail and head of segment 1 and 2 respectively
                    # a segment
                    #- The dimension 2 is x,y
                    #
                    # The following aims to determine which tails and heads of
                    # segments associated to a given diffraction point
                    # are connected
                    #
                    #

                    # point diff is pt1
                    updpt1 = np.where(np.sum(ptdiff.T==pt1,axis=1)==2)[0]
                    # point diff is ph1
                    updph1 = np.where(np.sum(ptdiff.T==ph1,axis=1)==2)[0]

                    # point diff is pt2
                    updpt2 = np.where(np.sum(ptdiff.T==pt2,axis=1)==2)[0]

                    # point diff is ph2
                    updph2 = np.where(np.sum(ptdiff.T==ph2,axis=1)==2)[0]

                    pa = np.empty((len(diffupt),2))
                    pb = np.empty((len(diffupt),2))

                    ####seg 1 :
                    #if pt1 diff point =&gt;  ph1 is the other point
                    pa[updpt1]= ph1[updpt1]
                    #if ph1 diff point =&gt;  pt1 is the other point
                    pa[updph1]= pt1[updph1]
                    ####seg 2 :
                    #if pt2 diff point =&gt;  ph2 is the other point
                    pb[updpt2]= ph2[updpt2]
                    #if ph2 diff point =&gt;  pt2 is the other point
                    pb[updph2]= pt2[updph2]

                    pt = ptdiff.T

                    # NN : (nb_diffraction_points)
                    # alpha wegde (a.k.a. wedge parameters, a.k.a wedge aperture)

                    NN = (360.-geu.sector(pa.T,pb.T,pt.T))/180.
                    # NN = (2.-NN)*np.pi

                    #angle between face 0, diffraction point and s_in
                    #s_in[:2,udiff[0],udiff[1]]  :
                    # s_in of insteractions udiff (2D) restricted to diffraction points
                    vptpa = pt-pa
                    vptpan = vptpa.T / np.sqrt(np.sum((vptpa)*(vptpa),axis=1))
                    # vpapt= pa-pt # papt : direction vector of face 0
                    # vpaptn = vpapt.T / np.sqrt(np.sum((vpapt)*(vpapt),axis=1))
                    sid = s_in[:,udiff[0],udiff[1]] #s_in restricted to diff
                    sod = s_out[:,udiff[0],udiff[1]] #s_out restricted to diff
                    vnormz = self[k][&#39;norm&#39;][:, udiff[0], udiff[1]]


                    #phi0 = arccos(dot(sid*vpavptn))
                    # phi0 = geu.vecang(sid[:2],vpaptn)
                    uleft = geu.isleft(pa.T,pt.T,pb.T)
                    phi0 = geu.vecang(vptpan,sid[:2])
                    phi0[~uleft] = geu.vecang(sid[:2,~uleft],vptpan[:,~uleft])
                    # phi0 = np.arccos(np.sum(sid[:2]*vpaptn,axis=0))

                    #phi = arccos(dot(sod*vpavptn))
                    # phi = np.arccos(np.sum(-sod[:2]*vpaptn,axis=0))
                    phi = geu.vecang(vptpan,-sod[:2])
                    phi[~uleft] = geu.vecang(-sod[:2,~uleft],vptpan[:,~uleft])
                    # beta
                    #it is important to check if the sid comes from left or right
                    #to this end assume that sid vector is composed
                    #of 2 point : (0,0) and sid
                    # compared to the position of the diffraction point in x
                    # with an elevation=0
                    sidxz = sid[[0,2]]
                    vnormxz = vnormz[[0,2]]
                    zero = np.zeros((2,ptdiff.shape[1]))
                    zdiff = np.vstack((ptdiff[0],zero[0]))
                    left = geu.isleft(zero,sidxz,zdiff)
                    beta = np.arccos(np.sum(vnormz*sid,axis=0))

                    # self[k][&#39;diffvect&#39;] is (4 x Nb_rays )
                    # for axis 0 lenght 4 represent :
                    # 0 =&gt; phi0
                    # 1 =&gt; phi
                    # 2 =&gt; beta
                    # 3 =&gt; N (wedge parameter)
                    self[k][&#39;diffvect&#39;]=np.array((phi0,phi,beta,NN))

                    ######
                    #Bi diffract
                    #####
                    #w is the \perp \soft in diff
                    w = np.cross(-sid, vnormz, axisa=0, axisb=0, axisc=0)

                    # nw : i x r
                    w, nw = fix_colinear(w)

                    wn = w/nw
                    # Handling channel reciprocity s_in --&gt; -s_in
                    #v = np.cross(wn, s_in, axisa=0, axisb=0, axisc=0)
                    v = np.cross(wn, -sid, axisa=0, axisb=0, axisc=0)

                    e_sid = np.expand_dims(-sid, axis=1)
                    ew = np.expand_dims(wn, axis=1)
                    ev = np.expand_dims(v, axis=1)

                    #  Bid 3 x 3 x (i,r)diff
                    Bid = np.concatenate((e_sid,ev, ew), axis=1)

                    #update Bi for diffracted rays
                    Bi[:,:,udiff[0],udiff[1]] = Bid
                    ######
                    #Bo diffract
                    #####
                    w = np.cross(sod,vnormz, axisa=0, axisb=0, axisc=0)

                    w, nw = fix_colinear(w)
                    wn = w/nw

                    #wn = w/np.sqrt(np.sum(w*w, axis=0))
                    v = np.cross(wn, sod, axisa=0, axisb=0, axisc=0)

                    e_sod = np.expand_dims(sod, axis=1)
                    ew = np.expand_dims(wn, axis=1)
                    ev = np.expand_dims(v, axis=1)
                    #  Bod 3 x 3 x (i,r)diff
                    Bod = np.concatenate((e_sod,ev, ew), axis=1)

                    #update Bo for diffracted rays
                    Bo[:,:,udiff[0],udiff[1]] = Bod
                #################################
                # End of diffraction specific case
                ##################################


                #
                # pasting (Bo0,B,BiN)
                #

                # B : 3 x 3 x i x r

                Bo = np.concatenate((Bo0[:, :, np.newaxis, :], Bo), axis=2)
                Bi = np.concatenate((Bi, BiN[:, :, np.newaxis, :]), axis=2)

                # B : 3 x 3 x i x r

                self[k][&#39;B&#39;] = np.einsum(&#39;xv...,xw...-&gt;vw...&#39;, Bi, Bo)
                #self[k][&#39;B&#39;] = np.einsum(&#39;vx...,xw...-&gt;vw...&#39;, Bi, Bo)

                #BiN = np.array([si[:,-1,:], eth, eph])    # ndim x 3 x Nray
                #self[k][&#39;BiN&#39;]=BiN
                # self[k][&#39;B&#39;]=np.sum(self[k][&#39;Bi&#39;][:2,:2,np.newaxis]*self[k][&#39;Bo&#39;][np.newaxis,:2,:2],axis=1)


            # if los exists
            else :
                self[k][&#39;nstrwall&#39;] = np.array(())
                self[k][&#39;norm&#39;] = np.array(())
                si = np.sqrt(np.sum((self[0][&#39;pt&#39;][:,0]-self[0][&#39;pt&#39;][:,1])**2,axis=0))
                self[k][&#39;si&#39;] = np.vstack((si,0.))
                self[k][&#39;vsi&#39;] = (self[0][&#39;pt&#39;][:,1]-self[0][&#39;pt&#39;][:,0])/si
                self[k][&#39;dis&#39;] = np.array((si))

                vsi = self[k][&#39;vsi&#39;]
                thd = np.arccos(vsi[2])
                phd = np.arctan2(vsi[1], vsi[0])

                self[k][&#39;aod&#39;] = np.vstack((thd, phd))
                self[k][&#39;Bo0&#39;] = np.array(())
                self[k][&#39;scpr&#39;] = np.array(())
                self[k][&#39;theta&#39;] = np.zeros((1,1))

                #
                # The following derivation of the doa is the actual chosen angle convention
                # Those angles are relative to natural spherical coordinates system in the gcs of the scene.
                #
                # for a LOS path :
                #  tha = pi - thd
                #  pha = phd - pi
                #
                #self[k][&#39;aoa&#39;] =  np.vstack((np.pi-thd, phd-np.pi))
                self[k][&#39;aoa&#39;] =  np.vstack((thd,phd))
                E = np.eye(2)[:,:,np.newaxis,np.newaxis]
                self[k][&#39;B&#39;] = np.dstack((E,E))
                ze = np.array([0])
                self[k][&#39;rays&#39;] = np.array(([[0]]))
                self[k][&#39;nbrays&#39;] = 1
                self[k][&#39;rayidx&#39;] = ze
                self.raypt = 1
                self._ray2nbi = ze
        self._luw = np.unique(luw).tolist()
        self.isbased = True</div>

<div class="viewcode-block" id="Rays.fillinter"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.fillinter">[docs]</a>    def fillinter(self, L, append=False):
        &quot;&quot;&quot;  fill ray interactions

        Parameters
        ----------

        L      : Layout
        append : Boolean
            If True append new rays to existing structure


        Notes
        -------

        This method adds the following members

        I : Interactions
        B : IntB
        B0 : IntB

        &quot;&quot;&quot;

        # reinitialized ray pointer if not in append mode
        if not append:
            self.raypt = 0

        # stacked interactions
        I = Interactions(slab=L.sl)

        # rotation basis
        B  = IntB(slab=L.sl)
        B0 = IntB(slab=L.sl)

        # # LOS Interaction
        # Los = IntL()

        # Reflexion
        R = IntR(slab=L.sl)

        # Transmission
        T = IntT(slab=L.sl)

        # Diffraction
        D = IntD(slab=L.sl)

        idx = np.array(())
        if self.los:
            idxts = 1
            nbrayt = 1
        else:
            idxts = 0
            nbrayt = 0


        # Transform dictionnary of slab name to array
        # slv = nx.get_node_attributes(L.Gs, &quot;name&quot;).values()
        # slk = nx.get_node_attributes(L.Gs, &quot;name&quot;).keys()
        # find all material used in simulation
        #uslv = np.unique(L.sla[1:])
        uslv = L.sl.keys()
        #
        # add CEIL and FLOOR
        #
        #uslv = np.hstack((uslv, np.array((&#39;CEIL&#39;, &#39;FLOOR&#39;))))

        # create reverse dictionnary with all material as a key
        # and associated point/segment as a value

        #dsla = {}
        #for s in uslv:
        #    dsla[s] = np.where(s == np.array(slv))[0]

        nsmax = max(L.Gs.node.keys())
        #sla = np.zeros((nsmax+1), dtype=&#39;S20&#39;)

        # array type str with more than 1 character
        # warning use zeros instead of empty because slab zero
        # is virtually used before assigning correct slab to ceil and floor

        #
        # sla is an array of string.
        # each value of Gs node is the index of the corresponding slab
        #

        #sla[slk] = np.array(slv)

        R.dusl = dict.fromkeys(uslv, np.array((), dtype=int))
        T.dusl = dict.fromkeys(uslv, np.array((), dtype=int))

        #to be specified and limited to used wedges
        if hasattr(self,&#39;_luw&#39;):
            D.dusl = dict.fromkeys(self._luw, np.array((), dtype=int))

        # transmission/reflection slab array
        tsl = np.array(())
        rsl = np.array(())
        # diffraction wedge list
        dw = np.array(())

        # loop on group of interactions
        for k in self:

            if k !=0:

                uR = uT = uD = uRf = uRc = 0.

                # structure number (segment or point)
                # nstr : i x r
                nstr = self[k][&#39;sig&#39;][0, 1:-1, :]

                # ityp : i x r
                ityp = self[k][&#39;sig&#39;][1, 1:-1, :]

                # theta : i x r   ( related to interactions )
                theta = self[k][&#39;theta&#39;]

                # (i+1) x r
                si = self[k][&#39;si&#39;]
                # distance in
                s_in = si[0:-1,:]
                # distance in
                s_out = si[1:,:]

                if &#39;diffvect&#39; in self[k]:
                    dvec = self[k][&#39;diffvect&#39;]
                    ldsl = self[k][&#39;diffslabs&#39;]
                    dix = self[k][&#39;diffidx&#39;]


                ## flatten information
                ######################

                # flatten nstr (1 dimension)
                # size1 = i x r
                size1 = nstr.size

                # flatten ityp (method faster than np.ravel() )
                nstrf = np.reshape(nstr,size1,order=&#39;F&#39;)
                itypf = ityp.reshape(size1,order=&#39;F&#39;)
                thetaf = theta.reshape(size1,order=&#39;F&#39;)
                #sif = si[0, :, :].reshape(si[0, :, :].size)

                # ## index creation / already done in rays.locbas
                # ##################
                # # create index for retrieving interactions

                # # integer offset : total size idx

                # idxts = idxts + idx.size

                # idx = idxts + np.arange(ityp.size).reshape(np.shape(ityp),order=&#39;F&#39;)

                # nbray = np.shape(idx)[1]

                # self[k][&#39;rays&#39;] = idx
                # self[k][&#39;nbrays&#39;] = nbray
                # self[k][&#39;rayidx&#39;] = nbrayt + np.arange(nbray)
                # # create a numpy array to relate the ray index to its corresponding
                # # number of interactions

                # # _ray2nbi = np.ones((nbray))

                # #try:
                # #    self._ray2nbi=np.hstack((self._ray2nbi,_ray2nbi))
                # #except:
                # #    self._ray2nbi=_ray2nbi

                # #self._ray2nbi[self[k][&#39;rayidx&#39;]]  = k
                # nbrayt = nbrayt + nbray
                # #self.raypt = self.raypt + self[k][&#39;nbrays&#39;]

                idxf = self[k][&#39;rays&#39;].reshape(self[k][&#39;rays&#39;].size,order=&#39;F&#39;)
                #  (i+1)xr
                # 

                size2 = si[:, :].size
                nbray = self[k][&#39;nbrays&#39;]
                # TODO
                # dirty fix
                # nbray is either an int or an array. why ?
                if type(nbray)==np.ndarray:
                    nbray=nbray[0]

                #  ,(i+1)xr
                # sif = si[:, :].reshape(size2,order=&#39;F&#39;) # TO BE REMOVE
                s_inf = s_in[:, :].reshape(ityp.size,order=&#39;F&#39;)
                s_outf = s_out[:, :].reshape(ityp.size,order=&#39;F&#39;)

                # 2x2,(i+1)xr

                #
                # self[k][&#39;B&#39;] 3 x 3 x i x r
                #
                # first unitary matrix (3x3xr)
                b0 = self[k][&#39;B&#39;][:,:,0,:]
                # first unitary matrix 1:
                # dimension i and r are merged
                b = self[k][&#39;B&#39;][:,:,1:,:].reshape(3, 3, size2-nbray,order=&#39;F&#39;)


                ## find used slab
                ##################
                # find slab type for the rnstr
                # nstrf is a number of slab
                # this is a problem for handling subsegment
                #

                # seek for interactions position
                ################################

                uD  = np.where((itypf == 1))[0]
                uR  = np.where((itypf == 2))[0]
                uT  = np.where((itypf == 3))[0]
                uRf = np.where((itypf == 4))[0]
                uRc = np.where((itypf == 5))[0]

                # assign floor and ceil slab
                ############################

                slT = [ L.Gs.node[x][&#39;name&#39;] for x in nstrf[uT] ]
                slR = [ L.Gs.node[x][&#39;name&#39;] for x in nstrf[uR] ]

                # WARNING
                # in future versions floor and ceil could be different for each cycle.
                # this information would be directly obtained from L.Gs
                # then the two following lines would have to be modified

                slRf = np.array([&#39;FLOOR&#39;]*len(uRf))
                slRc = np.array([&#39;CEIL&#39;]*len(uRc))


                # Fill the used slab
                #####################

                tsl = np.hstack((tsl, slT))
                rsl = np.hstack((rsl, slR, slRf, slRc))
                if &#39;diffvect&#39; in self[k]:
                    dw = np.hstack((dw,self[k][&#39;diffslabs&#39;]))
    ##            for s in uslv:
    ##
    ##                T.dusl[s]=np.hstack((T.dusl[s],len(T.idx) + np.where(sl[uT]==s)[0]))
    ##                R.dusl[s]=np.hstack((R.dusl[s],len(R.idx) + np.where(sl[uR]==s)[0]))
    ##            R.dusl[&#39;FLOOR&#39;]=np.hstack((R.dusl[&#39;FLOOR&#39;],len(R.idx)+len(uR) + np.where(sl[uRf]==&#39;FLOOR&#39;)[0]))
    # R.dusl[&#39;CEIL&#39;]=np.hstack((R.dusl[&#39;CEIL&#39;],len(R.idx)+len(uR)+len(uRf) +
    # np.where(sl[uRc]==&#39;CEIL&#39;)[0]))

                # Basis
                # Hugr issue with B index
                # Friedman version Bs was entering in the index
                # maybe B can have the same index that interactions
                # but this must be managed when evaluation of CIR is made

                # BU 10/4/2013
                # .. todo:  This is no longer idxf the good index
                # why the transposition b is first 2x2x(i+1)xr
                #                             idxf is (ixr)
                #
                # need to check how B is used in eval()
                #
                # Warning
                # -------
                # B.idx refers to an interaction index
                # whereas B0.idx refers to a ray number
                # B.stack(data=b.T, idx=idxf)
                # B0.stack(data=b0.T,idx=self[k][&#39;rayidx&#39;])

                B.stack(data=b.T, idx=idxf)
                B0.stack(data=b0.T,idx=self[k][&#39;rayidx&#39;])
                ### Reflexion
                ############
                ### wall reflexion
                #(theta, s_in,s_out)

                R.stack(data=np.array((thetaf[uR], s_inf[uR], s_outf[uR])).T,
                        idx=idxf[uR])
                # floor reflexion
                R.stack(data=np.array((thetaf[uRf], s_inf[uRf], s_outf[uRf])).T,
                        idx=idxf[uRf])
                # ceil reflexion
                R.stack(data=np.array((thetaf[uRc], s_inf[uRc], s_outf[uRc])).T,
                        idx=idxf[uRc])

                # R.stack(data=np.array((thetaf[uR], sif[uR], sif[uR+1])).T,
                #         idx=idxf[uR])
                # # floor reflexion
                # R.stack(data=np.array((thetaf[uRf], sif[uRf], sif[uRf+1])).T,
                #         idx=idxf[uRf])
                # # ceil reflexion
                # R.stack(data=np.array((thetaf[uRc], sif[uRc], sif[uRc+1])).T,
                #         idx=idxf[uRc])

                ### sl[idxf[uT]]
                # Transmision
                ############
                # (theta, s_in,s_out)
                # T.stack(data=np.array((thetaf[uT], sif[uT], sif[uT+1])).T, idx=idxf[uT])
                T.stack(data=np.array((thetaf[uT], s_inf[uT], s_outf[uT])).T, idx=idxf[uT])

                ###
                #Diffraction
                #phi0,phi,si,sd,N,mat0,matN,beta
                #

                if &#39;diffvect&#39; in self[k]:
                    # self[k][&#39;diffvect&#39;] = ((phi0,phi,beta,N) x (nb_rayxnb_interactions)   )
                    #si and so are stacked at the end of self[k][&#39;diffvect&#39;]
                    #as well:
                    #data =  (6 x (nb_rayxnb_interactions) )
                    # ((phi0,phi,beta,N,sin,sout) x (nb_rayxnb_interactions) )
                    data = np.vstack((self[k][&#39;diffvect&#39;],s_inf[uD],s_outf[uD]))
                    D.stack(data=data.T,idx=self[k][&#39;diffidx&#39;])#idxf[uD])

            elif self.los:
                ze = np.array([0])
                #self[k][&#39;rays&#39;] = np.array(([[0]]))
                #self[k][&#39;nbrays&#39;] = 1
                #self[k][&#39;rayidx&#39;] = ze
                #self.raypt = 1
                #self._ray2nbi=ze
                B.stack(data=np.eye(3)[np.newaxis,:,:], idx=ze)
                B0.stack(data=np.eye(3)[np.newaxis,:,:],idx=ze)

        if len(tsl)&gt;0:
            T.create_dusl(tsl)
        if len(rsl)&gt;0:
            R.create_dusl(rsl)
        if len(dw)&gt;0:
            D.create_dusl(dw)
        # create interactions structure
        self.I = I
        self.I.add([T, R, D])
        # create rotation base B
        self.B = B
        # create rotation base B0
        self.B0 = B0

        self.filled = True</div>

<div class="viewcode-block" id="Rays.eval"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.eval">[docs]</a>    def eval(self,fGHz=np.array([2.4]),bfacdiv=False,ib=[]):
        &quot;&quot;&quot;  field evaluation of rays

        Parameters
        ----------

        fGHz : array
            frequency in GHz
        ib : list of interactions block

        &quot;&quot;&quot;

        #print &#39;Rays evaluation&#39;

        self.fGHz=fGHz

        # evaluation of all interactions
        #
        # core calculation of all interactions is done here
        #
        
        self.I.eval(fGHz)

        # if np.isnan(self.I.I).any():
        #     pdb.set_trace()
        # evaluation of base B  (2x2)
        # B and B0 do no depend on frequency
        # just an axis extension (np.newaxis)
        #pdb.set_trace()

        # 1 x i x 3 x 3
        B  = self.B.data[np.newaxis,...]
        B  = B.swapaxes(2,3)
        # 1 x r x 3 x 3
        B0 = self.B0.data[np.newaxis,...]
        B0  = B0.swapaxes(2,3)

        # Ct : f x r x 3 x 3
        Ct = np.zeros((self.I.nf, self.nray, 3, 3), dtype=complex)

        # delays : ,r
        self.delays = np.zeros((self.nray))

        # dis : ,r
        self.dis = np.zeros((self.nray))

        #nf : number of frequency point
        nf = self.I.nf

        aod= np.empty((2,self.nray))
        aoa= np.empty((2,self.nray))
        # loop on interaction blocks
        if ib==[]:
            ib=self.keys()
        
        # loop over group of interactions
        for l in ib:
            # ir : ray index

            ir = self[l][&#39;rayidx&#39;]
            aoa[:,ir]=self[l][&#39;aoa&#39;]
            aod[:,ir]=self[l][&#39;aod&#39;]
            if l != 0:
                # l stands for the number of interactions
                r = self[l][&#39;nbrays&#39;]
                # dirty fix should not be an array
                if type(r)==np.ndarray:
                    r = r[0]
                # reshape in order to have a 1D list of index
                # reshape ray index
                rrl = self[l][&#39;rays&#39;].reshape(r*l,order=&#39;F&#39;)
                # get the corresponding evaluated interactions
                #
                # reshape error can be tricky to debug.
                #
                # f , r , l , 2 , 2
                A = self.I.I[:, rrl, :, :].reshape(self.I.nf, r, l, 3, 3)
                # get the corresponding unitary matrix B
                # 1 , r , l , 2 , 2
                #Bl = B[:, rrl, :, :].reshape(self.I.nf, r, l, 2, 2,order=&#39;F&#39;)
                Bl = B[:, rrl, :, :].reshape(1, r, l, 3, 3)
                # get the first unitary matrix B0l
                B0l = B0[:,ir,:, :]
                # get alpha
                alpha = self.I.alpha[rrl].reshape(r, l,order=&#39;F&#39;)
                # # get gamma
                gamma = self.I.gamma[rrl].reshape(r, l,order=&#39;F&#39;)
                # # get si0
                si0 = self.I.si0[rrl].reshape(r, l,order=&#39;F&#39;)
                # # get sout
                sout = self.I.sout[rrl].reshape(r, l,order=&#39;F&#39;)

                try:
                    del Z
                except:
                    pass


                #print &quot;\nrays&quot;,ir
                #print &quot;-----------------------&quot;
                ## loop on all the interactions of ray with l interactions
                for i in range(0, l):


    ############################################
    ##                # Divergence factor D
    ###                 not yet implementented
    ############################################
#                    if i == 0:
#                        pdb.set_trace()
#                        D0 = 1./si0[:,1]
#                        rho1 = si0[:,1]*alpha[:,i]
#                        rho2 = si0[:,1]*alpha[:,i]*gamma[:,i]
#                        D =np.sqrt(
#                         ( (rho1 ) / (rho1 + sout[:,i]) )
#                         *( (rho2) / (rho2 + sout[:,i])))
#                        D=D*D0
#                        rho1=rho1+(sout[:,i]*alpha[:,i])
#                        rho2=rho2+(sout[:,i]*alpha[:,i]*gamma[:,i])
#
#   ##                     gerer le loss
#                        if np.isnan(D).any():
#                            p=np.nonzero(np.isnan(D))[0]
#                            D[p]=1./sout[p,1]
#                    else :
#                        D=np.sqrt(
#                         ( (rho1 ) / (rho1 + sout[:,i]) )
#                         *( (rho2) / (rho2 + sout[:,i])))
#
#                        rho1=rho1+(sout[:,i]*alpha[:,i])
#                        rho2=rho2+(sout[:,i]*alpha[:,i]*gamma[:,i])
    ############################################

                    #  A0  (X dot Y)
                    #  |    |     |
                    #  v    v     v
                    ##########################
                    ## B  # I  # B  # I  # B #
                    ##########################
                    #      \_____/   \______/
                    #         |         |
                    #       Atmp(i)   Atmp(i+1)
                    #
                    # Z=Atmp(i) dot Atmp(i+1)

                    #X = A [:, :, i, :, :]
                    #Y = Bl[:, :, i, :, :]
                    # pdb.set_trace()
                    if i == 0:
                    ## First Basis added
                        Atmp = A[:, :, i, :, :]
                        B00 = B0l[:, :,  :, :]
                        Z = np.sum(Atmp[..., :, :, np.newaxis]
                                  *B00[..., np.newaxis, :, :], axis=-2)
                    else:
                        Atmp = A[:, :, i, :, :]
                        BB = Bl[:, :, i-1, :, :]
                        Ztmp = np.sum(Atmp[..., :, :, np.newaxis]
                                  *BB[..., np.newaxis, :, :], axis=-2)


                        Z = np.sum(Ztmp[..., :, :, np.newaxis]
                                  *Z[..., np.newaxis, :, :], axis=-2)

                    if i == l-1:
                        BB = Bl[:, :, i, :, :]
                        Z = np.sum(BB[..., :, :, np.newaxis]
                                  *Z[..., np.newaxis, :, :], axis=-2)


                # fill the C tilde MDA

                Ct[:,ir, :, :] = Z[:, :, :, :]

                #
                if bfacdiv:
                    Ct[:,ir, :, :] = Ct[:, ir, :, :]*1./(self[l][&#39;dis&#39;][np.newaxis, :, np.newaxis, np.newaxis])
                else:
                    Ct[:,ir, :, :] = Ct[:, ir, :, :]*1./(self[l][&#39;dis&#39;][np.newaxis, :, np.newaxis, np.newaxis])
                self.delays[ir] = self[l][&#39;dis&#39;]/0.3
                self.dis[ir] = self[l][&#39;dis&#39;]
        #
        # true LOS when no interaction
        #
        if self.los:
            Ct[:,0, :, :]= np.eye(3,3)[None,None,:,:]
            #self[0][&#39;dis&#39;] = self[0][&#39;si&#39;][0]
            # Fris
            Ct[:,0, :, :] = Ct[:,0, :, :]*1./(self[0][&#39;dis&#39;][None, :, None, None])
            self.delays[0] = self[0][&#39;dis&#39;]/0.3
            self.dis[0] = self[0][&#39;dis&#39;]


        # To be corrected in a future version
        #
        #  Ct : nf , Nray , theta , phi 
        #
        #  to 
        #
        #  Ct : Nray x nf , theta , phi 
        #
        Ct = np.swapaxes(Ct, 1, 0)

        #c11 = Ct[:,:,0,0]
        #c12 = Ct[:,:,0,1]
        #c21 = Ct[:,:,1,0]
        #c22 = Ct[:,:,1,1]
        
        c11 = Ct[:,:,1,1]
        c12 = Ct[:,:,1,2]
        c21 = Ct[:,:,2,1]
        c22 = Ct[:,:,2,2]


        #
        # Construction of the Ctilde propagation channel structure
        #
        Cn = Ctilde()

        # Cn.Cpp = bs.FUsignal(self.I.fGHz, c11)
        # Cn.Cpt = bs.FUsignal(self.I.fGHz, c12)
        # Cn.Ctp = bs.FUsignal(self.I.fGHz, c21)
        # Cn.Ctt = bs.FUsignal(self.I.fGHz, c22)
        Cn.Ctt = bs.FUsignal(self.I.fGHz, c11)
        Cn.Ctp = bs.FUsignal(self.I.fGHz, c12)
        Cn.Cpt = bs.FUsignal(self.I.fGHz, c21)
        Cn.Cpp = bs.FUsignal(self.I.fGHz, c22)

        Cn.nfreq = self.I.nf
        Cn.nray = self.nray
        Cn.tauk = self.delays
        Cn.fGHz = self.I.fGHz
        # r x 2
        Cn.tang = aod.T
        Cn.tangl = aod.T
        # r x 2
        #
        # recover angle of arrival convention 
        #
        Cn.rang  = np.hstack([np.pi-aoa.T[:,[0]],aoa.T[:,[1]]-np.pi]) 
        Cn.rangl = np.hstack([np.pi-aoa.T[:,[0]],aoa.T[:,[1]]-np.pi])
        # add aoa and aod

        self.evaluated = True

        return(Cn)</div>


<div class="viewcode-block" id="Rays.rayfromseg"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.rayfromseg">[docs]</a>    def rayfromseg(self,ls):
        &#39;&#39;&#39; DEPRECATED 
            use raysfromnstr instead
        &#39;&#39;&#39;
        DeprecationWarning(&#39;function name update: use raysfromnstr instead&#39;)
        return self.rayfromnstr(ls)</div>

<div class="viewcode-block" id="Rays.rayfromnstr"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.rayfromnstr">[docs]</a>    def rayfromnstr(self,ls):
        &quot;&quot;&quot; returns the indexes of rays for a given interaction list
        &quot;&quot;&quot;

        if not isinstance(ls,list):
            ls = [ls]

        lur = []
        for k in self:
            aib = self[k][&#39;sig&#39;][0,...]
            for i in ls :
                # import ipdb
                # ipdb.set_trace()
                ui, ur = np.where(aib == i)
                lur.extend(self[k][&#39;rayidx&#39;][ur].tolist())
        return np.sort(lur)</div>

<div class="viewcode-block" id="Rays.rayfromdelay"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.rayfromdelay">[docs]</a>    def rayfromdelay(self,t0=0,t1=[]):
        &quot;&quot;&quot; returns the indexes of rays between 2 timestamps t0 and t1
        &quot;&quot;&quot;
        if t1 == []:
            t1 = self.delays.max()
        u = np.where((self.delays&gt;t0) &amp; (self.delays&lt;t1))[0]
        return u</div>





<div class="viewcode-block" id="Rays.ray2slab"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.ray2slab">[docs]</a>    def ray2slab(self,L,ir):
        &quot;&quot;&quot; return the slabs for a given interaction index 


            Parameters
            ----------

            L : Layout
            ir : interaction block

            Returns
            -------

            numpy array of slabs strings at the shape (ir,r)
            ir : number of interactions ( of the interaction block)
            r : number of rays

        &quot;&quot;&quot;

        v=np.vectorize( lambda t: L.Gs.node[t][&#39;name&#39;] if (t!=0) and (t&gt;0) else &#39;_&#39;)
        return v(self[ir][&#39;sig&#39;][0])</div>


<div class="viewcode-block" id="Rays.ray"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.ray">[docs]</a>    def ray(self, r):
        &quot;&quot;&quot; returns the index of interactions of r

        Parameters
        ----------

        r : integer
            ray index

        Returns
        -------

        ir : nd.array
            index of interactions of r

        Examples
        --------

        &quot;&quot;&quot;
        raypos = np.nonzero(self[self._ray2nbi[r]][&#39;rayidx&#39;] == r)[0]
        return(self[self._ray2nbi[r]][&#39;rays&#39;][:,raypos][:,0])</div>

<div class="viewcode-block" id="Rays.ir2a"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.ir2a">[docs]</a>    def ir2a(self,ir):
        &quot;&quot;&quot; index ray 2 address ray

        Parameters
        ----------
        ir : integer
        
        Returns
        -------
        (ni,ux) : tuple address (group of interactions, index)

        &quot;&quot;&quot;
        assert ir &lt; self.nray, &quot;wrong ray index&quot;
        ni = self._ray2nbi[ir]
        ur = np.where(self[ni][&#39;rayidx&#39;]==ir)[0][0]
        return(ni,ur)</div>

<div class="viewcode-block" id="Rays.a2ir"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.a2ir">[docs]</a>    def a2ir(self,t):
        &quot;&quot;&quot;  address ray 2 index ray
        
        Parameters
        ----------
        t = (ni,ux) : tuple address (group of interactions, index)
            ray address  
        
        Returns
        -------
        ir : integer
            ray index  

        &quot;&quot;&quot;
        assert t[0] in self.keys(), &quot;wrong number of interactions&quot;
        ir = self[t[0]][&#39;rayidx&#39;][t[1]]
        return(ir)</div>


<div class="viewcode-block" id="Rays.ray2ityp"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.ray2ityp">[docs]</a>    def ray2ityp(self,r):
        &quot;&quot;&quot; return interaction type for a given ray


        Parameters
        ----------

        r : integer
        ray index


        Returns
        -------
        
        lt : list
            list of type of interactions

        &quot;&quot;&quot;

        di = {1:&#39;D&#39;,2:&#39;R&#39;,3:&#39;T&#39;,4:&#39;R&#39;,5:&#39;R&#39;}
        sig = self.ray2sig(r)
        sig  = sig[1,1:-1]
        return [di[s] for s in sig]</div>


<div class="viewcode-block" id="Rays.ray2nbi"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.ray2nbi">[docs]</a>    def ray2nbi(self,r):
        &quot;&quot;&quot; Get interaction block/number of interactions of a given ray

        Parameters
        ----------

        r : integer
            ray index

        Returns
        -------

        nbi : int
            interaction block number
        &quot;&quot;&quot;
        i = self._ray2nbi[r]
        return i </div>

<div class="viewcode-block" id="Rays.ray2iidx"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.ray2iidx">[docs]</a>    def ray2iidx(self,ir):
        &quot;&quot;&quot; Get interactions index of a given ray

        Parameters
        ----------

        ir : integer
            ray index

        Returns
        -------

        iidx : array
            interaction index 
        &quot;&quot;&quot;
        unbi = self.ray2nbi(ir)
        ur = np.where(self[unbi][&#39;rayidx&#39;]==ir)[0]
        return self[unbi][&#39;rays&#39;][:,ur]</div>


<div class="viewcode-block" id="Rays.ray2sig"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.ray2sig">[docs]</a>    def ray2sig(self,ir):
        &quot;&quot;&quot; get signature to corresponding ray
        &quot;&quot;&quot;
        unbi = self.ray2nbi(ir)
        ur = np.where(self[unbi][&#39;rayidx&#39;]==ir)[0]
        return self[unbi][&#39;sig&#39;][:,:,ur].squeeze()</div>

<div class="viewcode-block" id="Rays.ray2sig2d"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.ray2sig2d">[docs]</a>    def ray2sig2d(self,ir):
        &quot;&quot;&quot; get signature to corresponding ray
        &quot;&quot;&quot;
        sig = self.ray2sig(ir)
        sig = sig.squeeze()
        sig = sig[:,1:-1] #Â remove extremal 0
        unfc = np.where(sig[1,:]&lt;4)[0]#Â index floor cell
        sig2d = sig[:,unfc]
        return sig2d</div>

<div class="viewcode-block" id="Rays.ray2inter"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.ray2inter">[docs]</a>    def ray2inter(self,ir,L,Si):
        &quot;&quot;&quot; get interaction list (Gi style) from a ray

        Parameters
        ----------

        ir : ray index
        L : Layout
        Si : Signatures object

        &quot;&quot;&quot;
        sig = self.ray2sig2d(ir)
        return Si.sig2inter(L,sig)</div>


<div class="viewcode-block" id="Rays.slab_nb"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.slab_nb">[docs]</a>    def slab_nb(self, ir):
        &quot;&quot;&quot; returns the slab numbers of r

        Parameters
        ----------

        ir : integer
            ray index

        Returns
        -------

        isl : slabs number


        &quot;&quot;&quot;

        raypos = np.nonzero(self[self._ray2nbi[ir]][&#39;rayidx&#39;] == ir)[0]
        return(self[self._ray2nbi[ir]][&#39;sig&#39;][0,1:-1,raypos[0]])</div>

<div class="viewcode-block" id="Rays.vis"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.vis">[docs]</a>    def vis(self,ir,L):
        typ = [&#39;Tx&#39;] + self.typ(ir) + [&#39;Rx&#39;] 
        slab_nb = self.slab_nb(ir)
        slab_nb = np.insert(slab_nb,0,0)
        slab_nb = np.insert(slab_nb,len(slab_nb),0)
        nbi = self._ray2nbi[ir]
        raypos = np.nonzero(self[nbi][&#39;rayidx&#39;] == ir)[0]
        pt = self[nbi][&#39;pt&#39;][:,:,raypos]
        tz  = pt[2].ravel()
        slab = [ L.Gs.node[x][&#39;name&#39;] for x in slab_nb if x &gt; 0]
        st = &#39;&#39;
        for t in typ:
            st = st + t+&#39;      &#39; 
        print(st)
        st = &#39;&#39;
        for s in slab_nb:
            st = st + str(s)+&#39;     &#39; 
        print(st)
        st = &#39;&#39;
        for z in tz:
            st = st + str(z)+&#39;     &#39; 
        print(st)
        print(slab)</div>

<div class="viewcode-block" id="Rays.typ"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.typ">[docs]</a>    def typ(self, ir,fromR=True):
        &quot;&quot;&quot; returns interactions list type of a given ray

        Parameters
        ----------

        ir : integer
            ray index
        fromR : bool
            True : get information from signature in R
            False: get information in R.I

        &quot;&quot;&quot;
        #
        # In this function we can see that the ceil and floor 
        # are hard coded as reflection. This is going to evolve 
        # for implementation of multi floor 
        #
        if fromR:
            di = {0:&#39;L&#39;,1:&#39;D&#39;,2:&#39;R&#39;,3:&#39;T&#39;,4:&#39;R&#39;,5:&#39;R&#39;}
            nbi = self._ray2nbi[ir]
            raypos = np.nonzero(self[nbi][&#39;rayidx&#39;] == ir)[0]
            inter = self[nbi][&#39;sig&#39;][1,1:-1,raypos][0]
            return [di[i] for i in inter]
        else:
            a = self.ray(r)
            return(self.I.typ[a])</div>

<div class="viewcode-block" id="Rays.dump"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.dump">[docs]</a>    def dump(self,ir,L,ifGHz=0,filename=&#39;dumpray.ray&#39;):
        &quot;&quot;&quot; dump the full information of a ray in a file 
        &quot;&quot;&quot;
        nbi = self._ray2nbi[ir]  
        ur = np.where(self[nbi][&#39;rayidx&#39;]==ir)[0][0]
        fd=open(filename,&#39;w&#39;)
        fd.write(&#39;ray #&#39;+str(ir)+&#39;\n&#39;)
        fd.write(str(ur)+ &#39; th ray from the group of &#39; + str(nbi)+&#39; Interactions&#39; +&#39;\n&#39;)
        cy_a = L.pt2cy(self.pTx)
        cy_b = L.pt2cy(self.pRx)

        #fd.write(&#39;Tx #&#39;+str(self.pTx)+&#39;\n&#39;)
        #fd.write(&#39;Rx #&#39;+str(self.pRx)+&#39;\n&#39;)
        if self.evaluated:
            ray = self.ray(ir)
            typ = self.typ(ir)
            slabnb = self.slab_nb(ir)
            fd.write(&#39;   ray #&#39;+str(ray)+&#39;\n&#39;)
            #fd.write(&#39;   typ #&#39;+str(typ)+&#39;\n&#39;)
            fd.write(&#39;   slab #&#39;+str(slabnb)+&#39;\n&#39;)
        for k in range(nbi+2):
            if k==0:
                fd.write(&#39;Tx  :        &#39;)
            elif k==(nbi+1):
                fd.write(&#39;Rx  :        &#39;)
            else:
                six = slabnb[k-1]
                if six==0:
                    slabname=&#39;FLOOR&#39;
                    cyc =[-2,-3]
                else:
                    slabname = L.Gs.node[six][&#39;name&#39;]
                    cyc = L.Gs.node[six][&#39;ncycles&#39;]
                if typ[k-1]==&#39;T&#39;:
                    fd.write(&#39;T &#39;+slabname +&#39;       (&#39;+str(six)+&#39;,&#39;+str(cyc[0])+&#39;,&#39;+str(cyc[1])+&#39;)&#39;)
                if typ[k-1]==&#39;R&#39;:
                    fd.write(&#39;R &#39;+slabname +&#39;       (&#39;+str(six)+&#39;,)&#39;)
                if typ[k-1]==&#39;D&#39;:
                    fd.write(&#39;D (&#39;+str(six)+&#39;) :&#39;)

            fd.write(str(self[nbi][&#39;pt&#39;][:,k,ur])+&#39;\n&#39; )
            if k==0:
                fd.write(&#39;  &#39;+str(cy_a)+&#39;\n&#39;)
            elif k==(nbi+1):
                fd.write(&#39;  &#39;+str(cy_b)+&#39;\n&#39;)
            if k==0:
                for l in range(3):
                    if l&lt;2:
                        fd.write(&#39;\t&#39;+str(self[nbi][&#39;Bo0&#39;][l,:,ur])
                     +&#39;\t&#39;+str(self[nbi][&#39;B&#39;][l,:,0,ur])+&#39;\n&#39;)
                    else:
                        fd.write(&#39;\t&#39;+str(self[nbi][&#39;Bo0&#39;][l,:,ur]) +&#39;\n&#39;)
            elif k==(nbi+1):
                for l in range(3):
                    fd.write(&#39;\t&#39;+str(self[nbi][&#39;BiN&#39;][l,:,ur])+&#39;\n&#39;)
            else:
                for l in range(3):
                    if l&lt;2:
                        fd.write(&#39;\t&#39;+str(self[nbi][&#39;Bi&#39;][l,:,k-1,ur])+&#39;\t&#39;+
                              str(self[nbi][&#39;Bo&#39;][l,:,k-1,ur])
                         +&#39;\t&#39;+str(self[nbi][&#39;B&#39;][l,:,k-1,ur])+&#39;\n&#39;)
                    else:
                        fd.write(&#39;\t&#39;+str(self[nbi][&#39;Bi&#39;][l,:,k-1,ur])+&#39;\t&#39;+
                              str(self[nbi][&#39;Bo&#39;][l,:,k-1,ur])+&#39;\n&#39;)


        fd.close()</div>


<div class="viewcode-block" id="Rays.info"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.info">[docs]</a>    def info(self,ir,ifGHz=0,bB=True,matrix=False):
        &quot;&quot;&quot; provides information for a given ray r

        Parameters
        ----------

        ir : int
            ray index
        ifGHz : int
            frequency index
        bB: boolean
            display Basis
        matrix :
            display matrix 
        &quot;&quot;&quot;

        if self.evaluated:
            print(&#39;-------------------------&#39;)
            print(&#39;Informations of ray #&#39;, ir)
            print(&#39;-------------------------\n&#39;)

            ray = self.ray(ir)
            typ = self.typ(ir)
            slabnb = self.slab_nb(ir)
            # if there is a diffraction, phi0, phi, beta are shown
            if &#39;D&#39; in typ:
                diff =True
                print(&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7}, {5:10}, {6:10}, {7:4}, {8:4}, {9:4}&#39;\
                        .format(&#39;Index&#39;,
                                &#39;type&#39;,
                                &#39;slab&#39;, 
                                &#39;nstr&#39; ,
                                &#39;th(rad)&#39;,
                                &#39;alpha&#39;,
                                &#39;gamma2&#39;,
                                &#39;phi0&#39;,
                                &#39;phi&#39;,
                                &#39;beta&#39;))
            else :
                diff =False
                print(&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7}, {5:10}, {6:10}&#39;\
                     .format(&#39;Index&#39;,
                        &#39;type&#39;,
                        &#39;slab&#39;,
                        &#39;nstr&#39;,
                        &#39;th(rad)&#39;,
                        &#39;alpha&#39;,
                        &#39;gamma2&#39;))
            print(&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7.2}, {5:10.2}, {6:10.2}&#39;\
                  .format(ir, &#39;B0&#39;,&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;))

            for iidx, i in enumerate(typ):
                # import ipdb
                # ipdb.set_trace()
                if i == &#39;T&#39; or i == &#39;R&#39; or i ==&#39;D&#39;:
                    I = getattr(self.I, i)
                    for slab in I.dusl.keys():
    #                    print slab
                        midx = I.dusl[slab]
    #                    print midx
                        Iidx = np.array((I.idx))[midx]

                        if i != &#39;D&#39;:
                            th = I.data[I.dusl[slab], 0]
                            gamma = I.gamma[midx]
                            alpha = I.alpha[midx]
                        else : 
                            # from IPython.core.debugger import Tracer
                            # Tracer()()
                            th=[&#39;-&#39;]*max(max(Iidx),1)
                            gamma = [&#39;NC&#39;]*max(max(Iidx),1)
                            alpha = [&#39;NC&#39;]*max(max(Iidx),1)
                            udiff = np.where(self.I.D.idx==ray[iidx])[0]
                            phi0 = self.I.D.phi0[udiff][0]
                            phi=self.I.D.phi[udiff][0]
                            beta=self.I.D.beta[udiff][0]
                        for ii, Ii in enumerate(Iidx):
                            if Ii == ray[iidx]:
                                if i==&#39;D&#39;: 
                                    print(&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7.2}, {5:10}, {6:10}, {7:3.4}, {8:3.4}, {9:3.4}&#39;\
                                    .format(Ii, i, slab, slabnb[iidx], th[ii], alpha[ii], gamma[ii],phi0,phi,beta))
                                else:
                                    print(&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7.2}, {5:10.2}, {6:10.2}&#39;\
                                    .format(Ii, i, slab, slabnb[iidx], th[ii], alpha[ii], gamma[ii]))

                    else:
                        if bB:
                            print(&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7.2}, {5:10.2}, {6:10.2}&#39;.format(ray[iidx], &#39;B&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;))
                #              print &#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:10}, {5:10}&#39;.format(ray[iidx], i, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;)

            if matrix:
                print(&#39;\n----------------------------------------&#39;)
                print(&#39; Matrix of ray #&#39;, ir, &#39;at f=&#39;, self.I.fGHz[ifGHz])
                print(&#39;----------------------------------------&#39;)
                lmat = []
                ltran = []
                if bB:
                    print(&#39;rotation matrix#&#39;, &#39;type: B0&#39;)

                    B0 = self.B0.data[ir,:,:]
                    addr = self.ir2a(ir)
                    Bo0 = self[addr[0]][&#39;Bo0&#39;][:,:,addr[1]] 
                    Bi1 = self[addr[0]][&#39;Bi&#39;][:,:,0,addr[1]] 
                    U  = np.dot(Bi1.T,Bo0)
                    assert np.allclose(B0,U) 
                    lmat.append(B0)
                    ltran.append(B0)
                    print(B0)
                for iidx, i in enumerate(typ):
                    print(&#39;interaction #&#39;, ray[iidx], &#39;type:&#39;, i)
                    # f x l x 2 x 2
                    I = self.I.I[ifGHz, ray[iidx], :, :]
                    print(I)
                    lmat.append(I)

                    if bB:
                        print(&#39;rotation matrix#&#39;,[ray[iidx]], &#39;type: B&#39;)
                        B = self.B.data[ray[iidx], :, :]
                        print(B) 
                        lmat.append(B)
                        ltran.append(B)
                # evaluate matrix product
                PM0=np.eye(3)
                PM1=np.eye(3)
                for m in lmat[::-1]:
                    PM0=np.dot(PM0,m)
                for m in ltran[::-1]:
                    PM1=np.dot(PM1,m)
                print(&quot;matrix product with interactions (dB)&quot;)
                print(20*np.log10(np.abs(PM0[1,1])),&#39;  &#39;,20*np.log10(np.abs(PM0[1,2])))
                print(20*np.log10(np.abs(PM0[2,1])),&#39;  &#39;,20*np.log10(np.abs(PM0[2,2])))
                print(&quot;matrix product without interactions (dB)&quot;)
                print(20*np.log10(np.abs(PM1[1,1])),&#39;  &#39;,20*np.log10(np.abs(PM1[1,2])))
                print(20*np.log10(np.abs(PM1[2,1])),&#39;  &#39;,20*np.log10(np.abs(PM1[2,2])))
                return(PM0)

            else:
                print(&#39;\nto display matrix, use matrix=True on call&#39;)
        else:
            print(&#39;Rays have not been evaluated yet&#39;)</div>

<div class="viewcode-block" id="Rays.signature"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.signature">[docs]</a>    def signature(self, u , typ=&#39;full&#39;):
        &quot;&quot;&quot; extract ray signature

        Parameters
        ----------

        u : tuple orr int 
            if tuple addr 
            if int index

        Returns
        -------

        sig : ndarray

        Notes
        -----

        Signature of a ray is store as a member

        r[nint][&#39;sig&#39;]

        &quot;&quot;&quot;
        if type(u)==tuple:
            addr = u 
        else:
            addr = self.ir2a(u) 
        if typ==&#39;full&#39;:
            sig = self[addr[0]][&#39;sig&#39;][:,:,addr[1]]
        else:
            pass
        return(sig)</div>

<div class="viewcode-block" id="Rays.show3d"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.show3d">[docs]</a>    def show3d(self,
               ray,
               bdis=True,
               bbas=False,
               bstruc=True,
               col=np.array([1, 0, 1]),
               id=0,
               linewidth=1):
        &quot;&quot;&quot; plot a set of 3D rays

        Parameters
        ----------

        ray :
        block : int
            interaction block
        bdis : Boolean
            if False return .vect filename (True)
        bbas : Boolean
            display local basis (False)
        bstruc : Boolean
            display structure (True)
        col  : ndarray() 1x3
            color of the ray  ([1,0,1])
        id   : Integer
            id of the ray (default 0)
        linewidth : Integer
            default 1

        &quot;&quot;&quot;

        filerac = pyu.getlong(&quot;ray&quot; + str(id), pstruc[&#39;DIRGEOM&#39;])
        _filerac = pyu.getshort(filerac)
        filename_list = filerac + &#39;.list&#39;
        filename_vect = filerac + &#39;.vect&#39;

        try:
            fo = open(filename_vect, &quot;w&quot;)
        except:
            raise NameError(filename)

        fo.write(&quot;appearance { linewidth %d }\n&quot; % linewidth)

        fo.write(&quot;VECT\n&quot;)

        fo.write(&quot;1 %d 1\n\n&quot; % len(ray[0, :]))
        fo.write(&quot;%d\n&quot; % len(ray[0, :]))
        fo.write(&quot;1\n&quot;)
        for i in range(len(ray[0, :])):
            fo.write(&quot;%g %g %g\n&quot; % (ray[0, i], ray[1, i],
                                     ray[2, i]))
        # fo.write(&quot;%d %d %d 0\n&quot; % (col[0],col[1],col[2]))
        fo.write(&quot;%g %g %g 0\n&quot; % (col[0], col[1], col[2]))
        fo.close()

        #
        # Ajout des bases locales
        #


        fo = open(filename_list, &quot;w&quot;)
        fo.write(&quot;LIST\n&quot;)
        fo.write(&quot;{&lt;&quot; + filename_vect + &quot;}\n&quot;)
        if (bstruc):
            # fo.write(&quot;{&lt;strucTxRx.off}\n&quot;)
            fo.write(&quot;{&lt;&quot; + _filestr + &quot;.off}\n&quot;)
        filename = filename_list
        fo.close()

        if (bdis):
        #
        # Geomview Visualisation
        #
            chaine = &quot;geomview -nopanel -b 1 1 1 &quot; + filename + \
                &quot; 2&gt;/dev/null &amp;&quot;
            os.system(chaine)
        else:
            return(filename)</div>

    def _show3(self,L=[],rlist=[],newfig=False,cmap=&#39;hot&#39;,**kwargs):
        &quot;&quot;&quot; plot 3D rays in environment using Mayavi

        Parameters
        ----------

        L : Layout object
            Layout to be displayed
        rlist : list
            list of index rays
        newfig : boolean (default: False)
            if true create a new mayavi figure
            else : use the current
        ER: Ray energy 

        &quot;&quot;&quot;

        if newfig:
            mlab.clf()
            f = mlab.figure(bgcolor=(1, 1, 1), fgcolor=(0, 0, 0))
        else :
            f = mlab.gcf()
            # view=mlab.view()


        if L != []:
            try:
                L._filename
            except:
                raise NameError(&#39;L argument must be a layout object&#39;)

            L._show3()

        if &#39;ER&#39; in kwargs:
            ER = kwargs[&#39;ER&#39;]
            color_range = np.linspace( 0, 1., len(ER))#np.linspace( 0, np.pi, len(ER))
            uER = ER.argsort()[::-1]
            colors= color_range[uER]

        if rlist ==[]:
            nbi = self.keys()
            for i in nbi:
                r = range(np.shape(self[i][&#39;pt&#39;])[2])
                ridx = self[i][&#39;rayidx&#39;]
                # number of rays
                nbr = len(r) 
                # current number of interactions
                cnbi = i + 2

                # import ipdb
                # ipdb.set_trace()
                pt = self[i][&#39;pt&#39;][:,:,r].reshape(3,cnbi*nbr,order=&#39;F&#39;)
                l0 = np.array([np.arange(0,cnbi-1)+k*cnbi for k in range(nbr)]).ravel()
                l1 = l0+1
                connection = np.vstack((l0,l1)).T
                if &#39;ER&#39; in kwargs:
                    rc = np.repeat(colors[ridx],cnbi)
                    rc[::cnbi]=0
                    src = mlab.pipeline.scalar_scatter(pt[0,:], pt[1,:], pt[2,:],rc,colormap=cmap)
                else: 
                    src = mlab.pipeline.scalar_scatter(pt[0,:], pt[1,:], pt[2,:])

                src.mlab_source.dataset.lines=connection
                src.update()
                lines = mlab.pipeline.stripper(src)
                mlab.pipeline.surface(lines,opacity=0.5,colormap=cmap)
                f.children[-1].name=&#39;Rays with &#39; + str(i) + &#39;interactions&#39;
        else :

            nbi = self._ray2nbi[rlist]
            nr = np.array((nbi,rlist))
            unb = np.unique(nr[0,:])
            unr = {int(i):np.where(nr[0,:]==i)[0] for i in unb}

            for i in unb:
                raynb = (nr[1,unr[i]]).astype(int)
                nbr=len(raynb)
                ptidx = [np.where(self[i][&#39;rayidx&#39;]==x)[0][0] for x in raynb]
                # current number of interactions
                cnbi = i + 2
  
                pt = self[i][&#39;pt&#39;][:,:,ptidx].reshape(3,cnbi*nbr,order=&#39;F&#39;)

                # lines = np.arange(cnbi*nbr).reshape(cnbi,nbr)
                lines = np.arange(cnbi*nbr).reshape(nbr,cnbi)

                # mesh = tvtk.PolyData(points=pt.T, polys=lines)
                mesh = tvtk.PolyData(points=pt.T, polys=lines)
                mlab.pipeline.surface(mlab.pipeline.extract_edges(mesh),
                                                     color=(0, 0, 0), )
                f.children[-1].name=&#39;Rays with &#39; + str(int(i)) + &#39;interactions&#39;

        # mlab.view(view[0],view[1],view[2],view[3])
        return(f)

<div class="viewcode-block" id="Rays.show3"><a class="viewcode-back" href="../../../api/pylayers.antprop.rays.Rays.html#pylayers.antprop.rays.Rays.show3">[docs]</a>    def show3(self,
              L=[],
              bdis=True,
              bstruc=True,
              bbasi = False,
              bbaso = False,
              id=0,
              ilist=[],
              raylist=[],centered=True):
        &quot;&quot;&quot; plot 3D rays within the simulated environment

        Parameters
        ----------

        bdis : boolean
            True
        bstruc : boolean
            True
        bbasi : boolean
            display input basis of each interaction of rays
        bbaso : boolean
            display ouput basis of each interaction of rays
        id : int
        L : Layout object
            Layout to be displayed
        ilist : list of group of interactions
        raylist : list of index rays
        centered : boolean
            if True center the layout before display


        &quot;&quot;&quot;

        try:
            L._filename
        except:
            raise NameError(&#39;L argument must be a layout object&#39;)

        if not centered:
            pg=np.array([[0],[0],[0]])

        strucname= L._filename.split(&#39;.&#39;)[0]
        pg = L.geomfile(centered=centered)
        pg = np.hstack((pg,0.)).reshape(3,1)

        if ilist == []:
            ilist = self.keys()
        pTx = self.pTx.reshape((3, 1))-pg
        pRx = self.pRx.reshape((3, 1))-pg
        filename = pyu.getlong(&quot;grRay&quot; + str(id) + &quot;.list&quot;, pstruc[&#39;DIRGEOM&#39;])
        fo = open(filename, &quot;w&quot;)
        fo.write(&quot;LIST\n&quot;)
        if bstruc:
            fo.write(&quot;{&lt;&quot;+strucname+&quot;.off}\n&quot;)
            if bbasi:
                if not self.isbased:
                    raise NameError(&#39;Bases have not been computed (self.locbas(Layout)&#39;)
                else:   
                    base_listi = geu.Geomlist(&#39;baselisti&#39;,clear=True)
                    base_listi.append(&quot;LIST\n&quot;)
            if bbaso:
                if not self.isbased:
                    raise NameError(&#39;Bases have not been computed (self.locbas(Layout)&#39;)
                else:   
                    base_listo = geu.Geomlist(&#39;baselisto&#39;,clear=True)
                    base_listo.append(&quot;LIST\n&quot;)

            # fo.write(&quot;{&lt;strucTxRx.off}\n&quot;)

            k = 0
            for i in ilist:
                if raylist == []:
                    rlist = range(np.shape(self[i][&#39;pt&#39;])[2])
                else:
                    rlist = raylist
                for j in rlist:
                    ray = np.hstack((pTx,np.hstack((self[i][&#39;pt&#39;][:, :, j]-pg, pRx))))
                    # ray = rays[i][&#39;pt&#39;][:,:,j]
                    col = np.array([0, 0, 0])
                    # print ray
                    fileray = self.show3d(ray=ray, bdis=False,
                                          bstruc=False, col=col, id=k)
                    k += 1
                    fo.write(&quot;{&lt; &quot; + fileray + &quot; }\n&quot;)
                    if bbasi:
                        for inter in range(i):
                            filebi = &#39;bi_&#39; + str(j) + &#39;_&#39; + str(i) + &#39;_&#39; +str(inter)
                            basi = geu.GeomVect(filebi)
                            basi.geomBase(self[i][&#39;Bi&#39;][:,:,inter,j],pt=self[i][&#39;pt&#39;][:,inter+1,j]-pg[:,0])
                            base_listi.append(&quot;{&lt;&quot; + filebi +&#39;.vect&#39; &quot;}\n&quot;)
                        filebi = &#39;bi_&#39; + str(j) + &#39;_&#39; + str(i) + &#39;_&#39; +str(inter-1)
                        basi = geu.GeomVect(filebi)
                        basi.geomBase(self[i][&#39;BiN&#39;][:,:,j],pt=self[i][&#39;pt&#39;][:,-1,j]-pg[:,0])
                        base_listi.append(&quot;{&lt;&quot; + filebi +&#39;.vect&#39; &quot;}\n&quot;)
                    if bbaso:
                        for inter in range(i):
                            filebo = &#39;bo_&#39; + str(j) + &#39;_&#39; + str(i) + &#39;_&#39; +str(inter)
                            baso = geu.GeomVect(filebo)
                            baso.geomBase(self[i][&#39;Bo&#39;][:,:,inter,j],pt=self[i][&#39;pt&#39;][:,inter+1,j]-pg[:,0])
                            base_listo.append(&quot;{&lt;&quot; + filebo +&#39;.vect&#39; &quot;}\n&quot;)
                        filebo = &#39;bo_&#39; + str(j) + &#39;_&#39; + str(i) + &#39;_&#39; +str(inter+1)
                        baso = geu.GeomVect(filebo)
                        baso.geomBase(self[i][&#39;Bo0&#39;][:,:,j],pt=self[i][&#39;pt&#39;][:,0,j]-pg[:,0])
                        base_listo.append(&quot;{&lt;&quot; + filebo +&#39;.vect&#39; &quot;}\n&quot;)
            if bbasi:
                fo.write(&quot;{&lt; &quot; + &quot;baselisti.list}\n&quot;)
            if bbaso:  
                fo.write(&quot;{&lt; &quot; + &quot;baselisto.list}\n&quot;)

        fo.close()
        if (bdis):
            chaine = &quot;geomview &quot; + filename + &quot; 2&gt;/dev/null &amp;&quot;
            os.system(chaine)
        else:
            return(filename)</div></div>


if __name__ == &quot;__main__&quot;:
    doctest.testmod()
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team.
      Last updated on Jan 28, 2019.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>