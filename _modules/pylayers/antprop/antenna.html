

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.antprop.antenna &mdash; PyLayers</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_issue314.html">Exemple of issue 314</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_dakar.html">Outdoor Radio Coverage with Deygout Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_cover.html">Outdoor Radio Coverage with Deygout Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction_polar.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pylayers.antprop.antenna</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.antprop.antenna</h1><div class="highlight"><pre>
<span></span># -*- coding:Utf-8 -*-
&quot;&quot;&quot;
.. currentmodule:: pylayers.antprop.antenna

.. autosummary::
    :members:

&quot;&quot;&quot;
from __future__ import print_function
import doctest
import os
import glob
import re
import pdb
import sys
import numpy as np
import scipy.linalg as la
import matplotlib.pylab as plt
from scipy import io
from matplotlib import rc
from matplotlib import cm  # colormaps
from mpl_toolkits.mplot3d import axes3d
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.ticker import MaxNLocator
from scipy.special import sici, fresnel
import pandas as pd
import pylayers.util.pyutil as pyu
import pylayers.util.geomutil as geu
from pylayers.util.project import PyLayers
from pylayers.antprop.spharm import *
from pylayers.antprop.antssh import ssh, SSHFunc2, SSHFunc, SSHCoeff, CartToSphere
from pylayers.antprop.coeffModel import *
import copy
from mayavi import mlab
try:
    from pylayers.antprop.antvsh import vsh
except:
    pass

import PIL.Image as Image


<div class="viewcode-block" id="Pattern"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Pattern.html#pylayers.antprop.antenna.Pattern">[docs]</a>class Pattern(PyLayers):
    &quot;&quot;&quot; Class Pattern


    MetaClass of Antenna

    A pattern is evaluated with the 3 np.array parameters

    theta
    phi
    fGHz

    This class implements pattern methods.
    The name of a pattern method starts by p.
    Each pattern method has a unique dictionnary argument &#39;param&#39;

    If self.grid dimensions are
        Nt x Np x Nf
    else:
        Ndir x Nf

    &quot;&quot;&quot;
    def __init__(self):
        PyLayers.__init__(self)
        self.grid = False
        self.evaluated = False
        self.full = False

<div class="viewcode-block" id="Pattern.eval"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Pattern.html#pylayers.antprop.antenna.Pattern.eval">[docs]</a>    def eval(self, **kwargs):
        &quot;&quot;&quot;  evaluate pattern functions

        Parameters
        ----------

        th: np.array
            if this array is present it means grid = False
        ph: np.array
        pt : np.array (3,N)
        pr : np.array (3,N)
        azoffset : int (0)
        Rfloor:bool
            if true add gain value to reflected ray on the floor.
            values are append at the end of sqG.
        fGHz:list
            []
        nth: int
            90
        nph: int
            181
        first: boolean
            True if first call (to define self.param)
        th0 : float
            theta initial value
        th1 : float
            theta finale value
        ph0 : float
            phi initial value
        ph1 : float
            phi final value


        Examples
        --------

        &gt;&gt;&gt; from pylayers.antprop.aarray import *
        &gt;&gt;&gt; A0=Antenna(&#39;Omni&#39;, param={&#39;pol&#39;:&#39;t&#39;,&#39;GmaxdB&#39;:0})
        &gt;&gt;&gt; A1=Antenna(&#39;Gauss&#39;)
        &gt;&gt;&gt; A2=Antenna(&#39;3gpp&#39;)
        &gt;&gt;&gt; A3=ULArray()
        &gt;&gt;&gt; A0.eval()
        &gt;&gt;&gt; A1.eval()
        &gt;&gt;&gt; A2.eval()
        &gt;&gt;&gt; #A3.eval()

        &quot;&quot;&quot;
        defaults = {&#39;Rfloor&#39;: False,
                    &#39;nth&#39;: 90,
                    &#39;nph&#39;: 181,
                    &#39;th0&#39;: 0,
                    &#39;th1&#39;: np.pi,
                    &#39;ph0&#39;: 0,
                    &#39;ph1&#39;: 2*np.pi,
                    &#39;azoffset&#39;: 0,
                    &#39;inplace&#39;: True
                   }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        if &#39;fGHz&#39; not in kwargs:
            #Â case antenna has been measured
            if hasattr(self,&#39;_fGHz&#39;):
                self.fGHz=self._fGHz
            elif &#39;fGHz&#39; not in self.__dict__:
                self.fGHz = np.array([2.4])

        else:
            if type(kwargs[&#39;fGHz&#39;])==np.ndarray:
                self.fGHz = kwargs[&#39;fGHz&#39;]
            else:
                self.fGHz = np.array([kwargs[&#39;fGHz&#39;]])

        #Â if current antenna is a measured antenna, pass the request frequencies
        #Â in particular if antenna pattern is type = nfc

        if hasattr(self,&#39;_fGHz&#39;):
            self.param.update({&#39;fGHz&#39;:self.fGHz})

        self.nf = len(self.fGHz)

        #
        # if th and ph are empty
        #    if pt and pr are empty
        #          calculates from th0,th1,nth
        #                           ph0,phi,nph
        #    else
        #          calculates from points coordinates pt and pr
        # else
        #     take specified values
        #
        if (&#39;th&#39; not in kwargs) and (&#39;ph&#39; not in kwargs):
            if (&#39;pt&#39; not in kwargs) and (&#39;pr&#39; not in kwargs):
                # grid = True
                # Determine theta and phi fr
                self.theta = np.linspace(kwargs[&#39;th0&#39;],kwargs[&#39;th1&#39;],kwargs[&#39;nth&#39;])
                self.phi = np.linspace(kwargs[&#39;ph0&#39;],kwargs[&#39;ph1&#39;],kwargs[&#39;nph&#39;],endpoint=False)
                self.grid = True
                condth = np.abs((kwargs[&#39;th1&#39;]-kwargs[&#39;th0&#39;])-np.pi)&lt;1e-2
                condph = np.abs((kwargs[&#39;ph1&#39;]-kwargs[&#39;ph0&#39;])-2*np.pi)&lt;1e-2
                if (condth and condph):
                    self.full = True
            else:
                # Gain between 2 points (One or 2 directions (uf Rfloor)
                # grid = False
                si = kwargs[&#39;pr&#39;]-kwargs[&#39;pt&#39;]
                ssi = np.sqrt(np.sum(si*si,axis=0))
                sn = si/ssi[None,:]
                self.theta = np.arccos(sn[2,:])
                self.phi = np.mod(np.arctan2(sn[1,:],sn[0,:])+kwargs[&#39;azoffset&#39;],2*np.pi)
                self.grid = False
                if kwargs[&#39;Rfloor&#39;]:
                    dR = np.sqrt(ssi**2 + (kwargs[&#39;pr&#39;][2,:] + kwargs[&#39;pt&#39;][2,:])**2)  # Â reflexion length
                    thetaR = np.arccos((kwargs[&#39;pr&#39;][2,:] + kwargs[&#39;pt&#39;][2,:]) / dR)
                    self.theta = np.hstack([self.theta,thetaR])
                    self.phi = np.hstack([self.phi,self.phi])

        else :
            self.grid = False
            self.full = False
            assert(len(kwargs[&#39;th&#39;])==len(kwargs[&#39;ph&#39;]))
            self.theta = kwargs[&#39;th&#39;]
            self.phi = kwargs[&#39;ph&#39;]

        if self.typ==&#39;azel&#39;:
            self.theta=np.linspace(-np.pi,np.pi,360)
            self.phi=np.linspace(-np.pi,np.pi,360)

        self.nth = len(self.theta)
        self.nph = len(self.phi)

        #
        # evaluation of the specific Pattern__p function
        #
        Ft,Fp = eval(&#39;self._Pattern__p&#39;+self.typ)(param=self.param)
        if kwargs[&#39;inplace&#39;]:
            self.Ft = Ft
            self.Fp = Fp
            self.evaluated = True
            self.gain()
        else:
            return Ft,Fp</div>

<div class="viewcode-block" id="Pattern.vsh"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Pattern.html#pylayers.antprop.antenna.Pattern.vsh">[docs]</a>    def vsh(self,threshold=-1):
        if self.evaluated:
            vsh(self)
            self.C.s1tos2()
            self.C.s2tos3(threshold=threshold)
        else:
            print(&#39;antenna must be evaluated to be converted into spherical harmonics.&#39;)</div>

<div class="viewcode-block" id="Pattern.ssh"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Pattern.html#pylayers.antprop.antenna.Pattern.ssh">[docs]</a>    def ssh(self,L=89,dsf=1):
        if self.evaluated:
            ssh(self,L,dsf)</div>

    def __pdipole(self,**kwargs):
        &quot;&quot;&quot; dipole antenna along z axis

        From Balanis (Formula 4.62(a))

        .. math::

            F_{\theta}(\theta,\phi) = \left[  \frac{\cos\left(\frac{kl}{2}\cos\theta\right)- \cos\left(\frac{kl}{2}\right)}{\sin \theta} \right]

        &quot;&quot;&quot;
        defaults = { &#39;param&#39; : { &#39;l&#39; : 0.25 } }

        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        l = kwargs[&#39;param&#39;][&#39;l&#39;]

        if self.grid:
            # Nth x Nphx Nf
            k = 2*np.pi*self.fGHz[None,None,:]/0.3
            usmall = self.theta&lt;=1e-1
            Ft  = (np.cos((k*l/2)*np.ones(len(self.phi))[None,:,None]*np.cos(self.theta[:,None,None]))-np.cos(k*l/2))/np.sin(self.theta[:,None,None])
            Ft[usmall,:,:]   = -(k*l/4)*self.theta[usmall][:,None,None]*np.sin(k*l/2)
            self.evaluated = True
        else:
            k = 2*np.pi*np.fGHz[None,:] /0.3
            usmall = self.theta&lt;=1e-1
            Ft  = (np.cos((k*l/2)*np.cos(self.theta[:,None]))-np.cos(k*l/2))/np.sin(self.theta[:,None])
            Ft[usmall,:,:] = -(k*l/4)*self.theta[usmall][:,None,None]*np.sin(k*l/2)
            # Nd x Nf

        Fp  = np.zeros(Ft.shape)

        return Ft,Fp

    def __pPatch(self,**kwargs):
        &quot;&quot;&quot; Patch antenna
        from Balanis (14-40b) page 835 (Rectangular Patch)
        &quot;&quot;&quot;

        defaults = { &#39;param&#39; : { &#39;h&#39;:0.001588, &#39;W&#39;:0.01186, &#39;L&#39;:0.00906 } }
        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]


    def __pOmni(self,**kwargs):
        &quot;&quot;&quot;  omnidirectional pattern

        Parameters
        ----------

        param : dict
            dictionnary of parameters
            + pol : string
                &#39;t&#39;| &#39;p&#39;
            + GmaxdB : float
                0


        self.grid is used for switching between : 

          if True   angular grid : nth x nph x nf
          if False  direction    : ndir x nf

        &quot;&quot;&quot;
        defaults = { &#39;param&#39; : { &#39;pol&#39; : &#39;t&#39;, &#39;GmaxdB&#39;: 0 } }

        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        self.param = kwargs[&#39;param&#39;]
        self.GmaxdB  = self.param[&#39;GmaxdB&#39;]
        self.pol  = self.param[&#39;pol&#39;]
        G = pow(10.,self.GmaxdB/10.) # linear gain
        if self.grid:
            # Nth x Nphx Nf
            self.sqG  = np.array(np.sqrt(G))*np.ones(len(self.fGHz))[None,None,:]
            self.evaluated = True
        else:
            # Nd x Nf
            self.sqG =  np.array(np.sqrt(G))*np.ones(len(self.fGHz))[None,:]
        Ft,Fp = self.radF()
        return Ft,Fp


    def __paperture(self,**kwargs):
        &quot;&quot;&quot; Aperture Pattern 

        Aperture in the (x,y) plane. Main lobe in theta=0 direction

        polar indicates the orientation of the Electric field either &#39;x&#39; or &#39;y&#39;

        See theoretical background in : 

        http://www.ece.rutgers.edu/~orfanidi/ewa/ch18.pdf

        Parameters
        ----------

        HPBW_x_deg : float 
            Half Power Beamwidth (degrees)
        HPBW_y_deg : float 
            Half Power Beamwidth (degrees)


        &quot;&quot;&quot;
        defaults = {&#39;param&#39;: {&#39;HPBW_x_deg&#39;:40,
                              &#39;HPBW_y_deg&#39;:10,
                              &#39;Gfactor&#39;:27000,
                              &#39;fcGHz&#39;: 27.5,
                              &#39;polar&#39;:&#39;x&#39;,
                              &#39;window&#39;:&#39;rect&#39;
                             }}

        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        self.param = kwargs[&#39;param&#39;]

        deg_to_rad = np.pi/180.
        ld_c = 0.3/self.param[&#39;fcGHz&#39;]
        ld = 0.3/self.fGHz
        Dx = 0.886*ld_c/(self.param[&#39;HPBW_x_deg&#39;]*deg_to_rad)
        Dy = 0.886*ld_c/(self.param[&#39;HPBW_y_deg&#39;]*deg_to_rad)
        Dx_n = Dx/ld
        Dy_n = Dy/ld
        if self.grid:
            # Nth x Nph x Nf
            theta = self.theta[:,None,None]
            phi = self.phi[None,:,None]
        else:
            # Ndir x Nf
            theta = self.theta[:,None]
            phi = self.phi[:,None]

        vx = Dx_n[...,:]*np.sin(theta)*np.cos(phi) # 18.1.4
        vy = Dy_n[...,:]*np.sin(theta)*np.sin(phi) # 18.1.4

        F_nor = ((1+np.cos(theta))/2.)*np.abs(np.sinc(vx)*np.sinc(vy))
        HPBW_x = (0.886*ld/Dx)/deg_to_rad
        HPBW_y = (0.886*ld/Dy)/deg_to_rad
        Gmax = self.param[&#39;Gfactor&#39;]/(HPBW_x*HPBW_y)
        F  = np.sqrt(Gmax[...,:])*F_nor # Ndir x Nf

        # Handling repartition on both vector components
        # enforce E.y = 0
        if self.param[&#39;polar&#39;]==&#39;x&#39;:
            Ft = F/np.sqrt(1+(np.cos(theta)*np.sin(phi)/np.cos(phi))**2)
            Fp = (-np.cos(theta)*np.sin(phi)/np.cos(phi))*Ft
            nan_bool = np.isnan(Fp)
            Fp[nan_bool] = F[nan_bool]
        # enforce E.x = 0
        if self.param[&#39;polar&#39;]==&#39;y&#39;:
            Ft = F/np.sqrt(1+(np.cos(theta)*np.cos(phi)/np.sin(phi))**2)
            Fp = (np.cos(theta)*np.cos(phi)/np.sin(phi))*Ft
            nan_bool = np.isnan(Fp)
            Fp[nan_bool] = F[nan_bool] 
        # enforce E.x = 0 
        #
        # This is experimental 
        # How to apply the 2D windowing properly ?
        #
#        if self.param[&#39;window&#39;]!=&#39;rect&#39;:
#            Nt = self.Fp.shape[0] 
#            Np = self.Fp.shape[1] 
#            Wp = np.fft.ifftshift(np.hamming(Nt)[:,None]*np.ones(Np)[None,:])[:,:,None]
#            Wt = np.fft.ifftshift(np.ones(Nt)[:,None]*np.hamming(Np)[None,:])[:,:,None] 
#            Wu = np.fft.ifftshift(np.ones(Nt)[:,None]*np.ones(Np)[None,:])[:,:,None] 
#            Wi = np.fft.ifftshift(np.hamming(Nt)[:,None]*np.hamming(Np)[None,:])[:,:,None] 
#            W = np.fft.fftshift(np.hamming(Nt)[:,None]*np.hamming(Np)[None,:])[:,:,None] 
#            # Fp : t x p x f   ou r x f 
#            # Ft : t x p x f   ou r x f 
#
#            Kp = np.fft.ifft2(self.Fp,axes=(0,1))
#            Kt = np.fft.ifft2(self.Ft,axes=(0,1))
#
#            self.Fp = np.fft.fft2(Kp*Wt,axes=(0,1))
#            self.Ft = np.fft.fft2(Kt*Wp,axes=(0,1))

        return Ft,Fp


    def __pnfc(self,**kwargs):
        &quot;&quot;&quot; nfc Pattern 

        interpolation of Ft,Fp for measured antenna

        Interpolation between known values of Ft and Fp contained in
        self._Ft and self._Fp to a given set of theta, phi.

        &quot;&quot;&quot;
        defaults = {&#39;param&#39;: {&#39;fGHz&#39;:[]}}
        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]


        self.param = kwargs[&#39;param&#39;]

        # if self.grid: 
        #     # Nth x Nph x Nf
        #     theta = self.theta[:,None,None]
        #     phi = self.phi[None,:,None]
        # else:

        uf=np.ndarray(shape=0,dtype=int)
        for k in self.param[&#39;fGHz&#39;]:
            uf = np.hstack((uf,np.where(self._fGHz&lt;=k)[0][-1]))


        theta = self.theta
        phi = self.phi

        # th0=np.array([0.12,3.1415,0.01])
        # ph0=np.array([0.01,0.5,2])

        # find closest theta arg : N
        dth = self._theta[:,None]-theta
        udth = abs(dth).argmin(axis=0)
        #Â determine sign of this arg to know which from N-1 or N+1 is candidate
        sdth = np.sign(np.diag(dth[udth]))


        #Â specific process if the find argument is N-1 or N+1 a.k.a self._theta-th &gt;0 or &lt;0
        neg_mask = sdth&lt;0
        pos_mask = ~neg_mask

        cudth= np.ndarray((len(theta)),dtype=int)
        cudth[pos_mask]=udth[pos_mask]-1
        cudth[neg_mask]=udth[neg_mask]


        ratio_th = (theta-self._theta[cudth])/(self._theta[cudth+1]-self._theta[cudth])

        # find closest phi arg : N
        dph = self._phi[:,None]-phi
        udph = abs(dph).argmin(axis=0)
        #Â determine sign of this arg to know which from N-1 or N+1 is candidate
        sdph = np.sign(np.diag(dph[udph]))

        #Â specific process if the find argument is N-1 or N+1 a.k.a self._phi-ph &gt;0 or &lt;0
        neg_mask = sdph&lt;0
        pos_mask = ~neg_mask

        cudph= np.ndarray((len(phi)),dtype=int)
        cudph[pos_mask]=udph[pos_mask]-1
        cudph[neg_mask]=udph[neg_mask]

        ratio_ph = (phi-self._phi[cudph])/(self._phi[cudph+1]-self._phi[cudph])

        if self.grid:
            Ft=self._Ft[cudth,:,:][...,uf]*(1.-ratio_th[:,None,None])+ratio_th[:,None,None]*self._Ft[cudth+1,:,:][...,uf]
            Ft=Ft[:,cudph,:]*(1.-ratio_ph[None,:,None])+ratio_ph[None,:,None]*Ft[:,cudph+1,:]
            Fp=self._Fp[cudth,:,:][...,uf]*(1.-ratio_th[:,None,None])+ratio_th[:,None,None]*self._Fp[cudth+1,:,:][...,uf]
            Fp=Fp[:,cudph,:]*(1.-ratio_ph[None,:,None])+ratio_ph[None,:,None]*Fp[:,cudph+1,:]
        else:
            Ft0=self._Ft[cudth,cudph,:][...,uf]*(1.-ratio_th[:,None])+ratio_th[:,None]*self._Ft[cudth+1,cudph,:][...,uf]
            Ft1=self._Ft[cudth,cudph+1,:][...,uf]*(1.-ratio_th[:,None])+ratio_th[:,None]*self._Ft[cudth+1,cudph+1,:][...,uf]
            Ft = Ft0*(1.-ratio_ph[:,None])+Ft1*ratio_ph[:,None]
            Fp0=self._Fp[cudth,cudph,:][...,uf]*(1.-ratio_th[:,None])+ratio_th[:,None]*self._Fp[cudth+1,cudph,:][...,uf]
            Fp1=self._Fp[cudth,cudph+1,:][...,uf]*(1.-ratio_th[:,None])+ratio_th[:,None]*self._Fp[cudth+1,cudph+1,:][...,uf]
            Fp = Fp0*(1.-ratio_ph[:,None])+Fp1*ratio_ph[:,None]
        
        return Ft,Fp



    def __paperture2(self,**kwargs):
        &quot;&quot;&quot; Aperture Pattern 

        Aperture in the (x,y) plane. Main lobe in theta=0 direction

        polar indicates the orientation of the Electric field either &#39;x&#39; or &#39;y&#39;

        See theoretical background in : 

        http://www.ece.rutgers.edu/~orfanidi/ewa/ch18.pdf

        Parameters
        ----------

        HPBW_x_deg : float 
            Half Power Beamwidth (degrees)
        HPBW_y_deg : float 
            Half Power Beamwidth (degrees)


        &quot;&quot;&quot;
        defaults = {&#39;param&#39;: {&#39;HPBW_a_deg&#39;:40,
                              &#39;HPBW_b_deg&#39;:10,
                              &#39;Gfactor&#39;:27000,
                              &#39;fcGHz&#39;: 27.5,
                              &#39;polar&#39;:&#39;x&#39;,
                              &#39;window&#39;:&#39;rect&#39;
                             }}

        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        self.param = kwargs[&#39;param&#39;]

        deg_to_rad = np.pi/180.
        ld_c = 0.3/self.param[&#39;fcGHz&#39;]
        ld = 0.3/self.fGHz
        a = 1.189*ld_c/(self.param[&#39;HPBW_a_deg&#39;]*deg_to_rad)
        b = 0.886*ld_c/(self.param[&#39;HPBW_b_deg&#39;]*deg_to_rad)
        a_n = a/ld
        b_n = b/ld
        if self.grid:
            # Nth x Nph x Nf
            theta = self.theta[:,None,None]
            phi = self.phi[None,:,None]
        else:
            # Ndir x Nf
            theta = self.theta[:,None]
            phi = self.phi[:,None]

        vx = a_n[...,:]*np.sin(theta)*np.cos(phi) # 18.1.4
        vy = b_n[...,:]*np.sin(theta)*np.sin(phi) # 18.1.4

        #F_nor = ((1+np.cos(theta))/2.)*np.abs(np.sinc(vx)*np.sinc(vy))
        F_nor = (1+np.cos(theta))/2*(np.cos(np.pi*vx)/(1-4*vx**2))*np.sinc(vy) # 18.1.3 + suppression rear radiation

        HPBW_a = (1.189*ld/a)/deg_to_rad
        HPBW_b = (0.886*ld/b)/deg_to_rad
        Gmax = self.param[&#39;Gfactor&#39;]/(HPBW_a*HPBW_b)
        F  = np.sqrt(Gmax[...,:])*F_nor # Ndir x Nf

        # Handling repartition on both vector components
        # enforce E.y = 0
        if self.param[&#39;polar&#39;]==&#39;x&#39;:
            Ft = F/np.sqrt(1+(np.cos(theta)*np.sin(phi)/np.cos(phi))**2)
            Fp = (-np.cos(theta)*np.sin(phi)/np.cos(phi))*Ft
            nan_bool = np.isnan(Fp)
            Fp[nan_bool] = F[nan_bool] 
        # enforce E.x = 0 
        if self.param[&#39;polar&#39;]==&#39;y&#39;:
            Ft = F/np.sqrt(1+(np.cos(theta)*np.cos(phi)/np.sin(phi))**2)
            Fp = (np.cos(theta)*np.cos(phi)/np.sin(phi))*Ft
            nan_bool = np.isnan(Fp)
            Fp[nan_bool] = F[nan_bool] 
        # enforce E.x = 0 
        #
        # This is experimeintal 
        # How to apply the 2D windowing properly ?
        #
#        if self.param[&#39;window&#39;]!=&#39;rect&#39;:
#            Nt = self.Fp.shape[0] 
#            Np = self.Fp.shape[1] 
#            Wp = np.fft.ifftshift(np.hamming(Nt)[:,None]*np.ones(Np)[None,:])[:,:,None]
#            Wt = np.fft.ifftshift(np.ones(Nt)[:,None]*np.hamming(Np)[None,:])[:,:,None] 
#            Wu = np.fft.ifftshift(np.ones(Nt)[:,None]*np.ones(Np)[None,:])[:,:,None] 
#            Wi = np.fft.ifftshift(np.hamming(Nt)[:,None]*np.hamming(Np)[None,:])[:,:,None] 
#            W = np.fft.fftshift(np.hamming(Nt)[:,None]*np.hamming(Np)[None,:])[:,:,None] 
#            # Fp : t x p x f   ou r x f 
#            # Ft : t x p x f   ou r x f 
#
#            Kp = np.fft.ifft2(self.Fp,axes=(0,1))
#            Kt = np.fft.ifft2(self.Ft,axes=(0,1))
#
#            self.Fp = np.fft.fft2(Kp*Wt,axes=(0,1))
#            self.Ft = np.fft.fft2(Kt*Wp,axes=(0,1))

        return Ft,Fp

    def __phplanesectoralhorn(self,**kwargs):
        &quot;&quot;&quot; H plane sectoral horn 

        Parameters
        ----------

        rho1 : float 
            sector radius (meter)
        a1 : float
            aperture dimension along x (greatest value in meters)
        b1 : float 
            aperture dimension along y (greatest value in meters) 

        Notes
        -----

        Maximum gain in theta =0 
        Polarized along y axis (Jx=0,Jz=0)  

        &quot;&quot;&quot;

        defaults = {&#39;param&#39;: {&#39;rho1&#39;:0.198,
                              &#39;a1&#39;:0.088,  # aperture dimension along x
                              &#39;b1&#39;:0.0126, # aperture dimension along y 
                              &#39;fcGHz&#39;:28,
                              &#39;GcmaxdB&#39;:19,
                              &#39;Nx&#39;:20,
                              &#39;Ny&#39;:20}}

        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        self.param = kwargs[&#39;param&#39;]
        #H-plane antenna
        rho1            = self.param[&#39;rho1&#39;]
        a1              = self.param[&#39;a1&#39;]
        b1              = self.param[&#39;b1&#39;]
        Nx              = self.param[&#39;Nx&#39;]
        Ny              = self.param[&#39;Ny&#39;]
        fcGHz           = self.param[&#39;fcGHz&#39;]
        GcmaxdB         = self.param[&#39;GcmaxdB&#39;]
        assert(a1&gt;b1), &quot;a1 should be greater than b1 (see fig 13.1O(a) Balanis&quot;

        lbda   = 0.3/self.fGHz
        k      = 2*np.pi/lbda
        eta0    = np.sqrt(4*np.pi*1e-7/8.85429e-12)

        if self.grid:
            # X,Y aperture points (t,p,x,y,f)
            X = np.arange(-a1/2,a1/2,a1/(Nx-1))[None,None,:,None,None]
            Y = np.arange(-b1/2,b1/2,b1/(Ny-1))[None,None,None,:,None]
            # angular domain (theta,phi)
            Theta= self.theta[:,None,None,None,None]
            Phi = self.phi[None,:,None,None,None]
        else:
            # X,Y aperture points (r,x,y,f)
            X = np.arange(-a1/2,a1/2,a1/(Nx-1))[None,:,None,None]
            Y = np.arange(-b1/2,b1/2,b1/(Ny-1))[None,None,:,None]
            # angular domain (theta,phi)
            Theta= self.theta[:,None,None,None]
            Phi= self.phi[:,None,None,None]


        #% Aperture field Ea:
        # Ea is an approximation of the aperture field:
        # (from: C. A. Balanis, Antenna Theoy: Analysis and Design. New York
        # Wiley, 1982. ... Section 13.3.1 )

        Ea = np.cos(X*np.pi/a1)*np.exp(-.5*1j*k*((X**2)/(rho1)+(Y**2)/(rho1)))
        Jy = -Ea/eta0
        Mx = Ea

        # cosine direction
        ctsp = np.cos(Theta)*np.sin(Phi)
        cp = np.cos(Phi)
        ctcp = np.cos(Theta)*np.cos(Phi)
        sp = np.sin(Phi) 
        stcp = np.sin(Theta)*np.cos(Phi)
        stsp = np.sin(Theta)*np.sin(Phi)
        # N &amp; L
        ejkrrp = np.exp(1j*k*( X*stcp + Y*stsp))        # exp(jk (r.r&#39;))
        if self.grid:
            N_theta  = np.einsum(&#39;tpnmf-&gt;tpf&#39;,Jy*ctsp*ejkrrp) # 12-12 a assuming Jx,Jz=0
            N_phi    = np.einsum(&#39;tpnmf-&gt;tpf&#39;,Jy*cp*ejkrrp)   # 12-12 b &quot;&quot;
            L_theta  = np.einsum(&#39;tpnmf-&gt;tpf&#39;,Mx*ctcp*ejkrrp) # 12-12 c assuming My,Mz=0
            L_phi    = np.einsum(&#39;tpnmf-&gt;tpf&#39;,-Mx*sp*ejkrrp)  # 12-12 d &quot;&quot;
        else:
            N_theta  = np.einsum(&#39;rnmf-&gt;rf&#39;,Jy*ctsp*ejkrrp) # 12-12 a assuming Jx,Jz=0
            N_phi    = np.einsum(&#39;rnmf-&gt;rf&#39;,Jy*cp*ejkrrp)   # 12-12 b &quot;&quot;
            L_theta  = np.einsum(&#39;rnmf-&gt;rf&#39;,Mx*ctcp*ejkrrp) # 12-12 c assuming My,Mz=0
            L_phi    = np.einsum(&#39;rnmf-&gt;rf&#39;,-Mx*sp*ejkrrp)  # 12-12 d &quot;&quot;


        # Far-Field
        Ft  = -L_phi  - eta0*N_theta # 12-10b p 661
        Fp  = L_theta - eta0*N_phi   # 12-10c p 661
        G = Ft*np.conj(Ft)+Fp*np.conj(Fp)
        if self.grid:
            # Umax : ,f
            self.Umax = G.max(axis=(0,1))
            Ft = Ft/np.sqrt(self.Umax[None,None,:])
            Fp = Fp/np.sqrt(self.Umax[None,None,:])
            # centered frequency range
            fcc = np.abs(self.fGHz-fcGHz)
            idxc = np.where(fcc==np.min(fcc))[0][0]
            # Gain @ center frequency
            #G = _gain(Ft[:,:,idxc],Fp[:,:,idxc])
            G = _gain(Ft,Fp)
            # effective half power beamwidth
            self.ehpbw, self.hpster  = _hpbw(G,self.theta,self.phi)
            self.Gfactor = 10**(GcmaxdB/10.)*self.ehpbw[idxc]
            Gmax = self.Gfactor/self.ehpbw
            Ft = np.sqrt(Gmax[None,None,:])*Ft
            Fp = np.sqrt(Gmax[None,None,:])*Fp
        else:
            ##
            ## Ft (r x f )
            ## Fp (r x f )
            ##
            Ft = Ft/np.sqrt(self.Umax[None,:])
            Fp = Fp/np.sqrt(self.Umax[None,:])
            Gmax = self.Gfactor/self.ehpbw
            Ft = np.sqrt(Gmax[None,:])*Ft
            Fp = np.sqrt(Gmax[None,:])*Fp

        return Ft,Fp

    def __patoll(self,**kwargs):
        &quot;&quot;&quot;
        &quot;&quot;&quot;
        paramdef = {&#39;iband&#39;:0,
                    &#39;polar&#39;:-45.0,
                    &#39;tilt&#39;:0
                    }

        param = kwargs.pop(&#39;param&#39;)
        if param =={}:
            param = paramdef
        iband = param.pop(&#39;iband&#39;)
        polar = param.pop(&#39;polar&#39;)
        tilt = param.pop(&#39;tilt&#39;)
        # TODO check tilt value is compatible
        lbands = list(dict(self.atoll).keys())
        # Gver : 360,Nf
        # Ghor : 360,Nf
        Gver = self.atoll[lbands[iband]][polar][&#39;ver&#39;][:,tilt,:]
        self.fGHz = self.atoll[lbands[iband]][polar][&#39;freq&#39;]
        self.tilt_theo = self.atoll[lbands[iband]][polar][&#39;tilt&#39;][tilt]
        Ghor = self.atoll[lbands[iband]][polar][&#39;hor&#39;][:,tilt,:]
        shG = Gver.shape
        Nhor = Ghor.shape[0]
        Nver = Gver.shape[0]
        # grid mode (180,360,Nf)
        rmax = int(Nver/2)
        self.theta = np.linspace(0,np.pi,rmax+1)
        self.phi = np.linspace(0,2*np.pi-2*np.pi/Nhor,Nhor)
        #self.nth = len(self.theta)
        #self.nph = len(self.phi)
        #a1 = np.kron(self.theta,np.ones(len(self.phi)))
        #2 = np.kron(np.ones(len(self.theta)),self.phi)
        #g = np.hstack((a1[:,None],a2[:,None]))

        sqG = np.ones((181,360,shG[-1]))
        uvermax = zeros(shG[-1]).astype(int)
        for k in range(shG[-1]):
            # find the maximum in the vertical plane
            uvermax[k]  = np.where(Gver[:,k]==np.max(Gver[:,k]))[0][0]
            # offset of vertical pattern
            Gver_roll = np.roll(Gver[:,k],-uvermax[k])
            # first row (pole)
            sqG[0,:,k]  = np.sqrt(10**(Gver_roll[0]/10))
            # last row (pole)
            sqG[-1,:,k] = np.sqrt(10**(Gver_roll[rmax]/10))
            # first column (Vertical)
            c1 = 0
            sqG[:,c1,k]  = np.sqrt(10**(Gver_roll[0:rmax+1]/10))
            # third column (Vertical)
            c3 = 180
            sqG[1:-1,c3,k] = np.sqrt(10**(Gver_roll[rmax+1:][::-1]/10))
            # second column (Horizontal)
            c2 = 90
            sqG[:,c2,k] = np.sqrt(10**(Ghor[0:181,k]/10))
            # fourth column (Horizontal)
            c4 = 270
            sqG[1:-1,c4,k] = np.sqrt(10**(Ghor[rmax+1:,k][::-1]/10))
            u1 = np.linspace(1,89,89)/89.
            #
            # interpolation
            #
            sqG[1:-1,1:90,k] = sqG[1:-1,0,k][:,None]*(1-u1[None,:])+sqG[1:-1,90,k][:,None]*u1[None,:]
            sqG[1:-1,91:180,k]= sqG[1:-1,90,k][:,None]*(1-u1[None,:])+sqG[1:-1,180,k][:,None]*u1[None,:]
            sqG[1:-1,181:270,k] = sqG[1:-1,180,k][:,None]*(1-u1[None,:])+sqG[1:-1,270,k][:,None]*u1[None,:]
            sqG[1:-1,271:,k]= sqG[1:-1,270,k][:,None]*(1-u1[None,:])+sqG[1:-1,0,k][:,None]*u1[None,:]
        #plt.plot(sqG[:,0,:])
        #plt.plot(sqG[:,180,:])
        #plt.plot(sqG[:,90,:])
        #plt.plot(sqG[:,270,:])

        Ft = sqG/np.sqrt(2)
        Fp = sqG/np.sqrt(2)

        return Ft,Fp

    def __phorn(self,**kwargs):
        &quot;&quot;&quot; Horn antenna


        http://www.ece.rutgers.edu/~orfanidi/ewa/ch18.pdf (18.2)

        Parameters
        ----------

            Half Power Beamwidth (degrees)


        &quot;&quot;&quot;
        defaults = {&#39;param&#39;: {&#39;sigma_a&#39;:1.2593,
                              &#39;sigma_b&#39;:1.0246,
                              &#39;A_wl&#39;:16,
                              &#39;B_wl&#39;:3,
                              &#39;fcGHz&#39;:28.,
                              &#39;polar&#39;:&#39;x&#39;
                             }}

        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        self.param = kwargs[&#39;param&#39;]

        deg_to_rad = np.pi/180.
        ld_c = 0.3/self.param[&#39;fcGHz&#39;]
        ld = 0.3/self.fGHz
        A_wl = kwargs[&#39;param&#39;][&#39;A_wl&#39;]
        B_wl = kwargs[&#39;param&#39;][&#39;B_wl&#39;]

        A = A_wl*ld_c
        B = B_wl*ld_c
        sigma_a = kwargs[&#39;param&#39;][&#39;sigma_a&#39;]
        sigma_b = kwargs[&#39;param&#39;][&#39;sigma_b&#39;]
        #b = kwargs[&#39;param&#39;][&#39;b&#39;]
        #Ra = (A/(A-a))*RA
        #Rb = (B/(B-b))*RB
        #La = np.sqrt(Ra**2+A**2/4)
        #Lb = np.sqrt(Rb**2+B**2/4)
        #alpha = np.arctan(A/(2*Ra))
        #beta = np.arctan(B/(2*Rb))
        #Delta_a = A**2/(8*Ra)
        #Delta_b = B**2/(8*Rb)
        #sigma_a = A/np.sqrt((2*ld*Ra))
        #sigma_b = B/np.sqrt((2*ld*Rb))
        A_n = A/ld
        B_n = B/ld

        if self.grid:
            # Nth x Nph x Nf
            theta = self.theta[:,None,None]
            phi = self.phi[None,:,None]
        else:
            # Ndir x Nf
            theta = self.theta[:,None]
            phi = self.phi[:,None]

        vx = A_n[...,:]*np.sin(theta)*np.cos(phi) # 18.3.4
        vy = B_n[...,:]*np.sin(theta)*np.sin(phi) # 18.3.4

        F = ((1+np.cos(theta))/2.)*(F1(vx,sigma_a)*F0(vy,sigma_b))
        normF = np.abs(F1(0,sigma_a)*F0(0,sigma_b))**2
        F_nor = F/np.sqrt(normF)
        efficiency = 0.125*normF # 18.4.3
        Gmax = efficiency*4*np.pi*A*B/ld**2
        F  = np.sqrt(Gmax[...,:])*F_nor # Ndir x Nf

        # Handling repatition on both vector components
        # enforce E.y = 0
        if self.param[&#39;polar&#39;]==&#39;x&#39;:
            Ft = F/np.sqrt(1+(np.cos(theta)*np.sin(phi)/np.cos(phi))**2)
            Fp = (-np.cos(theta)*np.sin(phi)/np.cos(phi))*Ft
            nan_bool = np.isnan(Fp)
            Fp[nan_bool] = F[nan_bool]
        # enforce E.x = 0
        if self.param[&#39;polar&#39;]==&#39;y&#39;:
            Ft = F/np.sqrt(1+(np.cos(theta)*np.cos(phi)/np.sin(phi))**2)
            Fp = (np.cos(theta)*np.cos(phi)/np.sin(phi))*Ft
            nan_bool = np.isnan(Fp)
            Fp[nan_bool] = F[nan_bool]

        return Ft,Fp

    def __pazel(self,**kwargs):
        &quot;&quot;&quot; Azimuth elevation pattern from file

        Parameters
        ----------

        filename : ANT filename

        Notes
        -----

        The 3D pattern is obtained by taking the product
        of azimuth pattern and elevation pattern.

        &quot;&quot;&quot;



        defaults = {&#39;param&#39;: {&#39;filename&#39; : &#39;&#39;,
                              &#39;pol&#39;:&#39;V&#39;}}

        f = open(kwargs[&#39;param&#39;][&#39;filename&#39;])
        Gthetaphi = f.readlines()
        f.close()
        Gthetaphi = np.array(Gthetaphi).astype(&#39;float&#39;)
        Gaz = Gthetaphi[360:]
        Gel = Gthetaphi[:360]

        sqGazlin = np.sqrt(pow(10,Gaz/10.))
        sqGellin = np.sqrt(pow(10,Gel/10.))

        if self.grid :
            # Nth x Nph x Nf
            if kwargs[&#39;param&#39;][&#39;pol&#39;]==&#39;V&#39;:
                Ft = np.ones((360,360,1))
                Fp = np.zeros((360,360,1))
                #Ft[180,:] = sqGazlin[:,None]
                #Ft[:,180] = sqGellin[:,None]
                Ft = sqGazlin[None,:,None]*sqGellin[:,None,None]
            if kwargs[&#39;param&#39;][&#39;pol&#39;]==&#39;H&#39;:
                Fp = np.ones((360,360,1))
                Ft = np.zeros((360,360,1))
                Fp = sqGazlin[None,:,None]*sqGellin[:,None,None]
                #self.Fp[180,:]= sqGazlin[:,None]
                #self.Fp[:,180]= sqGellin[:,None]
            if kwargs[&#39;param&#39;][&#39;pol&#39;]==&#39;45&#39;:
                Fp = np.ones((360,360,1))
                Ft = np.ones((360,360,1))
                # Azimuth
                Ft = (1/sqrt(2))*sqGazlin[None,:,None]*sqGellin[:,None,None]
                Fp = (1/sqrt(2))*sqGazlin[None,:,None]*sqGellin[:,None,None]
                #self.Fp[180,:]= sqGazlin[:,None]
                #self.Fp[180,:]= (1/sqrt(2))*sqGazlin[:,None]
                #Ft[180,:]= (1/sqrt(2))*sqGazlin[:,None]
                # Elevation
                #self.Fp[:,180]= (1/sqrt(2))*sqGellin[:,None]
                #Ft[:,180]= (1/sqrt(2))*sqGellin[:,None]

            #Ft = sqGthlin[:,None,None]
            #self.Fp = sqGphlin[None,:,None]
            # Ft = self.sqGmax * ( np.exp(-2.76*argth[:,None,None]) * np.exp(-2.76*argphi[None,:,None]) )
            # self.Fp = self.sqGmax * ( np.exp(-2.76*argth[:,None,None]) * np.exp(-2.76*argphi[None,:,None]) )
            self.evaluated = True
        else:
            pass
            # #
            # #  Nd x Nf
            # #
            # Ft = self.sqGmax * ( np.exp(-2.76*argth) * np.exp(-2.76*argphi) )
            # Fp = self.sqGmax * ( np.exp(-2.76*argth) * np.exp(-2.76*argphi) )
            # # add frequency axis (Ndir x Nf)
            # Ft = np.dot(Ft[:,None],np.ones(len(self.fGHz))[None,:])
            # self.Fp = np.dot(Fp[:,None],np.ones(len(self.fGHz))[None,:])
        return Ft,Fp


    def __pGauss(self,**kwargs):
        &quot;&quot;&quot; Gauss pattern

        Parameters
        ----------

        p0 : phi main lobe (0-2pi)
        p3 : 3dB aperture angle
        t0 : theta main lobe (0-pi)
        t3 : 3dB aperture angle

        TODO : finish implementation of polar

        &quot;&quot;&quot;
        defaults = {&#39;param&#39;:{&#39;p0&#39; : 0,
                    &#39;t0&#39; : np.pi/2,
                    &#39;p3&#39; : np.pi/6,
                    &#39;t3&#39; : np.pi/6,
                    &#39;pol&#39;:&#39;th&#39;
                   }}

        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        self.typ=&#39;Gauss&#39;
        self.param = kwargs[&#39;param&#39;]

        p0 = self.param[&#39;p0&#39;]
        t0 = self.param[&#39;t0&#39;]
        p3 = self.param[&#39;p3&#39;]
        t3 = self.param[&#39;t3&#39;]
        pol = self.param[&#39;pol&#39;]

        self.Gmax = 16/(t3*p3)
        self.GdB = 10*np.log10(self.Gmax)
        self.sqGmax = np.sqrt(self.Gmax)

        argth = ((self.theta-t0)**2)/t3

        e1 = np.mod(self.phi-p0,2*np.pi)
        e2 = np.mod(p0-self.phi,2*np.pi)

        e = np.minimum(e1,e2)

        argphi = (e**2)/p3
        Nf = len(self.fGHz)

        if self.grid :
            Nt = len(self.theta)
            Np = len(self.phi)
            # Nth x Nph x Nf
            # Ft = self.sqGmax * ( np.exp(-2.76*argth[:,None,None]) * np.exp(-2.76*argphi[None,:,None]) )
            # self.Fp = self.sqGmax * ( np.exp(-2.76*argth[:,None,None]) * np.exp(-2.76*argphi[None,:,None]) )
            if pol==&#39;th&#39;:
                Ft = self.sqGmax * ( np.exp(-2.76*argth[:,None,None]) * np.exp(-2.76*argphi[None,:,None]) *np.ones(len(self.fGHz))[None,None,:])
                Fp = np.zeros((Nt,Np,Nf))
            if pol==&#39;ph&#39;:
                Ft = np.zeros((Nt,Np,Nf))
                Fp = self.sqGmax * ( np.exp(-2.76*argth[:,None,None]) * np.exp(-2.76*argphi[None,:,None]) *np.ones(len(self.fGHz))[None,None,:])
        else:
            #
            #  Nd x Nf
            #
            Nd = len(self.theta)
            assert(len(self.phi)==Nd)
            if pol==&#39;th&#39;:
                Ft = self.sqGmax * ( np.exp(-2.76*argth) * np.exp(-2.76*argphi) )
                Fp = np.zeros(Nd)
            if pol==&#39;ph&#39;:
                Ft = np.zeros(Nd)
                Fp = self.sqGmax * ( np.exp(-2.76*argth) * np.exp(-2.76*argphi) )
            # add frequency axis (Ndir x Nf)
            Ft = np.dot(Ft[:,None],np.ones(len(self.fGHz))[None,:])
            Fp = np.dot(Fp[:,None],np.ones(len(self.fGHz))[None,:])
        return Ft,Fp

    def __p3gpp(self,**kwargs):
        &quot;&quot;&quot; 3GPP antenna pattern

        Parameters
        ----------

        thtilt : theta tilt antenna
        hpbwv  : half power beamwidth v
        hpbwh  : half power beamwidth h
        sllv   : side lobe level
        fbrh   : front back ratio
        gm     :
        pol    : h | v | c


        if pattern
            Ft  nth x nphi x nf
            Fp  nth x nphi x nf
        else
            Ft  ndir x nf (==nth, ==nph)
            Fp  ndir x nf (==nth, ==nph)

        &quot;&quot;&quot;
        defaults = {&#39;param&#39; : {&#39;thtilt&#39;:0,  # antenna tilt
                    &#39;hpbwv&#39; :6.2,# half power beamwidth v
                    &#39;hpbwh&#39; :65, # half power beamwidth h
                    &#39;sllv&#39;: -18, # side lobe level
                    &#39;fbrh&#39;: 30,  # front back ratio
                    &#39;gm&#39;: 18,    #
                    &#39;pol&#39;:&#39;p&#39;    #t , p , c
                    }}


        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;] = defaults[&#39;param&#39;]


        #if &#39;param&#39; not in kwargs:
            #kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        self.typ = &quot;3gpp&quot;
        self.param = kwargs[&#39;param&#39;]
        thtilt = self.param[&#39;thtilt&#39;]
        hpbwh  = self.param[&#39;hpbwh&#39;]
        hpbwv  = self.param[&#39;hpbwv&#39;]
        sllv   = self.param[&#39;sllv&#39;]
        fbrh   = self.param[&#39;fbrh&#39;]
        gm     = self.param[&#39;gm&#39;]
        pol    = self.param[&#39;pol&#39;]

        self.pol = pol

        # convert radian to degree
        phi   = self.phi*180/np.pi-180
        theta = self.theta*180/np.pi-90

        if self.grid:
            #Nth x Nph x Nf
            GvdB = np.maximum(-12*((theta-thtilt)/hpbwv)**2,sllv)[:,None,None]
            GhdB = (-np.minimum(12*(phi/hpbwh)**2,fbrh)+gm)[None,:,None]
            GdB  = GhdB+GvdB
            self.sqG = np.sqrt(10**(GdB/10.))*np.ones(self.nf)[None,None,:]
            self.evaluated = True
        else:
            #Nd x Nf
            GvdB = np.maximum(-12*((theta-thtilt)/hpbwv)**2,sllv)[:,None]
            GhdB = (-np.minimum(12*(phi/hpbwh)**2,fbrh)+gm)[:,None]
            GdB  = GhdB+GvdB
            self.sqG = np.sqrt(10**(GdB/10.))
        # radiating functions are deduced from square root of gain
        Ft,Fp = self.radF()
        return Ft,Fp

    def __pvsh1(self,**kwargs):
        &quot;&quot;&quot; calculate pattern from VSH Coeffs (shape 1)

        Parameters
        ----------

        theta  : ndarray (1xNdir)
        phi    : ndarray (1xNdir)
        k      : int
            frequency index

        Returns
        -------

        Ft , Fp 

        &quot;&quot;&quot;
        assert hasattr(self,&#39;C&#39;),&#39;no spherical coefficient&#39;
        assert hasattr(self.C.Br,&#39;s1&#39;),&#39;no shape 1 coeff in vsh&#39;

        if self.grid:
            theta = np.kron(self.theta, np.ones(self.nph))
            phi = np.kron(np.ones(self.nth),self.phi)
        else:
            theta = self.theta
            phi = self.phi

        Nt = len(theta)
        Np = len(phi)

        if self.grid:
            theta = np.kron(theta, np.ones(Np))
            phi = np.kron(np.ones(Nt),phi)

        nray = len(theta)

        Br = self.C.Br.s1[:, :, :]
        Bi = self.C.Bi.s1[:, :, :]
        Cr = self.C.Cr.s1[:, :, :]
        Ci = self.C.Ci.s1[:, :, :]

        L = self.C.Br.L1
        M = self.C.Br.M1
        # The - sign is necessary to get the good reconstruction
        #     deduced from observation
        #     May be it comes from a different definition of theta in SPHEREPACK
        ind = index_vsh(L, M)
        l = ind[:, 0]
        m = ind[:, 1]
        #
        V, W = VW(l, m, theta, phi)
        #
        # broadcasting along frequency axis
        #
        V = np.expand_dims(V,0)
        W = np.expand_dims(V,0)
        #
        #   k : frequency axis
        #   l : axis l (theta)
        #   m : axis m (phi)
        #



        #Â The following cannot work du to shape issue!:

        # Fth = np.einsum(&#39;klm,kilm-&gt;ki&#39;,Br,np.real(V.T)) - \
        #       np.einsum(&#39;klm,kilm-&gt;ki&#39;,Bi,np.imag(V.T)) + \
        #       np.einsum(&#39;klm,kilm-&gt;ki&#39;,Ci,np.real(W.T)) + \
        #       np.einsum(&#39;klm,kilm-&gt;ki&#39;,Cr,np.imag(W.T))

        # Fph = -np.einsum(&#39;klm,kilm-&gt;ki&#39;,Cr,np.real(V.T)) + \
        #       np.einsum(&#39;klm,kilm-&gt;ki&#39;,Ci,np.imag(V.T)) + \
        #       np.einsum(&#39;klm,kilm-&gt;ki&#39;,Bi,np.real(W.T)) + \
        #       np.einsum(&#39;klm,kilm-&gt;ki&#39;,Br,np.imag(W.T))

        #Â this is replaced without garantee of correct 
        # broadcasting on fequency by :

        Brr = Br[:,l,m]
        Bir = Bi[:,l,m]
        Crr = Cr[:,l,m]
        Cir = Ci[:,l,m]

        Fth = np.dot(Brr, np.real(V.T)) - \
              np.dot(Bir, np.imag(V.T)) + \
              np.dot(Cir, np.real(W.T)) + \
              np.dot(Crr, np.imag(W.T))
        Fph = -np.dot(Crr, np.real(V.T)) + \
              np.dot(Cir, np.imag(V.T)) + \
              np.dot(Bir, np.real(W.T)) + \
              np.dot(Brr, np.imag(W.T))

        # here Nf x Nd

        Ft = Fth.transpose()
        Fp = Fph.transpose()

        # then Nd x Nf

        if self.grid:
        # Nth x Nph x Nf
            Ft = Ft.reshape(self.nth, self.nph,self.nf)
            Fp = Fp.reshape(self.nth, self.nph,self.nf)

        # last axis should be frequency 
        assert(Ft.shape[-1]==self.nf)
        assert(Fp.shape[-1]==self.nf)

        return Ft, Fp

    def __pvsh3(self,**kwargs):
        &quot;&quot;&quot; calculate pattern from vsh3


        &quot;&quot;&quot;
        assert hasattr(self,&#39;C&#39;),&#39;no spherical coefficient&#39;
        assert hasattr(self.C.Br,&#39;s3&#39;),&#39;no shape 3 coeff in vsh&#39;

        if self.grid:
            theta = np.kron(self.theta, np.ones(self.nph))
            phi = np.kron(np.ones(self.nth),self.phi)
        else:
            theta = self.theta
            phi = self.phi

        Br  = self.C.Br.s3
        lBr = self.C.Br.ind3[:, 0]
        mBr = self.C.Br.ind3[:, 1]

        Bi  = self.C.Bi.s3
        Cr  = self.C.Cr.s3
        Ci  = self.C.Ci.s3

        L = lBr.max()
        M = mBr.max()

        # vector spherical harmonics basis functions

        # V, W = VW(lBr, mBr, theta, phi)
        V, W = VW(lBr, mBr, theta, phi)
        Fth = np.dot(Br, np.real(V.T)) - \
              np.dot(Bi, np.imag(V.T)) + \
              np.dot(Ci, np.real(W.T)) + \
              np.dot(Cr, np.imag(W.T))

        Fph = -np.dot(Cr, np.real(V.T)) + \
               np.dot(Ci, np.imag(V.T)) + \
               np.dot(Bi, np.real(W.T)) + \
               np.dot(Br, np.imag(W.T))

        # here Nf x Nd

        Ft = Fth.transpose()
        Fp = Fph.transpose()

        # then Nd x Nf

        if self.grid:
        # Nth x Nph x Nf
            Ft = Ft.reshape(self.nth, self.nph,self.nf)
            Fp = Fp.reshape(self.nth, self.nph,self.nf)

        # last axis should be frequency
        assert(Ft.shape[-1]==self.nf)
        assert(Fp.shape[-1]==self.nf)

        return Ft,Fp

    def __psh3(self,**kwargs):
        &quot;&quot;&quot; calculate pattern for sh3

        Parameters
        ----------

        &quot;&quot;&quot;
        assert hasattr(self,&#39;S&#39;),&#39;no spherical coefficient&#39;
        assert hasattr(self.S.Cx,&#39;s3&#39;),&#39;no shape 3 coeff in ssh&#39;

        if self.grid:
            theta = np.kron(self.theta, np.ones(self.nph))
            phi = np.kron(np.ones(self.nth),self.phi)
        else:
            theta = self.theta
            phi = self.phi

        cx = self.S.Cx.s3
        cy = self.S.Cy.s3
        cz = self.S.Cz.s3

        lmax = self.S.Cx.lmax
        Y ,indx = SSHFunc2(lmax, theta,phi)

        k = self.S.Cx.k2

        if self.grid:
            Ex = np.dot(cx,Y[k])
            Ey = np.dot(cy,Y[k])
            Ez = np.dot(cz,Y[k])
            Fth,Fph = CartToSphere(theta, phi, Ex, Ey,Ez, bfreq = True, pattern = True )

            Ft = Fth.transpose()
            Fp = Fph.transpose()
            Ft = Ft.reshape(self.nth, self.nph,self.nf)
            Fp = Fp.reshape(self.nth, self.nph,self.nf)
        else:
            Ex = np.dot(cx,Y[k])
            Ey = np.dot(cy,Y[k])
            Ez = np.dot(cz,Y[k])
            Fth,Fph = CartToSphere(theta, phi, Ex, Ey,Ez, bfreq = True, pattern = False)
            Ft = Fth.transpose()
            Fp = Fph.transpose()

        assert(Ft.shape[-1]==self.nf)
        assert(Fp.shape[-1]==self.nf)

        return Ft,Fp

    def __pwireplate(self,**kwargs):
        &quot;&quot;&quot; pattern wire plate antenna

        &quot;&quot;&quot;
        defaults = {&#39;param&#39;:{&#39;t0&#39; : 5*np.pi/6,
                             &#39;GmaxdB&#39;: 5
                   }}

        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        self.typ=&#39;wireplate&#39;
        self.param = kwargs[&#39;param&#39;]
        t0 = self.param[&#39;t0&#39;]
        GmaxdB = self.param[&#39;GmaxdB&#39;]
        Gmax = pow(GmaxdB/10.,10)
        sqGmax = np.sqrt(Gmax)

        uth1 = np.where(self.theta &lt; t0)[0]
        uth2 = np.where(self.theta &gt;= t0)[0]
        p = t0
        q = np.pi/2.
        A = np.array(([[3*p**2,2*p,1],[p**3,p**2,p],[q**3,q**2,q]]))
        Y = np.array(([0,1,1/(1.*sqGmax)]))
        self.poly = la.solve(A,Y)

        argth1 = np.abs(self.poly[0]*self.theta[uth1]**3
                      + self.poly[1]*self.theta[uth1]**2
                      + self.poly[2]*self.theta[uth1])

        argth2 = -(1/(np.pi-t0)**2)*(self.theta[uth2]-t0)**2+1
        argth = np.hstack((argth1,argth2))[::-1]

        if self.grid:
            Ft = sqGmax * (argth[:,None])
            Fp = sqGmax * (argth[:,None])
        else:
            Fat = sqGmax * argth
            Fap = sqGmax * argth
            Ft = np.dot(Fat[:,None],np.ones(len(self.fGHz))[None,:])
            Fp = np.dot(Fap[:,None],np.ones(len(self.fGHz))[None,:])

        return Ft,Fp


    def __pcst(self,**kwargs):
        &quot;&quot;&quot; read antenna in text format
        &quot;&quot;&quot;

        defaults = {&#39;param&#39;:{&#39;p&#39; : 2,
                    &#39;directory&#39;:&#39;ant/FF_Results_txt_port_1_2/&#39;,
                    &#39;fGHz&#39;:np.arange(2,6.5,0.5)}}

        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            param=defaults[&#39;param&#39;]
        else:
            param=kwargs[&#39;param&#39;]

        self.fGHz = param[&#39;fGHz&#39;]
        self.nf = len(self.fGHz)

        for f in param[&#39;fGHz&#39;]:
            if ((int(f*10))%10)==0:
               _filename1 = &#39;E_port&#39;+str(param[&#39;p&#39;])+&#39;_f&#39;+str(int(f))+&#39;GHz.txt&#39;
               _filename2 = &#39;E_port&#39;+str(param[&#39;p&#39;])+&#39;_f&#39;+str(int(f))+&#39;Ghz.txt&#39;
        #    print &#39;toto&#39;
            else:
                _filename1 = &#39;E_port&#39;+str(param[&#39;p&#39;])+&#39;_f&#39;+str(f)+&#39;GHz.txt&#39;
                _filename2 = &#39;E_port&#39;+str(param[&#39;p&#39;])+&#39;_f&#39;+str(f)+&#39;Ghz.txt&#39;


            filename1 = pyu.getlong(_filename1, param[&#39;directory&#39;])
            filename2 = pyu.getlong(_filename2, param[&#39;directory&#39;])

            try:
                df = pd.read_csv(filename1,sep=&#39;;&#39;)
            except:
                df = pd.read_csv(filename2,sep=&#39;;&#39;)

            columns = df.columns
            theta = (df[columns[0]]*np.pi/180).values.reshape(72,37)
            phi = (df[columns[1]]*np.pi/180).values.reshape(72,37)
            modGrlzdB = df[columns[2]]
            mFt = df[columns[3]]
            pFt = df[columns[4]]
            mFp = df[columns[5]]
            pFp = df[columns[6]]
            ratiodB = df[columns[7]]
            Ft = (10**(mFt/20)*np.exp(1j*pFt*np.pi/180)).values.reshape(72,37)
            Fp = (10**(mFp/20)*np.exp(1j*pFp*np.pi/180)).values.reshape(72,37)
            Ft = Ft.swapaxes(0,1)
            Fp = Fp.swapaxes(0,1)
            try:
                tFt=np.concatenate((tFt,Ft[...,None]),axis=2)
                tFp=np.concatenate((tFp,Fp[...,None]),axis=2)
            except:
                tFt=Ft[...,None]
                tFp=Fp[...,None]
        self.phi = phi[:,0]
        self.theta = theta[0,:]
        self.nth = len(self.theta)
        self.nph = len(self.phi)
        Ft = tFt
        Fp = tFp 
        return Ft,Fp

    def __pHertz(self,**kwargs):
        &quot;&quot;&quot; Hertz dipole

        param = {&#39;param&#39;:{&#39;le&#39;:np.array([0,0,1])}}
        le unit vector defining the dipole orientation

        &quot;&quot;&quot;
        defaults = {&#39;param&#39;:{&#39;le&#39;:np.array([0,0,1])}}


        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        #k = 2*np.pi*self.fGHz[None,None,None,:]/0.3
        param=kwargs[&#39;param&#39;]

        if self.grid:
            le = param[&#39;le&#39;][:,None,None]
            xr = np.sin(self.theta)[None,:,None]*np.cos(self.phi)[None,None,:]
            yr = np.sin(self.theta)[None,:,None]*np.sin(self.phi)[None,None,:]
            zr = np.cos(self.theta)[None,:,None]*np.ones(len(self.phi))[None,None,:]
            r = np.concatenate((xr,yr,zr),axis=0)

            xp = -np.sin(self.phi)[None,None,:]*np.ones(len(self.theta))[None,:,None]
            yp =  np.cos(self.phi)[None,None,:]*np.ones(len(self.theta))[None,:,None]
            zp = np.zeros(len(self.phi))[None,None,:]*np.ones(len(self.theta))[None,:,None]
            ph = np.concatenate((xp,yp,zp),axis=0)

            xt = np.cos(self.theta)[None,:,None]*np.cos(self.phi)[None,None,:]
            yt = np.cos(self.theta)[None,:,None]*np.sin(self.phi)[None,None,:]
            zt = -np.sin(self.theta)[None,:,None]*np.ones(len(self.phi))[None,None,:]
            th = np.concatenate((xt,yt,zt),axis=0)

            vec = le - np.einsum(&#39;kij,kij-&gt;ij&#39;,le,r)[None,...]*r
            #G = 1j*30*k*vec
            Ft = np.sqrt(3/2.)*np.einsum(&#39;kij,kij-&gt;ij&#39;,vec,th)[...,None]
            Fp = np.sqrt(3/2.)*np.einsum(&#39;kij,kij-&gt;ij&#39;,vec,ph)[...,None]
        else:
            le = param[&#39;le&#39;][:,None]
            xr = np.sin(self.theta)*np.cos(self.phi)
            yr = np.sin(self.theta)*np.sin(self.phi)
            zr = np.cos(self.theta)
            r = np.concatenate((xr,yr,zr),axis=0)

            xp = -np.sin(self.phi)
            yp =  np.cos(self.phi)
            zp = np.zeros(len(self.phi))
            ph = np.concatenate((xp,yp,zp),axis=0)

            xt = np.cos(self.theta)*np.cos(self.phi)
            yt = np.cos(self.theta)*np.sin(self.phi)
            zt = -np.sin(self.theta)
            th = np.concatenate((xt,yt,zt),axis=0)

            vec = le - np.einsum(&#39;ki,ki-&gt;i&#39;,le,r)[None,...]*r
            #G = 1j*30*k*vec
            Ft = np.sqrt(3/2.)*np.einsum(&#39;ki,ki-&gt;i&#39;,vec,th)[...,None]
            Fp = np.sqrt(3/2.)*np.einsum(&#39;ki,ki-&gt;i&#39;,vec,ph)[...,None]

        return Ft,Fp

    def __pHuygens(self,**kwargs):
        &quot;&quot;&quot; Huygens source

        param : dict

        le : direction of electric current
        n  : normal to aperture
        &quot;&quot;&quot;
        defaults = {&#39;param&#39;:{&#39;le&#39;:np.array([0,0,1]),
                             &#39;n&#39;:np.array([1,0,0])}}


        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        #k = 2*np.pi*self.fGHz[None,None,None,:]/0.3
        param=kwargs[&#39;param&#39;]

        if self.grid:
            le = param[&#39;le&#39;][:,None,None]
            n  = param[&#39;n&#39;][:,None,None]
            xr = np.sin(self.theta)[None,:,None]*np.cos(self.phi)[None,None,:]
            yr = np.sin(self.theta)[None,:,None]*np.sin(self.phi)[None,None,:]
            zr = np.cos(self.theta)[None,:,None]*np.ones(len(self.phi))[None,None,:]
            r = np.concatenate((xr,yr,zr),axis=0)

            xp = -np.sin(self.phi)[None,None,:]*np.ones(len(self.theta))[None,:,None]
            yp =  np.cos(self.phi)[None,None,:]*np.ones(len(self.theta))[None,:,None]
            zp = np.zeros(len(self.phi))[None,None,:]*np.ones(len(self.theta))[None,:,None]
            ph = np.concatenate((xp,yp,zp),axis=0)

            xt = np.cos(self.theta)[None,:,None]*np.cos(self.phi)[None,None,:]
            yt = np.cos(self.theta)[None,:,None]*np.sin(self.phi)[None,None,:]
            zt = -np.sin(self.theta)[None,:,None]*np.ones(len(self.phi))[None,None,:]
            th = np.concatenate((xt,yt,zt),axis=0)

            vec1 = le - np.einsum(&#39;kij,kij-&gt;ij&#39;,le,r)[None,...]*r
            cro1 = np.cross(le,n,axisa=0,axisb=0,axisc=0)
            vec2 = np.cross(cro1,r,axisa=0,axisb=0,axisc=0)
            vec  = vec1-vec2

            #G = 1j*30*k*vec
            Ft = np.sqrt(3/4.)*np.einsum(&#39;kij,kij-&gt;ij&#39;,vec,th)[...,None]
            Fp = np.sqrt(3/4.)*np.einsum(&#39;kij,kij-&gt;ij&#39;,vec,ph)[...,None]
            #Ft = np.einsum(&#39;kij,kij-&gt;ij&#39;,vec,th)[...,None]
            #Fp = np.einsum(&#39;kij,kij-&gt;ij&#39;,vec,ph)[...,None]
        else:
            le = param[&#39;le&#39;][:,None]
            xr = np.sin(self.theta)*np.cos(self.phi)
            yr = np.sin(self.theta)*np.sin(self.phi)
            zr = np.cos(self.theta)
            r = np.concatenate((xr,yr,zr),axis=0)

            xp = -np.sin(self.phi)
            yp =  np.cos(self.phi)
            zp = np.zeros(len(self.phi))
            ph = np.concatenate((xp,yp,zp),axis=0)

            xt = np.cos(self.theta)*np.cos(self.phi)
            yt = np.cos(self.theta)*np.sin(self.phi)
            zt = -np.sin(self.theta)
            th = np.concatenate((xt,yt,zt),axis=0)

            vec1 = le - np.einsum(&#39;ki,ki-&gt;i&#39;,le,r)[None,...]*r
            cro1 = np.cross(le,n,axisa=0,axisb=0,axisc=0)
            vec2 = np.cross(cro1,r,axisa=0,axisb=0,axisc=0)
            vec  = vec1-vec2
            #G = 1j*30*k*vec
            Ft = np.sqrt(3)*np.einsum(&#39;ki,ki-&gt;i&#39;,vec,th)[...,None]
            Fp = np.sqrt(3)*np.einsum(&#39;ki,ki-&gt;i&#39;,vec,ph)[...,None]

        return Ft,Fp

    def __pArray(self,**kwargs):
        &quot;&quot;&quot; Array factor

        Parameters
        ----------

        Sc : np.array
            coupling S matrix

        Notes
        -----

        Nd : Number of directions
        Np : Number of points (antenna elements)
        Nf : Number of frequency
        Nb : Number of beams

        &quot;&quot;&quot;

        defaults = {&#39;param&#39;:{&#39;Sc&#39;:[]}}

        if &#39;param&#39; not in kwargs or kwargs[&#39;param&#39;]=={}:
            kwargs[&#39;param&#39;]=defaults[&#39;param&#39;]

        self.param = kwargs[&#39;param&#39;]

        lamda = (0.3/self.fGHz)
        k     = 2*np.pi/lamda

        if self.grid:
            sx = np.sin(self.theta[:,None])*np.cos(self.phi[None,:])    # Ntheta x Nphi
            sy = np.sin(self.theta[:,None])*np.sin(self.phi[None,:])    # Ntheta x Nphi
            sz = np.cos(self.theta[:,None])*np.ones(len(self.phi))[None,:]   # Ntheta x Nphi
            sx = sx.reshape(self.nth*self.nph)
            sy = sy.reshape(self.nth*self.nph)
            sz = sz.reshape(self.nth*self.nph)
        else:
            sx = np.sin(self.theta)*np.cos(self.phi)    # ,Nd
            sy = np.sin(self.theta)*np.sin(self.phi)    # ,Nd
            sz = np.cos(self.theta)                     # ,Nd

        self.s  = np.vstack((sx,sy,sz)).T         # Nd x 3
        #
        # F = exp(+jk s.p)
        #

        lshp = np.array(self.p.shape)
        if len(lshp)&gt;2:
            Np = np.prod(lshp[1:])
            p = self.p.reshape(3,Np)
        else:
            p = self.p

        Np = p.shape[1]
        self.Sc = self.param[&#39;Sc&#39;]
        if self.Sc==[]:
            # Sc : Np x Np x Nf
            self.Sc = np.eye(Np)[...,None]
            #Sc2 = np.random.rand(Np,Np)[...,None]
            #pdb.set_trace()

        #
        # Get the weights 
        #
        #   w :  b x a x f 
        lshw = np.array(self.w.shape)
        if len(lshw)&gt;2:
            Np2 = np.prod(lshw[0:-1])
            assert(Np2==Np)
            w = self.w.reshape(Np,lshw[-1])
        else:
            w = self.w
        # s : Nd x 3
        # p : 3 x Np
        #
        # sdotp : Nd x Np

        sdotp  = np.dot(self.s,p)   # s . p

        for a in self.la:
            if not self.grid:
                a.eval(grid=self.grid,ph=self.phi,th=self.theta)
            else:
                a.eval(grid=self.grid)
            # aFt : Nt x Np x Nf  |Nd x Nf
            # aFp : Nt x Np x Nf  |Nd x Nf
            aFt = a.Ft
            aFp = a.Fp
        #
        # Force conversion to Nd x Nf
        #

        shF = aFt.shape
        aFt = aFt.reshape(np.prod(shF[0:-1]),shF[-1])
        aFp = aFp.reshape(np.prod(shF[0:-1]),shF[-1])

        #
        # Same pattern on each point
        #
        aFt = aFt[:,None,:]
        aFp = aFp[:,None,:]

        #
        # Nf : frequency
        # Nd : direction
        # Np : points or array antenna element position
        # Nb : number of beams  
        #
        # w  : Np x Nf
        # Sc : Np x Np x Nf
        #
        #
        # w&#39; = w.Sc   Np x  Nf
        #
        # Coupling is implemented here

        # Rules : The repeated index k is the common dimension of the product
        # w    :  Np(k) x Nf(i)
        # Sc   :  Np(k) x Np(m) x Nf(i)
        # wp   :  Np(m) x Nf(i)
        wp = np.einsum(&#39;ki,kmi-&gt;mi&#39;,w,self.Sc)

        # add direction axis (=0) in w

        #if len(.w.shape)==3:
        #    self.wp   = self.wp[None,:,:,:]

        # aFT :  Nd x Np x Nf
        # E   :  Nd x Np x Nf

        E    = np.exp(1j*k[None,None,:]*sdotp[:,:,None])

        #
        # wp  : Np x Nf 
        # Fp  : Nd x Np x Nf
        # Ft  : Nd x Np x Nf
        #
        Ft = wp[None,...]*aFt*E
        Fp = wp[None,...]*aFp*E

        if self.grid:
        #
        # Integrate over the Np points (axis =1)
        # only if self.grid
        # Fp  : Nd x Nf
        # Ft  : Nd x Nf
        #
            Ft = np.sum(Ft,axis=1)
            Fp = np.sum(Fp,axis=1)
            sh = Ft.shape
            Ft = Ft.reshape(self.nth,self.nph,sh[1])
            Fp = Fp.reshape(self.nth,self.nph,sh[1])

        return Ft,Fp

<div class="viewcode-block" id="Pattern.radF"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Pattern.html#pylayers.antprop.antenna.Pattern.radF">[docs]</a>    def radF(self):
        &quot;&quot;&quot; evaluate radiation fonction w.r.t polarization

        self.pol : &#39;t&#39; : theta , &#39;p&#39; : phi n, &#39;c&#39; : circular

        &quot;&quot;&quot;
        assert self.pol in [&#39;t&#39;,&#39;p&#39;,&#39;c&#39;]

        if self.pol==&#39;p&#39;:
            Fp = self.sqG
            Ft = np.zeros(Fp.shape)
            #if len(self.sqG.shape)==3:
            #    Ft = np.array([0])*np.ones(len(self.fGHz))[None,None,:]
            #else:
            #    Ft = np.array([0])*np.ones(len(self.fGHz))[None,:]

        if self.pol==&#39;t&#39;:
            #if len(self.sqG.shape)==3:
            #    Fp = np.array([0])*np.ones(len(self.fGHz))[None,None,:]
            #else:
            #    Fp = np.array([0])*np.ones(len(self.fGHz))[None,:]
            Ft = self.sqG
            Fp = np.zeros(Ft.shape)

        if self.pol==&#39;c&#39;:
            Fp = (1./np.sqrt(2))*self.sqG
            Ft = (1j/np.sqrt(2))*self.sqG

        return Ft,Fp</div>

<div class="viewcode-block" id="Pattern.gain"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Pattern.html#pylayers.antprop.antenna.Pattern.gain">[docs]</a>    def gain(self):
        &quot;&quot;&quot;  calculates antenna gain

        Notes
        -----

        This function updates the following attributes

        + self.G  : np.array(Nt,Np,Nf) dtype:float
            linear gain
                  or np.array(Nr,Nf)
        + self.sqG : np.array(Nt,Np,Nf) dtype:float
            linear sqare root of gain
                  or np.array(Nr,Nf)
        + self.efficiency : np.array (,Nf) dtype:float
            efficiency 
        + self.hpster : np.array (,Nf) dtype:float
            half power solid angle :  1 ~ 4pi steradian 
        + self.ehpbw : np.array (,Nf) dtyp:float 
            equivalent half power beamwidth (radians)


        .. math:: G(\\theta,\\phi) = |F_{\\theta}|^2 + |F_{\\phi}|^2

        &quot;&quot;&quot;
        self.G = np.real( self.Fp * np.conj(self.Fp)
                       +  self.Ft * np.conj(self.Ft))



        if self.grid:
            dt = self.theta[1]-self.theta[0]
            dp = self.phi[1]-self.phi[0]
            Nt = len(self.theta)
            Np = len(self.phi)
            Gs = self.G * np.sin(self.theta)[:, None, None] * np.ones(Np)[None, :, None]
            self.efficiency = np.sum(np.sum(Gs,axis=0),axis=0)*dt*dp/(4*np.pi)

            self.sqG = np.sqrt(self.G)
            self.GdB = 10*np.log10(self.G)
            # GdBmax (,Nf)
            # Get direction of Gmax and get the polarisation state in that direction
            self.GdBmax = np.max(np.max(self.GdB,axis=0),axis=0)
            #
            # The GdB maximum is determined over all the frequencies
            #
            GdBmax = np.max(self.GdBmax)
            #self.umax = np.array(np.where(self.GdB==self.GdBmax))[:,0]
            self.umax = np.array(np.where(self.GdB==GdBmax))[:,0]
            self.theta_max = self.theta[self.umax[0]]
            self.phi_max = self.phi[self.umax[1]]
            M = geu.SphericalBasis(np.array([[self.theta_max,self.phi_max]]))
            self.sl = M[:,2].squeeze()
            uth = M[:,0]
            uph = M[:,1]

            el = self.Ft[tuple(self.umax)]*uth + self.Fp[tuple(self.umax)]*uph
            eln = el/np.linalg.norm(el)
            self.el = eln.squeeze()
            self.hl = np.cross(self.sl,self.el)
            #assert((self.efficiency&lt;1.0).all()),pdb.set_trace()
            self.hpster=np.zeros(len(self.fGHz))
            self.ehpbw=np.zeros(len(self.fGHz))
            for k in range(len(self.fGHz)):
                U  = np.zeros((Nt,Np))
                A = self.GdB[:,:,k]*np.ones(Nt)[:,None]*np.ones(Np)[None,:]
                u = np.where(A&gt;(self.GdBmax[k]-3))
                U[u] = 1
                V  = U*np.sin(self.theta)[:,None]
                self.hpster[k] = np.sum(V)*dt*dp/(4*np.pi)
                self.ehpbw[k] = np.arccos(1-2*self.hpster[k])
        else:
            self.sqG = np.sqrt(self.G)
            self.GdB = 10*np.log10(self.G)</div>

<div class="viewcode-block" id="Pattern.plotG"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Pattern.html#pylayers.antprop.antenna.Pattern.plotG">[docs]</a>    def plotG(self,**kwargs):
        &quot;&quot;&quot; antenna plot gain in 2D

        Parameters
        ----------

        fGHz : frequency
        plan : &#39;theta&#39; | &#39;phi&#39; depending on the selected plan to be displayed
        angdeg : phi or theta in degrees, if plan==&#39;phi&#39; it corresponds to theta
        GmaxdB :  max gain to be displayed (20)
        polar : boolean
        dyn : 8 ,
        legend : True,
        polar : boolean
            linear or polar representation
        topos : False,
        source :satimo,
        show : True,
        mode : string
            &#39;index&#39; |
        color: string
            &#39;black&#39;

        Returns
        -------

        fig
        ax

        Notes
        -----

        self.nth and self.nph has to be correctly set

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; import matplotlib.pyplot as plt
            &gt;&gt;&gt; from pylayers.antprop.antenna import *
            &gt;&gt;&gt; A = Antenna(&#39;defant.vsh3&#39;)
            &gt;&gt;&gt; fig,ax = A.plotG(fGHz=[2,3,4],plan=&#39;theta&#39;,angdeg=0)
            &gt;&gt;&gt; fig,ax = A.plotG(fGHz=[2,3,4],plan=&#39;phi&#39;,angdeg=90)

        &quot;&quot;&quot;

        if not self.evaluated:
            self.eval(pattern=True)

        dtr = np.pi/180.

        defaults = {&#39;fGHz&#39; : [],
                    &#39;dyn&#39; : 8 ,
                    &#39;plan&#39;: &#39;phi&#39;,
                    &#39;angdeg&#39; : 90,
                    &#39;legend&#39;:True,
                    &#39;GmaxdB&#39;:20,
                    &#39;polar&#39;:True,
                    &#39;topos&#39;:False,
                    &#39;source&#39;:&#39;satimo&#39;,
                    &#39;show&#39;:True,
                    &#39;mode&#39;:&#39;index&#39;,
                    &#39;color&#39;:&#39;black&#39;,
                    &#39;u&#39;:0,
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        args = {}
        for k in kwargs:
            if k not in defaults:
                args[k] = kwargs[k]

        if &#39;fig&#39; not in kwargs:
            fig = plt.figure(figsize=(8, 8))
        else:
            fig = kwargs[&#39;fig&#39;]

        if &#39;ax&#39; not in kwargs:
            #ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True, facecolor=&#39;#d5de9c&#39;)
            if kwargs[&#39;polar&#39;]:
                ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True )
            else:
                ax = fig.add_subplot(111)
        else:
            ax = kwargs[&#39;ax&#39;]

        u = kwargs[&#39;u&#39;]
        rc(&#39;grid&#39;, color=&#39;#316931&#39;, linewidth=1, linestyle=&#39;-&#39;)
        rc(&#39;xtick&#39;, labelsize=15)
        rc(&#39;ytick&#39;, labelsize=15)

        DyndB = kwargs[&#39;dyn&#39;] * 5
        GmindB = kwargs[&#39;GmaxdB&#39;] - DyndB
        #print &quot;DyndB&quot;,DyndB
        #print &quot;GmindB&quot;,GmindB

        # force square figure and square axes looks better for polar, IMO

        t1 = np.arange(5, DyndB + 5, 5)
        t2 = np.arange(GmindB + 5, kwargs[&#39;GmaxdB&#39;] + 5, 5)

        col = [&#39;k&#39;, &#39;r&#39;, &#39;g&#39;, &#39;b&#39;, &#39;m&#39;, &#39;c&#39;, &#39;y&#39;]
        cpt = 0

        #if len(self.fGHz) &gt; 1 :
        #    fstep = self.fGHz[1]-self.fGHz[0]
        #else :
        #    fstep = np.array((abs(self.fGHz-kwargs[&#39;fGHz&#39;][0])+1))
        #dtheta = self.theta[1,0]-self.theta[0,0]
        #dphi = self.phi[0,1]-self.phi[0,0]
        dtheta = self.theta[1]-self.theta[0]
        dphi = self.phi[1]-self.phi[0]

        if kwargs[&#39;fGHz&#39;]==[]:
            lfreq = [self.fGHz[0]]
        else:
            lfreq = kwargs[&#39;fGHz&#39;]

        for f in lfreq:
            df  = abs(self.fGHz-f)
            ik0 = np.where(df==min(df))
            ik = ik0[0][0]
            #ik=0
            chaine = &#39;f = %3.2f GHz&#39; %(self.fGHz[ik])
            # all theta
            if kwargs[&#39;plan&#39;]==&#39;theta&#39;:
                itheta = np.arange(self.nth)
                iphi1 = np.where(abs(self.phi-kwargs[&#39;angdeg&#39;]*dtr)&lt;dphi)[0][0]
                Np = self.nph
                #   0 &lt;= theta  &lt;= pi/2
                u1 = np.where((self.theta &lt;= np.pi / 2.) &amp; (self.theta &gt;= 0))[0]
                #   0 &lt; theta &lt; pi
                u2 = np.arange(self.nth)
                #   pi/2 &lt; theta  &lt;= pi
                u3 = np.nonzero((self.theta &lt;= np.pi) &amp; ( self.theta &gt; np.pi / 2))[0]

                #
                # handle broadcasted axis =1 --&gt; index 0
                shsqG = self.sqG.shape
                if shsqG[0]==1:
                    u1 = 0
                    u2 = 0
                    u3 = 0
                if shsqG[1]==1:
                    iphi1 = 0
                    iphi2 = 0
                if len(shsqG)==3:  # if only one frequency point
                    if shsqG[2]==1:
                        ik = 0
                else:
                    if shsqG[3]==1:
                        ik = 0

                # handle parity
                if np.mod(Np, 2) == 0:
                    iphi2 = np.mod(iphi1 + int(Np / 2), Np)
                else:
                    iphi2 = np.mod(iphi1 + int((Np - 1) / 2), Np)

                if len(shsqG)==3:
                    arg1 = (u1,iphi1,ik)
                    arg2 = (u2,iphi2,ik)
                    arg3 = (u3,iphi1,ik)
                else:
                    if shsqG[3]==1:
                        u = 0
                    arg1 = (u1,iphi1,u,ik)
                    arg2 = (u2,iphi2,u,ik)
                    arg3 = (u3,iphi1,u,ik)

                # polar diagram
                #pdb.set_trace()
                if kwargs[&#39;polar&#39;]:
                    if kwargs[&#39;source&#39;]==&#39;satimo&#39;:
                        r1 = -GmindB + 20 * np.log10( self.sqG[arg1]+1e-12)
                        r2 = -GmindB + 20 * np.log10( self.sqG[arg2]+1e-12)
                        r3 = -GmindB + 20 * np.log10( self.sqG[arg3]+1e-12)
                        #print max(r1)+GmindB
                        #print max(r2)+GmindB
                        #print max(r3)+GmindB
                    if kwargs[&#39;source&#39;]==&#39;cst&#39;:
                        r1 = -GmindB + 20 * np.log10( self.sqG[arg1]/np.sqrt(30)+1e-12)
                        r2 = -GmindB + 20 * np.log10( self.sqG[arg2]/np.sqrt(30)+1e-12)
                        r3 = -GmindB + 20 * np.log10( self.sqG[arg3]/np.sqrt(30)+1e-12)

                    if type(r1)!= np.ndarray:
                        r1 = np.array([r1])*np.ones(len(self.phi))
                    if type(r2)!= np.ndarray:
                        r2 = np.array([r2])*np.ones(len(self.phi))
                    if type(r3)!= np.ndarray:
                        r3 = np.array([r3])*np.ones(len(self.phi))

                    negr1 = np.nonzero(r1 &lt; 0)
                    negr2 = np.nonzero(r2 &lt; 0)
                    negr3 = np.nonzero(r3 &lt; 0)

                    r1[negr1[0]] = 0
                    r2[negr2[0]] = 0
                    r3[negr3[0]] = 0

                    r = np.hstack((r1[::-1], r2, r3[::-1], r1[-1]))

                    a1 = np.arange(0, 360, 30)
                    a2 = [90, 60, 30, 0, 330, 300, 270, 240, 210, 180, 150, 120]
                    rline2, rtext2 = plt.thetagrids(a1, a2)

                # linear diagram
                else:
                    r1 = 20 * np.log10( self.sqG[arg1]+1e-12)
                    r2 = 20 * np.log10( self.sqG[arg2]+1e-12)
                    r3 = 20 * np.log10( self.sqG[arg3]+1e-12)

                    r = np.hstack((r1[::-1], r2, r3[::-1], r1[-1]))

                # angular basis for phi
                angle = np.linspace(0, 2 * np.pi, len(r), endpoint=True)
                plt.title(u&#39;$\\theta$ plane&#39;)

            if kwargs[&#39;plan&#39;]==&#39;phi&#39;:
                iphi = np.arange(self.nph)
                itheta = np.where(abs(self.theta-kwargs[&#39;angdeg&#39;]*dtr)&lt;dtheta)[0][0]
                angle = self.phi[iphi]
                if len(self.sqG.shape)==3:
                    arg = [itheta,iphi,ik]
                else:
                    arg = [itheta,iphi,u,ik]
                if kwargs[&#39;polar&#39;]:
                    if np.prod(self.sqG.shape)!=1:
                        r = -GmindB + 20 * np.log10(self.sqG[arg])
                        neg = np.nonzero(r &lt; 0)
                        r[neg] = 0
                    else:
                        r = -GmindB+ 20*np.log10(self.sqG[0,0,0]*np.ones(np.shape(angle)))
               # plt.title(u&#39;H plane - $\phi$ degrees&#39;)
                    a1 = np.arange(0, 360, 30)
                    a2 = [0, 30, 60, 90, 120 , 150 , 180 , 210, 240 , 300 , 330]
                    #rline2, rtext2 = plt.thetagrids(a1, a2)
                else:
                    r =  20 * np.log10(self.sqG[arg])

                plt.title(u&#39;$\\phi$ plane &#39;)
            # actual plotting

            if len(lfreq)&gt;1: 
                ax.plot(angle, r, color=col[cpt], lw=2, label=chaine)
            else:
                ax.plot(angle, r, color=kwargs[&#39;color&#39;], lw=2, label=chaine)
            cpt = cpt + 1

        if kwargs[&#39;polar&#39;]:
            rline1, rtext1 = plt.rgrids(t1, t2)
            #ax.set_rmax(t1[-1])
            #ax.set_rmin(t1[0])
        if kwargs[&#39;legend&#39;]:
            ax.legend()
        if kwargs[&#39;show&#39;]:
            plt.ion()
            plt.show()
        return(fig,ax)</div></div>

<div class="viewcode-block" id="Antenna"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna">[docs]</a>class Antenna(Pattern):
    &quot;&quot;&quot; Antenna

    Attributes
    ----------

    name   : Antenna name

    nf     : number of frequency
    nth    : number of theta
    nph    : number of phi

    Ft     : Normalized Ftheta    (ntheta,nphi,nf)
    Fp     : Normalized Fphi      (ntheta,nphi,nf)
    sqG    : square root of gain  (ntheta,nphi,nf)


    theta  : theta base            1 x ntheta
    phi    : phi base              1 x phi

    C      : VSH Coefficients

    Methods
    -------

    info  : Display information about antenna
    vsh   : calculates Vector Spherical Harmonics
    show3 : Geomview diagram
    plot3d : 3D diagram plotting using matplotlib toolkit

    Antenna trx file can be stored in various order
        natural : HFSS
        ncp     : near filed chamber

    It is important when initializing an antenna object
    to be aware of the typ of trx file

    .trx (ASCII Vectorial antenna Pattern)

    F   Phi   Theta  Fphi  Ftheta

    &quot;&quot;&quot;


    def __init__(self,typ=&#39;Omni&#39;,**kwargs):
        &quot;&quot;&quot; class constructor

        Parameters
        ----------

        typ  : &#39;Omni&#39;,&#39;Gauss&#39;,&#39;WirePlate&#39;,&#39;3GPP&#39;,&#39;atoll&#39;

        _filename : string
                    antenna file name
        directory : str
                    antenna subdirectory of the current project
                    the file is seek in the $BASENAME/ant directory
        nf        : integer
                     number of frequency 
        ntheta    : integer
                    number of theta (default 181)
        nphi      : integer
                    number of phi (default 90)
        source    : string
                source of data { &#39;satimo&#39; | &#39;cst&#39; | &#39;hfss&#39; }

        Notes
        -----

        The supported data formats for storing antenna patterns are

        &#39;mat&#39;: Matlab File
        &#39;vsh2&#39;: unthresholded vector spherical coefficients
        &#39;vsh3&#39;: thresholded vector spherical cpoefficients
        &#39;atoll&#39;: Atoll antenna file format
        &#39;trx&#39; : Satimo NFC raw data
        &#39;trx1&#39; : Satimo NFC raw data  (deprecated)

         A = Antenna(&#39;my_antenna.mat&#39;)

        &quot;&quot;&quot;
        defaults = {&#39;directory&#39;: &#39;ant&#39;,
                    &#39;source&#39;:&#39;satimo&#39;,
                    &#39;ntheta&#39;:90,
                    &#39;nphi&#39;:181,
                    &#39;L&#39;:90, # L max
                    &#39;param&#39;:{},
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        if &#39;fGHz&#39; in kwargs:
            if type(kwargs[&#39;fGHz&#39;])==np.ndarray:
                self.fGHz=kwargs[&#39;fGHz&#39;]
            else:
                self.fGHz=np.array([kwargs[&#39;fGHz&#39;]])


        #mayavi selection
        self._is_selected=False


        self.source = kwargs[&#39;source&#39;]

        self.param = kwargs[&#39;param&#39;]

        # super(Antenna,self).__init__()
        #Pattern.__init__(self)
        #
        # if typ string has an extension it is a file
        #
        if isinstance(typ,str):
            AntennaName,Extension = os.path.splitext(typ)
            self.ext = Extension[1:]
            if self.ext==&#39;&#39;:
                self.fromfile = False
            else:
                self.fromfile = True
        else:
            self.fromfile = True

        self.tau = 0
        self.evaluated = False
        #determine if pattern for all theta/phi is constructed

        if self.fromfile:
            if isinstance(typ,str):
                self._filename = typ
                if self.ext == &#39;vsh3&#39;:
                    self.typ=&#39;vsh3&#39;
                    self.loadvsh3()
                if self.ext == &#39;vsh2&#39;:
                    self.typ=&#39;vsh2&#39;
                    self.loadvsh2()
                if self.ext == &#39;sh3&#39;:
                    self.typ=&#39;sh3&#39;
                    self.loadsh3()
                if self.ext == &#39;sh2&#39;:
                    self.typ=&#39;sh2&#39;
                    self.loadsh2()
                if self.ext == &#39;trx1&#39;:
                    self.typ=&#39;trx&#39;
                    self.load_trx(kwargs[&#39;directory&#39;],self.nf,self.nth,self.nph)
                if self.ext == &#39;trx&#39;:
                    self.typ=&#39;trx&#39;
                    self.loadtrx(kwargs[&#39;directory&#39;],kwargs[&#39;param&#39;])
                if self.ext == &#39;mat&#39;:
                    self.typ=&#39;mat&#39;
                    self.loadmat(kwargs[&#39;directory&#39;])
                if self.ext == &#39;cst&#39;:
                    self.typ=&#39;cst&#39;
                if self.ext == &#39;txt&#39;:
                    self.typ=&#39;atoll&#39;
                    self.load_atoll(kwargs[&#39;directory&#39;])
            elif isinstance(typ,list):
                self._filename = typ
                self.ext=&#39;hfss&#39;
                self.loadhfss(typ, self.nth, self.nph)

        else: # not from file
            self.typ = typ
            self._filename = typ
            if self.typ==&#39;vsh3&#39;:
                self.initvsh()
            else:
                self.eval()

    def __repr__(self):
        st = &#39;&#39;
        st = st + &#39;type : &#39; + self.typ +&#39;\n&#39;
        st = st+&#39;------------------------\n&#39;
        if &#39;param&#39; in self.__dict__:
            for k in self.param:
                st = st + &#39; &#39; + k + &#39; : &#39; + str(self.param[k])+&#39;\n&#39;
        if hasattr(self,&#39;atoll&#39;):
            for k1 in list(dict(self.atoll).keys()):
                st = st + str(k1)+&#39;\n&#39;
                for k2 in self.atoll[k1]:
                    st = st + &#39; &#39;+ str(k2)+&#39;\n&#39;
        st = st+&#39;------------------------\n&#39;
        rtd = 180./np.pi
        if self.fromfile:
            if isinstance(self._filename,str):
                st = st + &#39;file name : &#39; + self._filename+&#39;\n&#39;
            else:
                for i in range(len(self._filename)):
                    st = st + &#39;FileName : &#39; + self._filename[i]+&#39;\n&#39;
#        #st = st + &#39;file type : &#39; + self.typ+&#39;\n&#39;
        if &#39;fGHz&#39; in self.__dict__:
            st = st + &quot;fmin : %4.2f&quot; % (self.fGHz[0]) + &quot;GHz\n&quot;
            st = st + &quot;fmax : %4.2f&quot; % (self.fGHz[-1]) + &quot;GHz\n&quot;
            try:
                st = st + &quot;step : %4.2f&quot; % (1000*(self.fGHz[1]-self.fGHz[0])) + &quot;MHz\n&quot;
            except:
                st = st + &quot;step : None\n&quot;
            st = st + &quot;Nf : %d&quot; % (len(self.fGHz)) +&quot;\n&quot;
#
#

        if hasattr(self,&#39;C&#39;):
            st = st + self.C.__repr__()

        if hasattr(self,&#39;S&#39;):
            st = st + self.S.__repr__()

        if self.evaluated:
            st = st + &#39;-----------------------\n&#39;
            st = st + &#39;      evaluated        \n&#39;
            st = st + &#39;-----------------------\n&#39;
            st = st + &quot;Ntheta : %d&quot; % (self.nth) + &quot;\n&quot;
            st = st + &quot;Nphi : %d&quot; % (self.nph) + &quot;\n&quot;
#                kwargs[k] = defaults[k]

            u = np.where(self.sqG==self.sqG.max())
            if self.grid:
                if len(u[0])&gt;1:
                    S = self.sqG[(u[0][0],u[1][0],u[2][0])]
                    ut = u[0][0]
                    up = u[1][0]
                    uf = u[2][0]
                else:
                    S = self.sqG[u]
                    ut = u[0]
                    up = u[1]
                    uf = u[2]
            else:
                if len(u[0])&gt;1:
                    S = self.sqG[(u[0][0],u[1][0])]
                    ud = u[0][0]
                    uf = u[1][0]
                else:
                    S = self.sqG[u]
                    ud = u[0]
                    uf = u[1]

            st = st + &quot;GdBmax :&quot;+str(self.GdBmax[0])+&#39; &#39;+str(self.GdBmax[-1])+&#39;\n&#39;
            st = st + &quot;Gmax direction : .sl&quot; + str(self.sl)+&#39;\n&#39;
            st = st + &quot;Orientation of E field in Gmax direction : .el &quot; + str(self.el)+&#39;\n&#39;
            st = st + &quot;Orientation of H field in Gmax direction : .hl &quot; + str(self.hl)+&#39;\n&#39;
            st = st + &quot;effective HPBW : .ehpbw &quot; + str(self.ehpbw[0])+&#39; &#39;+str(self.ehpbw[-1])+&#39;\n&#39;

            if self.source==&#39;satimo&#39;:
                GdB = 20*np.log10(S)
            # see WHERE1 D4.1 sec 3.1.1.2.2
            if self.source==&#39;cst&#39;:
                GdB = 20*np.log10(S/np.sqrt(30))
            #st = st + &quot;GmaxdB : %4.2f dB \n&quot; % (GdB)
            st = st + &quot;   f = %4.2f GHz \n&quot; % (self.fGHz[uf])
            if self.grid:
                st = st + &quot;   theta = %4.2f (degrees) \n&quot; % (self.theta[ut]*rtd)
                st = st + &quot;   phi = %4.2f  (degrees) \n&quot; % (self.phi[up]*rtd)
            else:
                st = st + &quot; Ray n :&quot; + str(ud)+&#39; \n&#39;
        else:
            st = st + &#39;Not evaluated\n&#39;
#
#
#        if self.typ == &#39;mat&#39;:
#            #st = st + self.DataFile + &#39;\n&#39;
#            st = st + &#39;antenna name : &#39;+ self.AntennaName + &#39;\n&#39;
#            st = st + &#39;date : &#39; + self.Date +&#39;\n&#39;
#            st = st + &#39;time : &#39; + self.StartTime +&#39;\n&#39;
#            st = st + &#39;Notes : &#39; + self.Notes+&#39;\n&#39;
#            st = st + &#39;Serie : &#39; + str(self.Serie)+&#39;\n&#39;
#            st = st + &#39;Run : &#39; + str(self.Run)+&#39;\n&#39;
#            st = st + &quot;Nb theta (lat) : &quot;+ str(self.nth)+&#39;\n&#39;
#            st = st + &quot;Nb phi (lon) :&quot;+ str(self.nph)+&#39;\n&#39;
#
#        if self.typ == &#39;Gauss&#39;:
#            st = st + &#39;Gaussian pattern&#39; + &#39;\n&#39;
#            st = st + &#39;phi0 : &#39; + str(self.p0) +&#39;\n&#39;
#            st = st + &#39;theta0 :&#39; + str(self.t0) + &#39;\n&#39;
#            st = st + &#39;phi 3dB :&#39; + str(self.p3) + &#39;\n&#39;
#            st = st + &#39;theta 3dB :&#39; + str(self.t3) + &#39;\n&#39;
#            st = st + &#39;Gain dB :&#39; + str(self.GdB) + &#39;\n&#39;
#            st = st + &#39;Gain linear :&#39; + str(self.G ) + &#39;\n&#39;
#            st = st + &#39;sqrt G :&#39; + str(self.sqG) + &#39;\n&#39;

        return(st)

<div class="viewcode-block" id="Antenna.initvsh"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.initvsh">[docs]</a>    def initvsh(self,lmax=45):
        &quot;&quot;&quot; Initialize a void vsh structure

        Parameters
        ----------

        fGHz : array
        lmax : int
            level max

        &quot;&quot;&quot;
        nf = len(self.fGHz)
        Br = 1j * np.zeros((nf, lmax, lmax-1))
        Bi = 1j * np.zeros((nf, lmax, lmax-1))
        Cr = 1j * np.zeros((nf, lmax, lmax-1))
        Ci = 1j * np.zeros((nf, lmax, lmax-1))
        Br = VCoeff(typ=&#39;s1&#39;, fmin=self.fGHz[0], fmax=self.fGHz[-1], data=Br)
        Bi = VCoeff(typ=&#39;s1&#39;, fmin=self.fGHz[0], fmax=self.fGHz[-1], data=Bi)
        Cr = VCoeff(typ=&#39;s1&#39;, fmin=self.fGHz[0], fmax=self.fGHz[-1], data=Cr)
        Ci = VCoeff(typ=&#39;s1&#39;, fmin=self.fGHz[0], fmax=self.fGHz[-1], data=Ci)
        self.C = VSHCoeff(Br, Bi, Cr, Ci)</div>

<div class="viewcode-block" id="Antenna.ls"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.ls">[docs]</a>    def ls(self, typ=&#39;vsh3&#39;):
        &quot;&quot;&quot; list the antenna files in antenna project directory

        Parameters
        ----------

        typ : string optional
            {&#39;mat&#39;|&#39;trx&#39;|&#39;vsh2&#39;|&#39;sh2&#39;|&#39;vsh3&#39;|&#39;sh3&#39;}

        Returns
        -------

        lfile_s : list
            sorted list of all the .str file of strdir

        &quot;&quot;&quot;

        if typ==&#39;vsh3&#39;:
            pathname = pstruc[&#39;DIRANT&#39;] + &#39;/*.&#39; + typ
        if typ==&#39;sh3&#39;:
            pathname = pstruc[&#39;DIRANT&#39;] + &#39;/*.&#39; + typ
        if typ==&#39;mat&#39;:
            pathname = pstruc[&#39;DIRANT&#39;] + &#39;/*.&#39; + typ
        if typ==&#39;trx&#39;:
            pathname = pstruc[&#39;DIRANT&#39;] + &#39;/*.&#39; + typ

        lfile_l = glob.glob(basename+&#39;/&#39;+pathname)
        lfile_s = []
        for fi in lfile_l:
            fis = pyu.getshort(fi)
            lfile_s.append(fis)
        lfile_s.sort()

        return lfile_s</div>


<div class="viewcode-block" id="Antenna.photo"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.photo">[docs]</a>    def photo(self,directory=&#39;&#39;):
        &quot;&quot;&quot; show a picture of the antenna

        Parameters
        ----------

        directory : string

        &quot;&quot;&quot;

        if directory == &#39;&#39;:
            directory = os.path.join(&#39;ant&#39;,&#39;UWBAN&#39;,&#39;PhotosVideos&#39;)

        _filename = &#39;IMG_&#39;+self.PhotoFile.split(&#39;-&#39;)[1]+&#39;.JPG&#39;
        filename = pyu.getlong(_filename,directory)
        I = Image.open(filename)

        I.show()</div>


<div class="viewcode-block" id="Antenna.load_atoll"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.load_atoll">[docs]</a>    def load_atoll(self,directory=&quot;ant&quot;):
        &quot;&quot;&quot; load antenna from Atoll file

        Atoll format provides Antenna gain in the horizontal and vertical plane
        for different frequencies and different tilt values

        Parameters
        ----------

        directory : string

        Notes
        -----

        attol dictionnary is created
        atoll[keyband][polar][&#39;hor&#39;] = Ghor.reshape(360,ct,cf)
        atoll[keyband][polar][&#39;ver&#39;] = Gver.reshape(360,ct,cf)
        atoll[keyband][polar][&#39;tilt&#39;] = np.array(tilt)
        atoll[keyband][polar][&#39;freq&#39;] = np.array(tilt)

        &quot;&quot;&quot;
        _filemat = self._filename
        fileatoll = pyu.getlong(_filemat, directory)
        fd = open(fileatoll)
        lis = fd.readlines()
        tab = []
        for li in lis:
            lispl= li.split(&#39;\t&#39;)
            if (lispl[0]!=&#39;&#39;):
                tab.append(lispl)

        deg_to_rad = np.pi/180.
        lbs_to_kg = 0.45359237
        columns = tab[0]
        #pdb.set_trace()
        for k in np.arange(len(tab)-1):
            df = pd.DataFrame([tab[k+1]],columns=columns)
            try:
                dff=dff.append(df)
            except:
                dff= df
        self.raw = dff
        dff = dff.iloc[:,[0,8,9,10,2,5,7,14,11,16,17,13,6,12]]
        #dff = df[&#39;Name&#39;,&#39;Gain  (dBi)&#39;,&#39;FMin&#39;,&#39;FMax&#39;,&#39;FREQUENCY&#39;,&#39;Pattern&#39;,&#39;V_WIDTH&#39;,&#39;H_WIDTH&#39;,&#39;DIMENSIONS HxWxD   (INCHES)&#39;,&#39;WEIGHT (LBS)&#39;]
        dff.columns = [&#39;Name&#39;,&#39;Fmin&#39;,&#39;Fmax&#39;,&#39;F&#39;,&#39;Gmax&#39;,&#39;G&#39;,&#39;Hpbw&#39;,&#39;H_width&#39;,&#39;V_width&#39;,&#39;HxWxD&#39;,&#39;Weight&#39;,&#39;Tilt&#39;,&#39;Etilt&#39;,&#39;Ftob&#39;]
        dff=dff.apply(lambda x :pd.to_numeric(x,errors=&#39;ignore&#39;))
        #
        # Parse polarization in the field name
        #
        upolarp45 = [&#39;(+45)&#39; in x for x in dff[&#39;Name&#39;]]
        upolarm45 = [&#39;(-45)&#39; in x for x in dff[&#39;Name&#39;]]
        if (sum(upolarp45)&gt;0):
            dff.loc[upolarp45,&#39;Polar&#39;]=45
        if (sum(upolarm45)&gt;0):
            dff.loc[upolarm45,&#39;Polar&#39;]=-45

        atoll = {}
        dfband = dff.groupby([&#39;Fmin&#39;])
        for b in dfband:
            keyband = str(b[0])+&#39;-&#39;+str(b[1][&#39;Fmax&#39;].values[0])
            atoll[keyband]={}  # band
            dfpol = b[1].groupby([&#39;Polar&#39;])
            for p in dfpol:
                atoll[keyband][p[0]] = {} # polar
                dftilt = p[1].groupby([&#39;Tilt&#39;])
                Ghor = np.empty((360,1))  # angle , tilt , frequency
                Gver = np.empty((360,1))  # angle ,
                ct = 0
                tilt = []
                for t in dftilt:
                    dffreq = t[1].groupby([&#39;F&#39;])
                    ct+=1
                    cf=0
                    tilt.append(t[0])
                    freq = []
                    for f in dffreq:
                        freq.append(f[0])
                        cf+=1
                        if len(f[1])==1:
                            df = f[1]
                        else:
                            df = f[1].iloc[0:1]
                        Gmax = df[&#39;Gmax&#39;].values
                        str1 = df.loc[:,&#39;G&#39;].values[0].replace(&#39;  &#39;,&#39; &#39;)
                        lstr = str1.split(&#39; &#39;)
                        Pattern = [ eval(x) for x in lstr[0:-1]]
                        # 4 fist field / # of points
                        Nd,db,dc,Np = Pattern[0:4]
                        #print(Nd,b,c,Np)
                        tmp = np.array(Pattern[4:4+2*Np]).reshape(Np,2)
                        ah   = tmp[:,0]
                        ghor = Gmax-tmp[:,1]
                        # 4 fist field / # of points
                        da,db,dc,dd = Pattern[4+2*Np:4+2*Np+4]
                        #pdb.set_trace()
                        #print a,b,c,d
                        tmp = np.array(Pattern[4+2*Np+4:]).reshape(dc,2)
                        gver = Gmax-tmp[:,0]
                        av = tmp[:,1]
                        try:
                            Ghor = np.hstack((Ghor,ghor[:,None]))
                            Gver = np.hstack((Gver,gver[:,None]))
                        except:
                            pdb.set_trace()
                Ghor = np.delete(Ghor,0,1)
                Gver = np.delete(Gver,0,1)
                atoll[keyband][p[0]][&#39;hor&#39;] = Ghor.reshape(360,ct,cf)
                atoll[keyband][p[0]][&#39;ver&#39;] = Gver.reshape(360,ct,cf)
                atoll[keyband][p[0]][&#39;tilt&#39;] = np.array(tilt)
                atoll[keyband][p[0]][&#39;freq&#39;] = np.array(freq)
        self.atoll = atoll</div>
        # lbands : list of antenna bands

        # Gmax = eval(self.df[&#39;Gain  (dBi)&#39;].values[0])
        #fig = plt.figure()
        #ax =plt.gca(projection=&#39;polar&#39;)
        #ax =plt.gca()
        #ax.plot(H2[:,1]*deg_to_rad,Gain-H2[:,0],&#39;r&#39;,label=&#39;vertical&#39;,linewidth=2)
        #ax.plot(H1[:,0]*deg_to_rad,Gain-H1[:,1],&#39;b&#39;,label=&#39;horizontal&#39;,linewidth=2)
        #ax.set_rmin(-30)
        #plt.title(dir1+&#39;/&#39;+filename+&#39; Gain : &#39;+df[&#39;Gain  (dBi)&#39;].values[0])
        #BXD-634X638XCF-EDIN.txt
        #BXD-636X638XCF-EDIN.txt

<div class="viewcode-block" id="Antenna.loadmat"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.loadmat">[docs]</a>    def loadmat(self, directory=&quot;ant&quot;):
        &quot;&quot;&quot; load an antenna stored in a mat file

        Parameters
        ----------
        directory : str , optional
            default &#39;ant&#39;

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; import matplotlib.pyplot as plt
            &gt;&gt;&gt; from pylayers.antprop.antenna import *
            &gt;&gt;&gt; A = Antenna(&#39;S1R1.mat&#39;,directory=&#39;ant/UWBAN/Matfile&#39;)
            &gt;&gt;&gt; f,a = A.plotG(plan=&#39;theta&#39;,angdeg=0)
            &gt;&gt;&gt; f,a = A.plotG(plan=&#39;phi&#39;,angdeg=90,fig=f,ax=a)
            &gt;&gt;&gt; txt = plt.title(&#39;S1R1 antenna : st loadmat&#39;)
            &gt;&gt;&gt; plt.show()


        &quot;&quot;&quot;
        _filemat = self._filename
        filemat = pyu.getlong(_filemat, directory)
        d = io.loadmat(filemat, squeeze_me=True, struct_as_record=False)
        ext = _filemat.replace(&#39;.mat&#39;, &#39;&#39;)
        d = d[ext]
        #
        #
        #
        self.typ = &#39;mat&#39;
        self.Date = str(d.Date)
        self.Notes = str(d.Notes)
        self.PhotoFile = str(d.PhotoFile)
        self.Serie = eval(str(d.Serie))
        self.Run = eval(str(d.Run))
        self.DataFile = str(d.DataFile)
        self.StartTime = str(d.StartTime)
        self.AntennaName = str(d.AntennaName)

        self.fGHz = d.freq/1.e9
        self.theta = d.theta
        self.phi = d.phi
        self.Ft = d.Ftheta
        self.Fp = d.Fphi

        self.Fp = self.Fp.swapaxes(0, 2)
        self.Fp = self.Fp.swapaxes(0, 1)
        self.Ft = self.Ft.swapaxes(0, 2)
        self.Ft = self.Ft.swapaxes(0, 1)
        Gr = np.real(self.Fp * np.conj(self.Fp) + \
                     self.Ft * np.conj(self.Ft))
        self.sqG = np.sqrt(Gr)
        self.nth = len(self.theta)
        self.nph = len(self.phi)

        if type(self.fGHz) ==  float:
            self.nf = 1
        else:
            self.nf = len(self.fGHz)

        self.evaluated = True
        self.grid = True</div>

<div class="viewcode-block" id="Antenna.load_trx"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.load_trx">[docs]</a>    def load_trx(self, directory=&quot;ant&quot;, nf=104, ntheta=181, nphi=90, ncol=6):
        &quot;&quot;&quot; load a trx file (deprecated)

        Parameters
        ----------
        directory : str
                    directory where is located the trx file (default : ant)
        nf : float
             number of frequency points
        ntheta : float
               number of theta
        nphi : float
               number of phi

        TODO : DEPRECATED (Fix the Ft and Fp format with Nf as last axis)

        &quot;&quot;&quot;
        _filetrx = self._filename
        filename = pyu.getlong(_filetrx, directory)
        if ncol == 6:
            pattern = &quot;&quot;&quot;^.*\t.*\t.*\t.*\t.*\t.*\t.*$&quot;&quot;&quot;
        else:
            pattern = &quot;&quot;&quot;^.*\t.*\t.*\t.*\t.*\t.*\t.*\t.*$&quot;&quot;&quot;
        fd = open(filename, &#39;r&#39;)
        d = fd.read().split(&#39;\r\n&#39;)
        fd.close()
        k = 0
        #while ((re.search(pattern1,d[k]) is None ) &amp; (re.search(pattern2,d[k]) is None )):
        while re.search(pattern, d[k]) is None:
            k = k + 1

        d = d[k:]
        N = len(d)
        del d[N - 1]
        r = &#39;\t&#39;.join(d)
        r.replace(&#39; &#39;, &#39;&#39;)
        d = np.array(r.split()).astype(&#39;float&#39;)

        #
        # TODO Parsing the header
        #
        #nf     = 104
        #nphi   = 90
        #ntheta = 181

        N = nf * nphi * ntheta
        d = d.reshape(N, 7)

        F = d[:, 0]
        PHI = d[:, 1]
        THETA = d[:, 2]
        Fphi = d[:, 3] + d[:, 4] * 1j
        Ftheta = d[:, 5] + d[:, 6] * 1j

        self.Fp = Fphi.reshape((nf, nphi, ntheta))
        self.Ft = Ftheta.reshape((nf, nphi, ntheta))
        Ttheta = THETA.reshape((nf, nphi, ntheta))
        Tphi = PHI.reshape((nf, nphi, ntheta))
        Tf = F.reshape((nf, nphi, ntheta))

        self.Fp = self.Fp.swapaxes(1, 2)
        self.Ft = self.Ft.swapaxes(1, 2)
        Ttheta = Ttheta.swapaxes(1, 2)
        Tphi = Tphi.swapaxes(1, 2)
        Tf = Tf.swapaxes(1, 2)

        self.fGHz = Tf[:, 0, 0]
        self.theta = Ttheta[0, :, 0]
        #self.phi     = Tphi[0,0,:]

        #
        # Temporaire
        #
        A1 = self.Fp[:, 90:181, :]
        A2 = self.Fp[:, 0:91, :]
        self.Fp = np.concatenate((A1, A2[:, ::-1, :]), axis=2)
        A1 = self.Ft[:, 90:181, :]
        A2 = self.Ft[:, 0:91, :]
        self.Ft = np.concatenate((A1, A2[:, ::-1, :]), axis=2)
        self.theta = np.linspace(0, np.pi, 91)
        self.phi = np.linspace(0, 2 * np.pi, 180, endpoint=False)
        self.nth = 91
        self.nph = 180
        self.nf = 104
        self.evaluated = True</div>

<div class="viewcode-block" id="Antenna.pattern"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.pattern">[docs]</a>    def pattern(self,theta=[],phi=[],typ=&#39;s3&#39;):
        &quot;&quot;&quot; return multidimensionnal radiation patterns

        Parameters
        ----------

        theta   : array
            1xNt
        phi     : array
            1xNp
        typ : string
            {s1|s2|s3}

        &quot;&quot;&quot;

        if theta == []:
            theta = np.linspace(0,np.pi,30)
        if phi == []:
            phi = np.linspace(0,2*np.pi,60)

        self.grid = True

        Nt = len(theta)
        Np = len(phi)
        Nf = len(self.fGHz)
        #Th = np.kron(theta, np.ones(Np))
        #Ph = np.kron(np.ones(Nt), phi)
        if typ ==&#39;s1&#39;:
            FTh, FPh = self.Fsynth1(theta, phi)
        if typ ==&#39;s2&#39;:
            FTh, FPh = self.Fsynth2b(theta,phi)
        if typ ==&#39;s3&#39;:
            FTh, FPh = self.Fsynth3(theta, phi)
        #FTh = Fth.reshape(Nf, Nt, Np)
        #FPh = Fph.reshape(Nf, Nt, Np)

        return(FTh,FPh)</div>

<div class="viewcode-block" id="Antenna.coeffshow"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.coeffshow">[docs]</a>    def coeffshow(self,**kwargs):
        &quot;&quot;&quot; display antenna coefficient

            typ : string
                &#39;ssh&#39; |&#39;vsh&#39;
            L  : maximum level
            kf : frequency index
            vmin  : float
            vmax  : float

        &quot;&quot;&quot;
        defaults = {&#39;typ&#39;:&#39;vsh&#39;,
                    &#39;L&#39;:20,
                    &#39;kf&#39;:46,
                    &#39;vmin&#39;:-40,
                    &#39;vmax&#39;:0,
                    &#39;cmap&#39;:cm.hot_r,
                    &#39;dB&#39;:True
                   }
        for k in defaults:
            if k not in kwargs:
                kwargs[k]=defaults[k]

        L  = kwargs[&#39;L&#39;]
        kf = kwargs[&#39;kf&#39;]

        # calculates mode energy
        # linear and log scale
        # E : f , l , m
        if kwargs[&#39;typ&#39;]==&#39;vsh&#39;:
            E  = self.C.energy(typ=&#39;s1&#39;)
        if kwargs[&#39;typ&#39;]==&#39;ssh&#39;:
            E  = self.S.energy(typ=&#39;s1&#39;)

        # Aem : f,l
        # calculates energy integrated over m

        Aem = np.sum(E,axis=2)
        Aem_dB = 10*np.log10(Aem)

        # Ael : f,m
        # calculates energy integrated over l

        Ael = np.sum(E,axis=1)
        Ael_dB = 10*np.log10(Ael)


        fig, ax = plt.subplots()
        fig.set_figwidth(15)
        fig.set_figheight(10)

        if kwargs[&#39;dB&#39;]:
            im = ax.imshow(10*np.log10(E[kf,:,:]),
                           vmin = kwargs[&#39;vmin&#39;],
                           vmax = kwargs[&#39;vmax&#39;],
                           extent =[-L,L,L,0],
                           interpolation = &#39;nearest&#39;,
                           cmap = kwargs[&#39;cmap&#39;])

        divider = make_axes_locatable(ax)
        cax = divider.append_axes(&quot;right&quot;, size=&quot;5%&quot;, pad=0.05)
        axHistx = divider.append_axes(&quot;top&quot;, 1., pad=0.5, sharex=ax)
        axHisty = divider.append_axes(&quot;left&quot;, 1., pad=0.5, sharey=ax)
        #axHistx.bar(range(-L,L),Aem)
        #axHisty.barh(range(0,L),Ael )
        axHistx.yaxis.set_ticks(np.array([0,0.2,0.4,0.6,0.8]))
        axHisty.xaxis.set_ticks(np.array([0,0.1,0.2,0.3]))
        cbar = plt.colorbar(im, cax=cax)
        fig.tight_layout()

        plt.text(-0.02,0.6 ,&#39;levels&#39;,
             horizontalalignment=&#39;right&#39;,
             verticalalignment=&#39;top&#39;,
             transform=ax.transAxes,
             rotation =90, fontsize= 15)

        plt.text(0.6,1.1 ,&#39;free space&#39;,
             horizontalalignment=&#39;right&#39;,
             verticalalignment=&#39;top&#39;,
             transform=ax.transAxes,
             fontsize= 15)

        plt.text(0.55,-0.1 ,&#39;modes&#39;,
             horizontalalignment=&#39;right&#39;
             ,verticalalignment=&#39;top&#39;, transform=ax.transAxes, fontsize= 15)

        return fig,ax</div>


<div class="viewcode-block" id="Antenna.errel"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.errel">[docs]</a>    def errel(self,kf=-1, dsf=1, typ=&#39;s3&#39;):
        &quot;&quot;&quot; calculates error between antenna pattern and reference pattern

        Parameters
        ----------

        kf  : integer
            frequency index. If k=-1 integration over all frequency
        dsf : down sampling factor
        typ :

        Returns
        -------

        errelTh : float
            relative error on :math:`F_{\\theta}`
        errelPh : float
            relative error on :math:`F_{\phi}`
        errel   : float

        Notes
        -----

        .. math::

            \epsilon_r^{\\theta} =
            \\frac{|F_{\\theta}(\\theta,\phi)-\hat{F}_{\\theta}(\\theta,\phi)|^2}
                 {|F_{\\theta}(\\theta,\phi)|^2}

            \epsilon_r^{\phi} =
            \\frac{|F_{\phi}(\\theta,\phi)-\hat{F}_{\phi}(\\theta,\phi)|^2}
                 {|F_{\\theta}(\\theta,\phi)|^2}


        &quot;&quot;&quot;
        #
        # Retrieve angular bases from the down sampling factor dsf
        #
        theta = self.theta[::dsf]
        phi = self.phi[::dsf]
        Nt = len(theta)
        Np = len(phi)

        #Th = np.kron(theta, np.ones(Np))
        #Ph = np.kron(np.ones(Nt), phi)

        if typ ==&#39;s1&#39;:
            FTh, FPh = self.Fsynth1(theta, phi)
        if typ ==&#39;s2&#39;:
            FTh, FPh = self.Fsynth2b(theta, phi)
        if typ ==&#39;s3&#39;:
            FTh, FPh = self.Fsynth3(theta, phi)

        #FTh = Fth.reshape(self.nf, Nt, Np)
        #FPh = Fph.reshape(self.nf, Nt, Np)
        #
        #  Jacobian
        #
        #st    = outer(sin(theta),ones(len(phi)))
        st = np.sin(theta).reshape((len(theta), 1))
        #
        # Construct difference between reference and reconstructed
        #
        if kf!=-1:
            dTh = (FTh[kf, :, :] - self.Ft[kf, ::dsf, ::dsf])
            dPh = (FPh[kf, :, :] - self.Fp[kf, ::dsf, ::dsf])
            #
            # squaring  + Jacobian
            #
            dTh2 = np.real(dTh * np.conj(dTh)) * st
            dPh2 = np.real(dPh * np.conj(dPh)) * st

            vTh2 = np.real(self.Ft[kf, ::dsf, ::dsf] \
                 * np.conj(self.Ft[kf, ::dsf, ::dsf])) * st
            vPh2 = np.real(self.Fp[kf, ::dsf, ::dsf] \
                 * np.conj(self.Fp[kf, ::dsf, ::dsf])) * st

            mvTh2 = np.sum(vTh2)
            mvPh2 = np.sum(vPh2)

            errTh = np.sum(dTh2)
            errPh = np.sum(dPh2)
        else:
            dTh = (FTh[:, :, :] - self.Ft[:, ::dsf, ::dsf])
            dPh = (FPh[:, :, :] - self.Fp[:, ::dsf, ::dsf])
            #
            # squaring  + Jacobian
            #
            dTh2 = np.real(dTh * np.conj(dTh)) * st
            dPh2 = np.real(dPh * np.conj(dPh)) * st

            vTh2 = np.real(self.Ft[:, ::dsf, ::dsf] \
                 * np.conj(self.Ft[:, ::dsf, ::dsf])) * st
            vPh2 = np.real(self.Fp[:, ::dsf, ::dsf] \
                 * np.conj(self.Fp[:, ::dsf, ::dsf])) * st

            mvTh2 = np.sum(vTh2)
            mvPh2 = np.sum(vPh2)

            errTh = np.sum(dTh2)
            errPh = np.sum(dPh2)

        errelTh = (errTh / mvTh2)
        errelPh = (errPh / mvPh2)
        errel =( (errTh + errPh) / (mvTh2 + mvPh2))

        return(errelTh, errelPh, errel)</div>


<div class="viewcode-block" id="Antenna.loadhfss"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.loadhfss">[docs]</a>    def loadhfss(self,lfa = [], Nt=72,Np=37):
        &quot;&quot;&quot; load antenna from HFSS file

        Parameters
        ----------

        lfa : list of antenna file
        Nt  : int
            Number of angle theta
        Np  : int
            Number of angle phi

        Notes
        -----

        One file per frequency point

        th , ph , abs_grlz,th_absdB,th_phase,ph_absdB,ph_phase_ax_ratio

        &quot;&quot;&quot;

        # lfa : list file antenna
        self.nf = len(lfa)
        fGHz  = []
        lacsv = []
        Fphi = np.empty((self.nf,self.nth,self.nph))
        Ftheta = np.empty((self.nf,self.nth,self.nph))
        SqG = np.empty((self.nf,self.nth,self.nph))

        for i in range (len(lfa)):

            fGHz.append(eval(lfa[i].split(&#39;.csv&#39;)[0][-4]))
            lacsv.append(pd.read_csv(lfa[i],
                                     header=False,
                                     sep=&#39;,&#39;,
            names=[&#39;th&#39;,&#39;ph&#39;,&#39;abs_grlz&#39;,&#39;th_absdB&#39;,&#39;th_phase&#39;,&#39;ph_absdB&#39;,&#39;ph_phase&#39;,&#39;ax_ratio&#39;],
                                     index_col=False))

            th=lacsv[i].th.reshape(Np,Nt)*np.pi/180.
            ph=lacsv[i].ph.reshape(Np,Nt)*np.pi/180.
            Greal = lacsv[i].abs_grlz.reshape(Np,Nt)

            th_dB = lacsv[i].th_absdB.reshape(Np,Nt)
            ph_dB = lacsv[i].ph_absdB.reshape(Np,Nt)

            th_lin = pow(10,th_dB/20.)
            ph_lin = pow(10,ph_dB/20.)

            #th_phase = lacsv[i].th_phase.reshape(72,37)*np.pi/180.
            #ph_phase = lacsv[i].ph_phase.reshape(72,37)*np.pi/180.
            #axratio=lacsv[i].ax_ratio.reshape(72,37)
            Fphi[i,:,:] = ph_lin.swapaxes(1,0)
            Ftheta[i,:,:] = th_lin.swapaxes(1,0)
            SqG[i,:,:] = Greal.swapaxes(1,0)


        self.fGHz = np.array(fGHz)
        #self.theta = th[0,:].reshape(Nt,1)
        #self.phi = ph[:,0].reshape(1,Np)
        self.theta = th[0,:]
        self.phi = ph[:,0]
        self.Fp=Fphi
        self.Ft=Ftheta
        self.sqG=SqG</div>



<div class="viewcode-block" id="Antenna.loadtrx"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.loadtrx">[docs]</a>    def loadtrx(self,directory,param={}):
        &quot;&quot;&quot; load trx file (SATIMO Near Field Chamber raw data)

        Parameters
        ----------

        directory

        self._filename: short name of the antenna file

        the file is seek in the $BASENAME/ant directory


        fmin fmax Nf  phmin   phmax   Nphi    thmin    thmax    Ntheta  #EDelay
        0     1   2   3       4       5       6        7        8       9
        1     10  121 0       6.19    72      0        3.14     37      0


        param  : dict
            mode : string
            mode 1 : columns are organized [&#39;f&#39;,&#39;phi&#39;,&#39;th&#39;,&#39;ReFph&#39;,&#39;ImFphi&#39;,&#39;ReFth&#39;,&#39;ImFth&#39;]
            mode 2 : columns are organized [&#39;f&#39;,&#39;phi&#39;,&#39;th&#39;,&#39;GdB&#39;,&#39;GdB_ph&#39;,&#39;GdB_th&#39;]
                    mode2 corresponds to TRXV2


        The measured values of Fp Ft and sqG and the associated theta and phi range
        are stored using the underscore prefix.
        e.g. self._Ft; self._Fp; self._sqG



        Notes
        ------

        for mode 2 :
        it is require to create a header file &quot;header_&lt;_filename&gt;.txt with the structure
        # fmin fmax Nf  phmin   phmax   Nphi    thmin    thmax    Ntheta  #EDelay
        and to remove header for trx file.

        Warning Mode 2 invert automatocally apply _swap_theta_phi !
        &quot;&quot;&quot;


        if param== {}:
            param = {&#39;mode&#39; : 1}

        _filetrx = self._filename
        _headtrx = &#39;header_&#39; + _filetrx
        _headtrx = _headtrx.replace(&#39;trx&#39;, &#39;txt&#39;)
        headtrx = pyu.getlong(_headtrx, directory)
        filename = pyu.getlong(_filetrx, directory)
    #
    # Trx header structure
    #
    # fmin fmax Nf  phmin   phmax   Nphi    thmin    thmax    Ntheta  #EDelay
    # 0     1   2   3       4       5       6        7        8       9
    # 1     10  121 0       6.19    72      0        3.14     37      0
    #
    #
        foh = open(headtrx)
        ligh = foh.read()
        foh.close()
        fmin = eval(ligh.split()[0])
        fmax = eval(ligh.split()[1])
        nf   = eval(ligh.split()[2])
        phmin = eval(ligh.split()[3])
        phmax = eval(ligh.split()[4])
        nphi = eval(ligh.split()[5])
        thmin = eval(ligh.split()[6])
        thmax = eval(ligh.split()[7])
        ntheta = eval(ligh.split()[8])
        #
        # The electrical delay in column 9 is optional
        #
        try:
            tau = eval(ligh.split()[9])  # tau : delay (ns)
        except:
            tau = 0

        #
        # Data are stored in 7 columns in mode 1 
        #
        # 0  1   2     3        4       5       6
        # f  phi th    ReFph   ImFphi  ReFth    ImFth
        #
        #


        fi = open(filename)
        d = np.array(fi.read().split())
        N = len(d)
        if param[&#39;mode&#39;] == 1:
            M = N / 7
            d = d.reshape(M, 7)
        elif param[&#39;mode&#39;] == 2:
            M = N / 6
            d = d.reshape(M, 6)
        d = d.astype(&#39;float&#39;)

        f = d[:, 0]
        if f[0] == 0:
            print(&quot;error : frequency cannot be zero&quot;)
        # detect frequency unit
        # if values are above 2000 its means frequency is not expressed
        # in GHz
        #
        if (f[0] &gt; 2000):
            f = f / 1.0e9


        phi   = d[:, 1]
        theta = d[:, 2]

        #
        # type : refers to the way the angular values are stored in the file
        # Detection of file type
        #
        # nfc
        #    f  phi theta
        #    2    1    0
        # Natural
        #    f  phi theta
        #    2    0    1
        #
        # auto detect storage mode looping
        #
        dphi = abs(phi[0] - phi[1])
        dtheta = abs(theta[0] - theta[1])

        if (dphi == 0) &amp; (dtheta != 0):
            typ = &#39;nfc&#39;
        if (dtheta == 0) &amp; (dphi != 0):
            typ = &#39;natural&#39;

        self.typ = typ

        if param[&#39;mode&#39;]==1:
            Fphi   = d[:, 3] + d[:, 4] * 1j
            Ftheta = d[:, 5] + d[:, 6] * 1j
        elif param[&#39;mode&#39;]==2:
            Fphi   = 10**(d[:, 4]/20)
            Ftheta = 10**(d[:, 5]/20)
        #
        # Normalization
        #
        G = np.real(Fphi * np.conj(Fphi) + Ftheta * np.conj(Ftheta))
        SqG = np.sqrt(G)
        #Fphi    = Fphi/SqG
        #Ftheta  = Ftheta/SqG
        #Fphi    = Fphi
        #Ftheta  = Ftheta
        #
        # Reshaping
        #
        if typ == &#39;natural&#39;:

            self._Fp = Fphi.reshape((nf, ntheta, nphi))
            self._Ft = Ftheta.reshape((nf, ntheta, nphi))
            self._sqG = SqG.reshape((nf, ntheta, nphi))
            Ttheta = theta.reshape((nf, ntheta, nphi))
            Tphi = phi.reshape((nf, ntheta, nphi))
            Tf = f.reshape((nf, ntheta, nphi))
            self._Fp = self.Fp.swapaxes(0, 1).swapaxes(1,2)
            self._Ft = self.Ft.swapaxes(0, 1).swapaxes(1,2)
            self._sqG = self.sqG.swapaxes(0, 1).swapaxes(1,2)
            Ttheta = Ttheta.swapaxes(0, 1).swapaxes(1,2)
            Tphi = Tphi.swapaxes(0, 1).swapaxes(1,2)
            Tf = Tf.swapaxes(0, 1).swapaxes(1,2)


        if typ == &#39;nfc&#39;:
            self._Fp = Fphi.reshape((nf, nphi, ntheta))
            self._Ft = Ftheta.reshape((nf, nphi, ntheta))
            self._sqG = SqG.reshape((nf, nphi, ntheta))
            Ttheta = theta.reshape((nf, nphi, ntheta))
            Tphi = phi.reshape((nf, nphi, ntheta))
            Tf = f.reshape((nf, nphi, ntheta))

        #
        # Force natural order (f,theta,phi)
        # This is not the order of the satimo nfc which is  (f,phi,theta)
        #

            # self.Fp = self.Fp.swapaxes(1, 2)
            # self.Ft = self.Ft.swapaxes(1, 2)
            # self.sqG = self.sqG.swapaxes(1, 2)
            self._Fp = self._Fp.swapaxes(0, 2)
            self._Ft = self._Ft.swapaxes(0, 2)
            self._sqG = self._sqG.swapaxes(0, 2)
            Ttheta = Ttheta.swapaxes(0, 2)
            Tphi = Tphi.swapaxes(0, 2)
            Tf = Tf.swapaxes(0, 2)

        # sqg=np.sqrt(10**(d[:,3]/10))
        # self.sqG=sqg.reshape((nf, nphi, ntheta)).swapaxes(0, 2)

        self._fGHz = Tf[0, 0, :]
        self._theta = Ttheta[:, 0, 0]
        self._phi = Tphi[0, :, 0]
        #
        # check header consistency
        #

        np.testing.assert_almost_equal(self._fGHz[0],fmin,6)
        np.testing.assert_almost_equal(self._fGHz[-1],fmax,6)
        np.testing.assert_almost_equal(self._theta[0],thmin,3)
        np.testing.assert_almost_equal(self._theta[-1],thmax,3)
        np.testing.assert_almost_equal(self._phi[0],phmin,3)
        np.testing.assert_almost_equal(self._phi[-1],phmax,3)

        self._nf = nf
        self._nth = ntheta
        self._nph = nphi
        self._tau = tau


        if param[&#39;mode&#39;]==2:
            self._swap_theta_phi()

        self.evaluated = False</div>


    def _swap_theta_phi(self):
        &quot;&quot;&quot; swapping theta and phi in case where e.g.
            theta in [0, 2*pi] and phi in [0,pi]

            swapping allow to correctly return with the assumption
            where
            theta in [0,pi] and phi [0,2*pi] and allow e.g using vsh
            methods.

        &quot;&quot;&quot;
        assert self._nth&gt;self._nph,&#39;nth &lt; nph so swapping is not possible&#39;

        mid_nth = int(np.ceil(self._nth/2.))
        new_nph = self._nph*2

        #Â process for self.sqG

        B1=self._sqG[:mid_nth,...]#self.sqG[:65,...]
        B2=self._sqG[mid_nth:,...]#self.sqG[65:,...]
        B2i= B2[::-1,...]

        R=np.zeros((mid_nth,new_nph,self._nf))#R=np.zeros((65,128,31))
        R[:,:mid_nth-1,:]=B1         #R[:,:64,:]=B1 
        R[:-1,mid_nth-1:,:]=B2i      #  R[:-1,64:,:]=B2i
        R[-1,mid_nth-1:,:]=B1[-1,:,:]# R[-1,64:,:]=B1[-1,:,:] 
        self._sqG = R


        #Â process for self.Ft
        B1=self._Ft[:mid_nth,...]#self.Ft[:65,...]
        B2=self._Ft[mid_nth:,...]#self.Ft[65:,...]
        B2i= B2[::-1,...]

        R=np.zeros((mid_nth,new_nph,self._nf))#R=np.zeros((65,128,31))
        R[:,:mid_nth-1,:]=B1         #R[:,:64,:]=B1 
        R[:-1,mid_nth-1:,:]=B2i      #  R[:-1,64:,:]=B2i
        R[-1,mid_nth-1:,:]=B1[-1,:,:]# R[-1,64:,:]=B1[-1,:,:] 
        self._Ft = R


        #Â process for self.Fp
        B1=self._Fp[:mid_nth,...]#self.Ft[:65,...]
        B2=self._Fp[mid_nth:,...]#self.Ft[65:,...]
        B2i= B2[::-1,...]

        R=np.zeros((mid_nth,new_nph,self._nf))#R=np.zeros((65,128,31))
        R[:,:mid_nth-1,:]=B1         #R[:,:64,:]=B1 
        R[:-1,mid_nth-1:,:]=B2i      #  R[:-1,64:,:]=B2i
        R[-1,mid_nth-1:,:]=B1[-1,:,:]# R[-1,64:,:]=B1[-1,:,:] 
        self._Fp = R


        #Â update theta,phi
        self._theta = np.linspace(0,np.pi,mid_nth)
        self._phi = np.linspace(0,2*np.pi,new_nph)
        self._nth = mid_nth
        self._nph = new_nph



<div class="viewcode-block" id="Antenna.checkpole"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.checkpole">[docs]</a>    def checkpole(self, kf=0):
        &quot;&quot;&quot; display the reconstructed field on pole for integrity verification

        Parameters
        ----------

        kf : int
             frequency index default 0

        &quot;&quot;&quot;
        Ft0 = self.Ft[kf, 0, :]
        Fp0 = self.Fp[kf, 0, :]
        Ftp = self.Ft[kf, -1, :]
        Fpp = self.Fp[kf, -1, :]
        phi = self.phi

        Ex0 = Ft0 * np.cos(phi) - Fp0 * np.sin(phi)
        Ey0 = Ft0 * np.sin(phi) + Fp0 * np.cos(phi)
        Exp = Ftp * np.cos(phi) - Fpp * np.sin(phi)
        Eyp = Ftp * np.sin(phi) + Fpp * np.cos(phi)

        plt.subplot(4, 2, 1)
        plt.plot(phi, np.real(Ex0))
        plt.subplot(4, 2, 2)
        plt.plot(phi, np.imag(Ex0))
        plt.subplot(4, 2, 3)
        plt.plot(phi, np.real(Ey0))
        plt.subplot(4, 2, 4)
        plt.plot(phi, np.imag(Ey0))
        plt.subplot(4, 2, 5)
        plt.plot(phi, np.real(Exp))
        plt.subplot(4, 2, 6)
        plt.plot(phi, np.imag(Exp))
        plt.subplot(4, 2, 7)
        plt.plot(phi, np.real(Eyp))
        plt.subplot(4, 2, 8)
        plt.plot(phi, np.imag(Eyp))</div>

<div class="viewcode-block" id="Antenna.info"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.info">[docs]</a>    def info(self):
        &quot;&quot;&quot; gives info about antenna object


        &quot;&quot;&quot;
        print(self._filename)
        print(&quot;type : &quot;, self.typ)
        if self.typ == &#39;mat&#39;:
            print(self.DataFile)
            print(self.AntennaName)
            print(self.Date)
            print(self.StartTime)
            print(self.Notes)
            print(self.Serie)
            print(self.Run)
            print(&quot;Nb theta (lat) :&quot;, self.nth)
            print(&quot;Nb phi (lon) :&quot;, self.nph)
        if self.typ ==&#39;nfc&#39;:
            print( &quot;--------------------------&quot;)
            print( &quot;fmin (GHz) :&quot;, self.fGHz[0])
            print( &quot;fmax (GHz) :&quot;, self.fGHz[-1])
            print( &quot;Nf   :&quot;, self.nf)
            print( &quot;thmin (rad) :&quot;, self.theta[0])
            print( &quot;thmax (rad) :&quot;, self.theta[-1])
            print( &quot;Nth  :&quot;, self.nth)
            print( &quot;phmin (rad) :&quot;, self.phi[0])
            print( &quot;phmax (rad) :&quot;, self.phi[-1])
            print( &quot;Nph  :&quot;, self.nph)
        try:
            self.C.info()
        except:
            print(&quot;No vsh coefficient calculated yet&quot;)</div>

    #@mlab.show
    def _show3(self,bnewfig = True,
                    bcolorbar =True,
                    name=[],
                    binteract=False,
                    btitle=True,
                    bcircle=True,
                    **kwargs ):
        &quot;&quot;&quot; show3 mayavi

        Parameters
        ----------

        btitle : boolean
            display title
        bcolorbar : boolean
            display colorbar
        binteract : boolean 
            enable interactive mode
        bcircle : boolean 
            draw a circle 
        newfig: boolean


        see also
        --------

        antprop.antenna._computemesh

        &quot;&quot;&quot;

        if not self.evaluated:
            self.eval(pattern=True)

        # k is the frequency index
        if hasattr(self, &#39;p&#39;):
            lpshp = len(self.p.shape)
            sum_index = tuple(np.arange(1, lpshp))
            po = np.mean(self.p, axis=sum_index)
            kwargs[&#39;po&#39;] = po

        x, y, z, k, scalar = self._computemesh(**kwargs)

        if bnewfig:
            mlab.clf()
            f = mlab.figure(bgcolor=(1, 1, 1), fgcolor=(0, 0, 0))
        else:
            f = mlab.gcf()

        if &#39;opacity&#39; in kwargs:
            opacity = kwargs[&#39;opacity&#39;]
        else: 
            opacity = 1

        self._mayamesh = mlab.mesh(x, y, z,
                                   scalars= scalar,
                                   resolution = 1,
                                   opacity = opacity,reset_zoom=False)

        if name == []:
            f.children[-1].name = &#39;Antenna &#39; + self._filename
        else :
            f.children[-1].name = name + self._filename

        if bcolorbar :
            mlab.colorbar()

        if btitle:
            mlab.title(self._filename + &#39; @ &#39; + str(self.fGHz[k]) + &#39; GHz&#39;,height=1,size=0.5)

        def circle(typ=&#39;xy&#39;,a=1.2):
            phi = np.linspace(0, 2*np.pi, 2000)
            if typ==&#39;xy&#39;:
                return [ a*np.cos(phi) ,
                         a*np.sin(phi) ,
                         np.zeros(len(phi))
                         ]
            if typ==&#39;yz&#39;:
                return [ np.zeros(len(phi)),
                         a*np.cos(phi) ,
                         a*np.sin(phi) 
                         ]
            if typ==&#39;xz&#39;:
                return [ a*np.cos(phi),
                         a*np.zeros(len(phi)),
                         np.sin(phi) 
                         ]

        # draw 3D circle around the pattern
        if bcircle:
            xc,yc,zc =circle(&#39;xy&#39;) # blue
            mlab.plot3d(xc,yc,zc,color=(0,0,1))
            xc,yc,zc =circle(&#39;yz&#39;) # red
            mlab.plot3d(xc,yc,zc,color=(1,0,0))
            xc,yc,zc =circle(&#39;xz&#39;) # green
            mlab.plot3d(xc,yc,zc,color=(0,1,0))

        if binteract:
            self._outline = mlab.outline(self._mayamesh, color=(.7, .7, .7))
            self._outline.visible=False
            def picker_callback(picker):
                &quot;&quot;&quot; Picker callback: this get called when on pick events.
                &quot;&quot;&quot;
                if picker.actor in self._mayamesh.actor.actors:
                    self._outline.visible = not self._outline.visible
                    self._is_selected=self._outline.visible
            picker = f.on_mouse_pick(picker_callback)

        return(f)




    def _computemesh(self,**kwargs):
        &quot;&quot;&quot; compute mesh from theta phi

        Parameters
        ----------

        fGHz : np.array()
            default [] : takes center frequency fa[len(fa)/2]
        po   : np.array()
            location point of the antenna
        T    : np.array
            rotation matrix
        minr : float
            minimum radius in meter
        maxr : float
            maximum radius in meters
        tag : string
        ilog : boolean
        title : boolean


        Returns
        -------

        (x, y, z, k)

        x , y , z values in cartesian axis
        k frequency point evaluated

        &quot;&quot;&quot;
        defaults = {&#39;fGHz&#39;: [],
                     &#39;po&#39;: np.array([0, 0, 0]),
                     &#39;T&#39;: np.eye(3),
                     &#39;minr&#39;: 0.1,
                     &#39;maxr&#39;: 1,
                     &#39;scale&#39;: 1.,
                     &#39;tag&#39; : &#39;Pat&#39;,
                     &#39;txru&#39; : 0,
                     &#39;ilog&#39; : False,
                     &#39;title&#39;: True,

                     }

        for key, value in defaults.items():
            if key not in kwargs:
                kwargs[key] = value

        fGHz = kwargs[&#39;fGHz&#39;]
        minr = kwargs[&#39;minr&#39;]
        maxr = kwargs[&#39;maxr&#39;]
        tag = kwargs[&#39;tag&#39;]
        ilog = kwargs[&#39;ilog&#39;]
        txru = kwargs[&#39;txru&#39;]
        scale = kwargs[&#39;scale&#39;]

        po = kwargs[&#39;po&#39;]
        # T is an unitary matrix
        T = kwargs[&#39;T&#39;]
        if fGHz == []:
            #Â self.ext == &#39;&#39; &lt;=&gt; mathematically generated =&gt; nf = 1
            if self.ext != &#39;&#39;:
                k = int(len(self.fGHz)/2)
            else:
                k = 0
        else :
            if self.ext != &#39;&#39;:
                k = np.where(self.fGHz&gt;=fGHz)[0][0]
            else:
                k = 0
        if len(self.Ft.shape)==2:
            r = self.sqG[:,k]
        elif len(self.Ft.shape)==3:
            r = self.sqG[:,:,k]
        else:
            r = self.sqG[:,:,txru,k]

        th = self.theta[:,None]
        phi = self.phi[None,:]

        if ilog :
            r = 10*np.log10(abs(r))
        else:
            r = abs(r)
        if r.max() != r.min():
            u = (r - r.min()) /(r.max() - r.min())
        else : u = r

        r = minr + (maxr-minr) * u
        x = scale*r * np.sin(th) * np.cos(phi)
        y = scale*r * np.sin(th) * np.sin(phi)
        z = scale*r * np.cos(th)
        if z.shape[1] != y.shape[1]:
            z = z*np.ones(y.shape[1])
        p = np.concatenate((x[...,None],
                            y[...,None],
                            z[...,None]),axis=2)
        #
        # antenna cs -&gt; glogal cs
        # q : Nt x Np x 3
        q = np.einsum(&#39;ij,klj-&gt;kli&#39;,T,p)
        #
        # translation
        #
        scalar=(q[...,0]**2+q[...,1]**2+q[...,2]**2)

        q[...,0]=q[...,0]+po[0]
        q[...,1]=q[...,1]+po[1]
        q[...,2]=q[...,2]+po[2]

        x = q[...,0]
        y = q[...,1]
        z = q[...,2]



        return x, y, z, k, scalar

<div class="viewcode-block" id="Antenna.show3"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.show3">[docs]</a>    def show3(self,k=0,po=[],T=[],txru=0,typ=&#39;G&#39;, mode=&#39;linear&#39;, silent=False):
        &quot;&quot;&quot; show3 geomview

        Parameters
        ----------

        k : frequency index
        po : poition of the antenna
        T  : GCS of the antenna
        typ : string
            &#39;G&#39; | &#39;Ft&#39; | &#39;Fp&#39;
        mode : string
            &#39;linear&#39;| &#39;not implemented&#39;
        silent : boolean
            True    | False

        Examples
        --------

            &gt;&gt;&gt; from pylayers.antprop.antenna import *
            &gt;&gt;&gt; import numpy as np
            &gt;&gt;&gt; import matplotlib.pylab as plt
            &gt;&gt;&gt; A = Antenna(&#39;defant.sh3&#39;)
            &gt;&gt;&gt; #A.show3()

        &quot;&quot;&quot;

        if not self.evaluated:
            self.eval(pattern=True)

        f = self.fGHz[k]

        # 3 axis : nth x nph x nf
        if len(self.Ft.shape)==3:
            if typ == &#39;G&#39;:
                V = self.sqG[:, :,k]
            if typ == &#39;Ft&#39;:
                V = self.Ft[:, :,k]
            if typ == &#39;Fp&#39;:
                V = self.Fp[:, :,k]
            if typ == &#39;Ft&#39;:
                V = self.Ft[:,:,k]

        # 4 axis : nth x nph x ntxru x nf
        if len(self.Ft.shape)==4:
            if typ == &#39;G&#39;:
                V = self.sqG[:, :, txru,k]
            if typ == &#39;Ft&#39;:
                V = self.Ft[:, : ,txru,k]
            if typ == &#39;Fp&#39;:
                V = self.Fp[:, :,txru,k]

        if po ==[]:
            po = np.array([0, 0, 0])
        if T ==[]:
            T = np.eye(3)

        _filename = &#39;antbody&#39;

        geo = geu.Geomoff(_filename)
        # geo.pattern requires the following shapes
        # theta (Ntx1)
        # phi (1xNp)
        #if len(np.shape(self.theta))==1:
        #    theta = self.theta[:,None]
        #else:
        #    theta=self.theta
        theta = self.theta
        #if len(np.shape(self.phi))==1:
        #    phi = self.phi[None,:]
        #else:
        #    phi=self.phi
        phi = self.phi

        geo.pattern(theta,phi,V,po=po,T=T,ilog=False,minr=0.01,maxr=0.2)
        #filename = geom_pattern(self.theta, self.phi, V, k, po, minr, maxr, typ)
        #filename = geom_pattern(self.theta, self.phi, V, k, po, minr, maxr, typ)

        if not silent:
            geo.show3()</div>

<div class="viewcode-block" id="Antenna.plot3d"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.plot3d">[docs]</a>    def plot3d(self, k=0, typ=&#39;Gain&#39;, col=True):
        &quot;&quot;&quot; show 3D pattern in matplotlib

        Parameters
        ----------

        k : frequency index

        typ =  &#39;Gain&#39;
            = &#39;Ftheta&#39;
            = &#39;Fphi&#39;

        if col  -&gt; color coded plot3D
        else    -&gt; simple plot3D

        &quot;&quot;&quot;

        fig = plt.figure()
        ax = axes3d.Axes3D(fig)

        if typ == &#39;Gain&#39;:
            V = self.sqG[:, :,k]
        if typ == &#39;Ftheta&#39;:
            V = self.Ft[ :, :,k]
        if typ == &#39;Fphi&#39;:
            V = self.Fp[ :, :,k]

        vt = np.ones(self.nth)
        vp = np.ones(self.nph)
        Th = np.outer(self.theta, vp)
        Ph = np.outer(vt, self.phi)

        pdb.set_trace()
        X = abs(V) * np.cos(Ph) * np.sin(Th)
        Y = abs(V) * np.sin(Ph) * np.sin(Th)
        Z = abs(V) * np.cos(Th)

        ax.set_xlabel(&#39;X&#39;)
        ax.set_ylabel(&#39;Y&#39;)
        ax.set_zlabel(&#39;Z&#39;)

        if col:
            ax.plot_surface(X, Y, Z, rstride=1, cstride=1,
                            cmap=cm.hot_r,shade=True)
        else:
            ax.plot3D(np.ravel(X), np.ravel(Y), np.ravel(Z))
        plt.show()</div>

<div class="viewcode-block" id="Antenna.pol3d"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.pol3d">[docs]</a>    def pol3d(self, k=0, R=50, St=4, Sp=4, silent=False):
        &quot;&quot;&quot; Display polarisation diagram  in 3D

           Parameters
           ----------

           k  : int
               frequency index
           R  : float
               radius of the sphere
           St : int
               downsampling factor along theta
           Sp : int
               downsampling factor along phi
           silent : Boolean
               (if True the file is created and not displayed&#39;)

           The file created is named : Polar{ifreq}.list
           it is placed in the /geom directory of the project

        &quot;&quot;&quot;
        _filename = &#39;Polar&#39; + str(10000 + k)[1:] + &#39;.list&#39;
        filename = pyu.getlong(_filename, pstruc[&#39;DIRGEOM&#39;])
        fd = open(filename, &quot;w&quot;)
        fd.write(&quot;LIST\n&quot;)

        Nt = self.nth
        Np = self.nph
        N = 10
        plth = np.arange(0, Nt, St)
        plph = np.arange(0, Np, Sp)

        for m in plph:
            for n in plth:
                #theta = self.theta[n,0]
                theta = self.theta[n]
                #print &quot;m,theta= :&quot;,m,theta*180/np.pi
                #phi = self.phi[0,m]
                phi = self.phi[m]
                #print &quot;n,phi=:&quot;,n,phi*180/np.pi
                B = geu.vec_sph(theta, phi)
                p = R * np.array((np.cos(phi) * np.sin(theta),
                                  np.sin(phi) * np.sin(theta),
                                  np.cos(theta)))
                fd.write(&#39;{\n&#39;)
                geu.ellipse(fd, p, B[0, :], B[1, :], self.Ft[n, m , k], self.Fp[n, m , k], N)
                fd.write(&#39;}\n&#39;)
        fd.close()
        if not silent:
            chaine = &quot;geomview &quot; + filename + &quot; 2&gt;/dev/null &amp;&quot;
            os.system(chaine)</div>

<div class="viewcode-block" id="Antenna.mse"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.mse">[docs]</a>    def mse(self, Fth, Fph, N=0):
        &quot;&quot;&quot; mean square error between original and reconstructed

        Parameters
        ----------

        Fth  : np.array
        Fph  : np.array
        N    : int


        Notes
        -----

        Calculate the relative mean square error between original pattern A.Ftheta , A.Fphi and the
        pattern given as argument of the function  Fth , Fph

        The mse is evaluated on both polarization and normalized over the energy of each
        original pattern.

        The function returns the maximum between those two errors

        N is a parameter which allows to suppress value at the pole for the calculation of the error
        if N=0 all values are kept else   N &lt; n &lt; Nt - N

        &quot;&quot;&quot;

        sh = np.shape(self.Ft)
        Nf = sh[0]
        Nt = sh[1]
        Np = sh[2]
        # plage de theta (exclusion du pole)
        pt = np.arange(N, Nt - N, 1)

        Fthr = Fth.reshape(sh)
        Fphr = Fph.reshape(sh)

        Gr = np.real(Fphr * np.conj(Fphr) + Fthr * np.conj(Fthr))
        SqGr = np.sqrt(Gr)

        Fthr = Fthr[:, pt, :].ravel()
        Fphr = Fphr[:, pt, :].ravel()
        SqGr = SqGr[:, pt, :].ravel()

        Ftho = self.Ft[:, pt, :].ravel()
        Fpho = self.Fp[:, pt, :].ravel()
        SqGo = self.sqG[:, pt, :].ravel()

        Etho = np.sqrt(np.dot(np.conj(Ftho), Ftho))
        Epho = np.sqrt(np.dot(np.conj(Fpho), Fpho))
        Eo = np.sqrt(np.dot(np.conj(Ftho), Ftho) + np.dot(np.conj(Fpho), Fpho))

        errth = Ftho - Fthr
        errph = Fpho - Fphr
        Err = np.real(np.sqrt(np.dot(np.conj(errth), errth) + np.dot(np.conj(errph), errph)))

        Errth = np.real(np.sqrt(np.dot(np.conj(errth), errth)))
        Errph = np.real(np.sqrt(np.dot(np.conj(errph), errph)))

        #Errth_rel = Errth/Etho
        #Errph_rel = Errph/Epho
        Errth_rel = Errth / Eo
        Errph_rel = Errph / Eo
        Err_rel = Err / Eo

        return Err_rel, Errth_rel, Errph_rel</div>

<div class="viewcode-block" id="Antenna.getdelay"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.getdelay">[docs]</a>    def getdelay(self,delayCandidates = np.arange(-10,10,0.001)):
        &quot;&quot;&quot; get electrical delay

        Parameters
        ----------

        delayCandidates : ndarray dalay in (ns)
            default np.arange(-10,10,0.001)

        Returns
        -------

        electricalDelay  : float

        Author : Troels Pedersen (Aalborg University)
                 B.Uguen

        &quot;&quot;&quot;
        if self.evaluated:
            maxPowerInd  = np.unravel_index(np.argmax(abs(self.Ft)),np.shape(self.Ft))
            elD  = delayCandidates[np.argmax(abs(
                np.dot(self.Ft[maxPowerInd[0],maxPowerInd[1],:]
                       ,np.exp(2j*np.pi*self.fGHz[:,None]
                               *delayCandidates[None,:]))))]
            #electricalDelay  = delayCandidates[np.argmax(abs(
            #    np.dot(self.Ft[:,maxPowerInd[1],maxPowerInd[2]]
            #        ,np.exp(2j*np.pi*freq.reshape(len(freq),1)
            #          *delayCandidates.reshape(1,len(delayCandidates))))
            #        ))]
            return(elD)
        else:
            raise Warning(&#39;Antenna has not been evaluated&#39;)</div>

<div class="viewcode-block" id="Antenna.elec_delay"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.elec_delay">[docs]</a>    def elec_delay(self,tau):
        r&quot;&quot;&quot; apply an electrical delay

        Parameters
        ----------

        tau : float
            electrical delay in nanoseconds

        Notes
        -----

         This function applies an electrical delay math::`\exp{+2 j \pi f \tau)`
         on the phase of diagram math::``F_{\theta}`` and math::`F_{\phi}`

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; from pylayers.antprop.antenna import *
            &gt;&gt;&gt; A = Antenna(&#39;S2R2.sh3&#39;)
            &gt;&gt;&gt; A.eval()
            &gt;&gt;&gt; tau = A.getdelay()
            &gt;&gt;&gt; A.elec_delay(tau)



        &quot;&quot;&quot;

        self.tau = self.tau+tau
        if self.evaluated:
            Ftheta = self.Ft
            Fphi = self.Fp
            sh = np.shape(Ftheta)
            e = np.exp(2 * np.pi * 1j * self.fGHz[None,None,:]* tau)
            #E = np.outer(e, ones(sh[1] * sh[2]))
            #Fth = Ftheta.reshape(sh[0], sh[1] * sh[2])
            #EFth = Fth * E
            #self.Ft = EFth.reshape(sh[0], sh[1], sh[2])
            self.Ft = self.Ft*e
            self.Fp = self.Fp*e
            #Fph = Fphi.reshape(sh[0], sh[1] * sh[2])
            #EFph = Fph * E
            #self.Fp = EFph.reshape(sh[0], sh[1], sh[2])
        else:
            raise Warning(&#39;antenna has not been evaluated&#39;)</div>


<div class="viewcode-block" id="Antenna.Fsynth"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.Fsynth">[docs]</a>    def Fsynth(self,theta=[],phi=[],):
        &quot;&quot;&quot; Perform Antenna synthesis

        Parameters
        ----------

        theta : np.array
        phi :   np.array
            call Antenna.Fpatt or Antenna.Fsynth3

        Notes
        -----

        The antenna pattern synthesis is done either from spherical
        harmonics coefficients or from an analytical expression of the
        radiation pattern.

        &quot;&quot;&quot;
        if ((self.fromfile) or (self.typ==&#39;vsh&#39;) or (self.typ==&#39;ssh&#39;)):
            Ft,Fp = self.Fsynth3(theta,phi)
            self.gain()
            self.evaluated=True
        else :
            Ft = self.Ft
            Fp = self.Fp
            self.theta = theta
            self.phi = phi
            eval(&#39;self.p&#39;+self.typ)()
            #Ft,Fp = self.Fpatt(theta,phi,pattern)
        return (Ft,Fp)</div>


    #def Fsynth1(self, theta, phi, k=0):

<div class="viewcode-block" id="Antenna.Fsynth1"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.Fsynth1">[docs]</a>    def Fsynth1(self, theta, phi):
        &quot;&quot;&quot; calculate complex antenna pattern  from VSH Coefficients (shape 1)

        Parameters
        ----------

        theta  : ndarray (1xNdir)
        phi    : ndarray (1xNdir)
        k      : int
            frequency index

        Returns
        -------

        Ft , Fp 

        &quot;&quot;&quot;

        Nt = len(theta)
        Np = len(phi)

        if self.grid:
            theta = np.kron(theta, np.ones(Np))
            phi = np.kron(np.ones(Nt),phi)

        nray = len(theta)

        #Br = self.C.Br.s1[k, :, :]
        #Bi = self.C.Bi.s1[k, :, :]
        #Cr = self.C.Cr.s1[k, :, :]
        #Ci = self.C.Ci.s1[k, :, :]

        Br = self.C.Br.s1[:, :, :]
        Bi = self.C.Bi.s1[:, :, :]
        Cr = self.C.Cr.s1[:, :, :]
        Ci = self.C.Ci.s1[:, :, :]

        N = self.C.Br.N1
        M = self.C.Br.M1
        #print &quot;N,M&quot;,N,M
        #
        # The - sign is necessary to get the good reconstruction
        #     deduced from observation
        #     May be it comes from a different definition of theta in SPHEREPACK
        x = -np.cos(theta)
        Pmm1n, Pmp1n = AFLegendre3(N, M, x)
        ind = index_vsh(N, M)
        n = ind[:, 0]
        m = ind[:, 1]
        #~ V, W = VW(n, m, x, phi, Pmm1n, Pmp1n)
        V, W = VW(n, m, x, phi)
        #
        # broadcasting along frequency axis
        #
        V = np.expand_dims(V,0)
        W = np.expand_dims(V,0)
        #
        #   k : frequency axis
        #   l : coeff l
        #   m
        # Fth = np.eisum(&#39;klm,kilm-&gt;ki&#39;,Br,np.real(V.T)) - \
        #       np.eisum(&#39;klm,kilm-&gt;ki&#39;,Bi,np.imag(V.T)) + \
        #       np.eisum(&#39;klm,kilm-&gt;ki&#39;,Ci,np.real(W.T)) + \
        #       np.eisum(&#39;klm,kilm-&gt;ki&#39;,Cr,np.imag(W.T))

        # Fph = -np.eisum(&#39;klm,kilm-&gt;ki&#39;,Cr,np.real(V.T)) + \
        #       np.eisum(&#39;klm,kilm-&gt;ki&#39;,Ci,np.imag(V.T)) + \
        #       np.eisum(&#39;klm,kilm-&gt;ki&#39;,Bi,np.real(W.T)) + \
        #       np.eisum(&#39;klm,kilm-&gt;ki&#39;,Br,np.imag(W.T))

        Brr = Br[:,l,m]
        Bir = Bi[:,l,m]
        Crr = Cr[:,l,m]
        Cir = Ci[:,l,m]

        Fth = np.dot(Brr, np.real(V.T)) - \
              np.dot(Bir, np.imag(V.T)) + \
              np.dot(Cir, np.real(W.T)) + \
              np.dot(Crr, np.imag(W.T))
        Fph = -np.dot(Crr, np.real(V.T)) + \
              np.dot(Cir, np.imag(V.T)) + \
              np.dot(Bir, np.real(W.T)) + \
              np.dot(Brr, np.imag(W.T))

        #Fth = np.dot(Br, np.real(V.T)) - \
        #    np.dot(Bi, np.imag(V.T)) + \
        #    np.dot(Ci, np.real(W.T)) + \
        #    np.dot(Cr, np.imag(W.T))

        #Fph = -np.dot(Cr, np.real(V.T)) + \
        #    np.dot(Ci, np.imag(V.T)) + \
        #    np.dot(Bi, np.real(W.T)) + \
        #    np.dot(Br, np.imag(W.T))

        if self.grid:
            Nf = len(self.fGHz)
            Fth = Fth.reshape(Nf, Nt, Np)
            Fph = Fph.reshape(Nf, Nt, Np)

        return Fth, Fph</div>


<div class="viewcode-block" id="Antenna.Fsynth2s"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.Fsynth2s">[docs]</a>    def Fsynth2s(self,dsf=1):
        &quot;&quot;&quot;  pattern synthesis from shape 2 vsh coefficients

        Parameters
        ----------

        phi

        Notes
        -----

        Calculate complex antenna pattern from VSH Coefficients (shape 2)
        for the specified directions (theta,phi)
        theta and phi arrays needs to have the same size

        &quot;&quot;&quot;
        theta = self.theta[::dsf]
        phi = self.phi[::dsf]
        Nt = len(theta)
        Np = len(phi)
        theta = np.kron(theta, np.ones(Np))
        phi = np.kron(np.ones(Nt), phi)

        Ndir = len(theta)

        Br = self.C.Br.s2 # Nf x K2
        Bi = self.C.Bi.s2 # Nf x K2
        Cr = self.C.Cr.s2 # Nf x K2
        Ci = self.C.Ci.s2 # Nf x K2

        Nf = np.shape(self.C.Br.s2)[0]
        K2 = np.shape(self.C.Br.s2)[1]

        L = self.C.Br.N2 # int
        M = self.C.Br.M2 # int

        #print &quot;N,M&quot;,N,M
        #
        # The - sign is necessary to get the good reconstruction
        #     deduced from observation
        #     May be it comes from a different definition of theta in SPHEREPACK

        x = -np.cos(theta)

        Pmm1n, Pmp1n = AFLegendre3(L, M, x)
        ind = index_vsh(L, M)

        l = ind[:, 0]
        m = ind[:, 1]

        V, W = VW2(l, m, x, phi, Pmm1n, Pmp1n)  # K2 x Ndir

        # Fth , Fph are Nf x Ndir

        tEBr = []
        tEBi = []
        tECr = []
        tECi = []

        for k in range(K2):
            BrVr = np.dot(Br[:,k].reshape(Nf,1),
                          np.real(V.T)[k,:].reshape(1,Ndir))
            BiVi = np.dot(Bi[:,k].reshape(Nf,1),
                          np.imag(V.T)[k,:].reshape(1,Ndir))
            CiWr = np.dot(Ci[:,k].reshape(Nf,1),
                          np.real(W.T)[k,:].reshape(1,Ndir))
            CrWi = np.dot(Cr[:,k].reshape(Nf,1),
                          np.imag(W.T)[k,:].reshape(1,Ndir))

            CrVr = np.dot(Cr[:,k].reshape(Nf,1),
                          np.real(V.T)[k,:].reshape(1,Ndir))
            CiVi = np.dot(Ci[:,k].reshape(Nf,1),
                          np.imag(V.T)[k,:].reshape(1,Ndir))
            BiWr = np.dot(Bi[:,k].reshape(Nf,1),
                          np.real(W.T)[k,:].reshape(1,Ndir))
            BrWi = np.dot(Br[:,k].reshape(Nf,1),
                          np.imag(W.T)[k,:].reshape(1,Ndir))

            EBr = np.sum(BrVr*np.conj(BrVr)*np.sin(theta)) + \
                  np.sum(BrWi*np.conj(BrWi)*np.sin(theta))

            EBi = np.sum(BiVi*np.conj(BiVi)*np.sin(theta)) + \
                  np.sum(BiWr*np.conj(BiWr)*np.sin(theta))

            ECr = np.sum(CrWi*np.conj(CrWi)*np.sin(theta)) + \
                + np.sum(CrVr*np.conj(CrVr)*np.sin(theta))

            ECi = np.sum(CiWr*np.conj(CiWr)*np.sin(theta)) + \
                + np.sum(CiVi*np.conj(CiVi)*np.sin(theta))

            tEBr.append(EBr)
            tEBi.append(EBi)
            tECr.append(ECr)
            tECi.append(ECi)

        #Fth = np.dot(Br, np.real(V.T)) - np.dot(Bi, np.imag(V.T)) + \
        #      np.dot(Ci, np.real(W.T)) + np.dot(Cr, np.imag(W.T))
        #Fph = -np.dot(Cr, np.real(V.T)) + np.dot(Ci, np.imag(V.T)) + \
        #      np.dot(Bi, np.real(W.T)) + np.dot(Br, np.imag(W.T))

        return np.array(tEBr),np.array(tEBi),np.array(tECr),np.array(tECi)</div>

<div class="viewcode-block" id="Antenna.Fsynth2b"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.Fsynth2b">[docs]</a>    def Fsynth2b(self, theta, phi):
        &quot;&quot;&quot;  pattern synthesis from shape 2 vsh coefficients

        Parameters
        ----------

        theta : 1 x Nt
        phi   : 1 x Np

        Notes
        -----

        Calculate complex antenna pattern from VSH Coefficients (shape 2)
        for the specified directions (theta,phi)
        theta and phi arrays needs to have the same size

        &quot;&quot;&quot;

        Nt = len(theta)
        Np = len(phi)

        if self.grid:
            theta = np.kron(theta, np.ones(Np))
            phi = np.kron(np.ones(Nt),phi)

        Br = self.C.Br.s2 # Nf x K2
        Bi = self.C.Bi.s2 # Nf x K2
        Cr = self.C.Cr.s2 # Nf x K2
        Ci = self.C.Ci.s2 # Nf x K2

        L = self.C.Br.N2 # int
        M = self.C.Br.M2 # int

        #print &quot;N,M&quot;,N,M
        #
        # The - sign is necessary to get the good reconstruction
        #     deduced from observation
        #     May be it comes from a different definition of theta in SPHEREPACK

        x = -np.cos(theta)

        Pmm1n, Pmp1n = AFLegendre3(L, M, x)
        ind = index_vsh(L, M)

        l = ind[:, 0]
        m = ind[:, 1]

        V, W = VW2(l, m, x, phi, Pmm1n, Pmp1n)  # K2 x Ndir

        # Fth , Fph are Nf x Ndir
        Fth = np.dot(Br, np.real(V.T)) - np.dot(Bi, np.imag(V.T)) + \
              np.dot(Ci, np.real(W.T)) + np.dot(Cr, np.imag(W.T))

        Fph = -np.dot(Cr, np.real(V.T)) + np.dot(Ci, np.imag(V.T)) + \
              np.dot(Bi, np.real(W.T)) + np.dot(Br, np.imag(W.T))

        if self.grid:
            Nf = len(self.fGHz)
            Fth = Fth.reshape(Nf, Nt, Np)
            Fph = Fph.reshape(Nf, Nt, Np)

        return Fth, Fph</div>

<div class="viewcode-block" id="Antenna.Fsynth2"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.Fsynth2">[docs]</a>    def Fsynth2(self, theta, phi, typ = &#39;vsh&#39;):
        &quot;&quot;&quot;  pattern synthesis from shape 2 vsh coeff

        Parameters
        ----------

        theta : array 1 x Nt
        phi : array 1 x Np
        pattern : boolean
            default False
        typ : string
            {vsh | ssh}


        Notes
        -----

        Calculate complex antenna pattern from VSH Coefficients (shape 2)
        for the specified directions (theta,phi)
        theta and phi arrays needs to have the same size

        &quot;&quot;&quot;

        self.nth = len(theta)
        self.nph = len(phi)
        self.nf = len(self.fGHz)

        if typ ==&#39;vsh&#39; :

            if self.grid:
                theta = np.kron(theta, np.ones(self.nph))
                phi = np.kron(np.ones(self.nth),phi)

            Br = self.C.Br.s2
            Bi = self.C.Bi.s2
            Cr = self.C.Cr.s2
            Ci = self.C.Ci.s2

            N = self.C.Br.N2
            M = self.C.Br.M2

            #print &quot;N,M&quot;,N,M
            #
            # The - sign is necessary to get the good reconstruction
            #     deduced from observation
            #     May be it comes from a different definition of theta in SPHEREPACK
            x = -np.cos(theta)

            Pmm1n, Pmp1n = AFLegendre3(N, M, x)
            ind = index_vsh(N, M)

            n = ind[:, 0]
            m = ind[:, 1]

            #~ V, W = VW(n, m, x, phi, Pmm1n, Pmp1n)
            V, W = VW(n, m, x, phi)


            Fth = np.dot(Br, np.real(V.T)) - np.dot(Bi, np.imag(V.T)) + \
                np.dot(Ci, np.real(W.T)) + np.dot(Cr, np.imag(W.T))
            Fph = -np.dot(Cr, np.real(V.T)) + np.dot(Ci, np.imag(V.T)) + \
                np.dot(Bi, np.real(W.T)) + np.dot(Br, np.imag(W.T))

            if self.grid:
                Fth = Fth.reshape(self.nf, self.nth, self.nph)
                Fph = Fph.reshape(self.nf, self.nth, self.nph)

        if typ==&#39;ssh&#39;:
            cx = self.S.Cx.s2
            cy = self.S.Cy.s2
            cz = self.S.Cz.s2

            lmax = self.S.Cx.lmax
            Y ,indx = SSHFunc(lmax, theta,phi)
            Ex = np.dot(cx,Y).reshape(self.nf,self.nth,self.nph)
            Ey = np.dot(cy,Y).reshape(self.nf,self.nth,self.nph)
            Ez = np.dot(cz,Y).reshape(self.nf,self.nth,self.nph)

            Fth,Fph = CartToSphere (theta, phi, Ex, Ey,Ez, bfreq = True )

        self.evaluated = True
        return Fth, Fph</div>


<div class="viewcode-block" id="Antenna.Fsynth3"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.Fsynth3">[docs]</a>    def Fsynth3(self,theta=[],phi=[],typ=&#39;vsh&#39;):
        r&quot;&quot;&quot; synthesis of a complex antenna pattern from SH coefficients
        (vsh or ssh  in shape 3)


        Ndir is the number of directions

        Parameters
        ----------

        theta : ndarray (1xNdir if not pattern)  (1xNtheta if pattern)
        phi   : ndarray (1xNdir if not pattter)  (1xNphi if pattern)

        pattern : boolean
            if True theta and phi are reorganized for building the pattern
        typ  : &#39;vsh&#39; | &#39;ssh&#39; | &#39;hfss&#39;

        Returns
        -------

        if self.grid:
            Fth   : ndarray (Ntheta x Nphi)
            Fph   : ndarray (Ntheta x Nphi)
        else:
            Fth   : ndarray (1 x Ndir)
            Fph   : ndarray (1 x Ndir)

        See Also
        --------

        pylayers.antprop.channel._vec2scalA

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; from pylayers.antprop.antenna import *
            &gt;&gt;&gt; import numpy as np
            &gt;&gt;&gt; import matplotlib.pylab as plt
            &gt;&gt;&gt; A = Antenna(&#39;defant.vsh3&#39;)
            &gt;&gt;&gt; F = A.eval(grid=True)

        All Br,Cr,Bi,Ci have the same (l,m) index in order to evaluate only
        once the V,W function

        If the data comes from a cst file like the antenna used in WHERE1 D4.1
        the pattern is multiplied by $\frac{4\pi}{120\pi}=\frac{1}{\sqrt{30}$

        &quot;&quot;&quot;

        #typ = self.typ
        #self._filename.split(&#39;.&#39;)[1]
        #if typ==&#39;satimo&#39;:
        #    coeff=1.
        #if typ==&#39;cst&#39;:
        #    coeff=1./sqrt(30)


        #assert typ in [&#39;ssh&#39;,&#39;vsh&#39;,&#39;hfss&#39;], 
        assert (hasattr(self,&#39;C&#39;) or hasattr(self,&#39;S&#39;)),&quot;No SH coeffs evaluated&quot;

        Nf = len(self.fGHz)
        if theta==[]:
            theta=np.linspace(0,np.pi,45)

        if phi == []:
            phi= np.linspace(0,2*np.pi,90)

        Nt = len(theta)
        Np = len(phi)
        self.nth = len(theta)
        self.nph = len(phi)

        if self.grid:
            #self.theta = theta[:,None]
            #self.phi = phi[None,:]
            self.theta = theta
            self.phi = phi
            theta = np.kron(theta, np.ones(Np))
            phi = np.kron(np.ones(Nt),phi)


        if typ ==&#39;vsh&#39;:

            nray = len(theta)

            Br  = self.C.Br.s3
            lBr = self.C.Br.ind3[:, 0]
            mBr = self.C.Br.ind3[:, 1]

            Bi  = self.C.Bi.s3
            Cr  = self.C.Cr.s3
            Ci  = self.C.Ci.s3

            L = lBr.max()
            M = mBr.max()

            # vector spherical harmonics basis functions
            V, W = VW(lBr, mBr, theta, phi)

            Fth = np.dot(Br, np.real(V.T)) - \
                  np.dot(Bi, np.imag(V.T)) + \
                  np.dot(Ci, np.real(W.T)) + \
                  np.dot(Cr, np.imag(W.T))

            Fph = -np.dot(Cr, np.real(V.T)) + \
                   np.dot(Ci, np.imag(V.T)) + \
                   np.dot(Bi, np.real(W.T)) + \
                   np.dot(Br, np.imag(W.T))

            if self.grid:

                Fth = Fth.reshape(Nf, Nt, Np)
                Fph = Fph.reshape(Nf, Nt, Np)


        if typ == &#39;ssh&#39;:
            cx = self.S.Cx.s3
            cy = self.S.Cy.s3
            cz = self.S.Cz.s3

            lmax = self.S.Cx.lmax
            Y ,indx = SSHFunc2(lmax, theta,phi)
            #k = self.S.Cx.k2[:,0]
            # same k for x y and z
            k = self.S.Cx.k2
            if pattern :
                Ex = np.dot(cx,Y[k])
                Ey = np.dot(cy,Y[k])
                Ez = np.dot(cz,Y[k])
                Fth,Fph = CartToSphere(theta, phi, Ex, Ey,Ez, bfreq = True, pattern = True )
                Fth = Fth.reshape(Nf,Nt,Np)
                Fph = Fph.reshape(Nf,Nt,Np)


            else:

                Ex = np.dot(cx,Y[k])
                Ey = np.dot(cy,Y[k])
                Ez = np.dot(cz,Y[k])
                Fth,Fph = CartToSphere (theta, phi, Ex, Ey,Ez, bfreq = True, pattern = False)

            #self.Fp = Fph
            #self.Ft = Fth
            #G = np.real(Fph * np.conj(Fph) + Fth * np.conj(Fth))
            #self.sqG = np.sqrt(G)


        #if self.grid:
        #    self.Fp = Fph
        #    self.Ft = Fth
        #    G = np.real(Fph * np.conj(Fph) + Fth * np.conj(Fth))
        #    self.sqG = np.sqrt(G)

        self.evaluated = True

        #if typ == &#39;hfss&#39;:
        #    scipy.interpolate.griddata()

        #    Fth = self.Ft
        #    Fph = self.Fp
        # TODO create 2 different functions for pattern and not pattern
        #if not self.grid:
        return Fth, Fph</div>
        #else:
        #    return None,None

<div class="viewcode-block" id="Antenna.movie_vsh"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.movie_vsh">[docs]</a>    def movie_vsh(self, mode=&#39;linear&#39;):
        &quot;&quot;&quot; animates vector spherical coeff w.r.t frequency

        Parameters
        ----------
        mode : string
            &#39;linear&#39; |
        &quot;&quot;&quot;

        Brmin = abs(self.C.Br[:, 0:20, 0:20]).min()
        Brmax = abs(self.C.Br[:, 0:20, 0:20]).max()
        Bimin = abs(self.C.Bi[:, 0:20, 0:20]).min()
        Bimax = abs(self.C.Bi[:, 0:20, 0:20]).max()

        Crmin = abs(self.C.Cr[:, 0:20, 0:20]).min()
        Crmax = abs(self.C.Cr[:, 0:20, 0:20]).max()
        Cimin = abs(self.C.Ci[:, 0:20, 0:20]).min()
        Cimax = abs(self.C.Ci[:, 0:20, 0:20]).max()

        # print(Brmin, Brmax, Bimin, Bimax, Crmin, Crmax, Cimin, Cimax)

        for k in range(self.nf):
            plt.figure()
            stf = &#39; f=&#39; + str(self.fGHz[k]) + &#39; GHz&#39;
            subplot(221)
            pcolor(abs(self.C.Br.s1[k, 0:20, 0:20]),
                   vmin=Brmin, vmax=Brmax, edgecolors=&#39;k&#39;)
            #xlabel(&#39;m&#39;,fontsize=12)
            ylabel(&#39;n&#39;, fontsize=12)
            title(&#39;$|Br_{n}^{(m)}|$&#39; + stf, fontsize=10)
            colorbar()
            subplot(222)
            pcolor(abs(self.C.Bi.s1[k, 0:20, 0:20]),
                   vmin=Bimin, vmax=Bimax, edgecolors=&#39;k&#39;)
            #xlabel(&#39;m&#39;,fontsize=12)
            ylabel(&#39;n&#39;, fontsize=12)
            title(&#39;$|Bi_{n}^{(m)}|$&#39; + stf, fontsize=10)
            colorbar()
            subplot(223)
            pcolor(abs(self.C.Cr.s1[k, 0:20, 0:20]),
                   vmin=Crmin, vmax=Crmax, edgecolors=&#39;k&#39;)
            xlabel(&#39;m&#39;, fontsize=12)
            #ylabel(&#39;n&#39;,fontsize=12)
            title(&#39;$|Cr_{n}^{(m)}|$&#39; + stf, fontsize=10)
            colorbar()
            subplot(224)
            pcolor(abs(self.C.Ci.s1[k, 0:20, 0:20]),
                   vmin=Cimin, vmax=Cimax, edgecolors=&#39;k&#39;)
            xlabel(&#39;m&#39;, fontsize=12)
            #ylabel(&#39;n&#39;,fontsize=12)
            title(&#39;$|Ci_{n}^{(m)}|$&#39; + stf, fontsize=10)
            colorbar()
            filename = str(&#39;%03d&#39; % k) + &#39;.png&#39;
            savefig(filename, dpi=100)
            clf()

        command = (&#39;mencoder&#39;,
                   &#39;mf://*.png&#39;,
                   &#39;-mf&#39;,
                   &#39;type=png:w=800:h=600:fps=1&#39;,
                   &#39;-ovc&#39;,
                   &#39;lavc&#39;,
                   &#39;-lavcopts&#39;,
                   &#39;vcodec=mpeg4&#39;,
                   &#39;-oac&#39;,
                   &#39;copy&#39;,
                   &#39;-o&#39;,
                   &#39;vshcoeff.avi&#39;)
        subprocess.check_call(command)</div>

<div class="viewcode-block" id="Antenna.minsh3"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.minsh3">[docs]</a>    def minsh3(self, emax=0.05):
        &quot;&quot;&quot; creates vsh3 with significant coeff until given relative reconstruction error

        Parameters
        ----------

        emax : float
            error default 0.05

        Notes
        -----

        Create antenna&#39;s vsh3 file which only contains
        the significant vsh coefficients in shape 3,
        in order to obtain a reconstruction maximal error =  emax

        This function requires a reading of .trx file before being executed

        &quot;&quot;&quot;

        #th = np.kron(self.theta, np.ones(self.nph))
        #ph = np.kron(np.ones(self.nth), self.phi)

        if not self.grid:
            self.grid = True
        Fth3, Fph3 = self.Fsynth3(self.theta, self.phi)
        Err = self.mse(Fth3, Fph3, 0)

        Enc = self.C.ens3()
        n = len(Enc)
        pos = 0

        while (pos &lt; n) &amp; (Err[0] &lt; emax):

            Emin = Enc[pos]
            d = self.C.drag3(Emin)
            Fth3, Fph3 = self.Fsynth3(self.theta, self.phi)
            Err = self.mse(Fth3, Fph3, 0)

            if Err[0] &gt;= emax:
                i = d[0][0]
                i3 = d[1][0]
                self.C.put3(i, i3)
                Fth3, Fph3 = self.Fsynth3(self.theta,self.phi)
                Err = self.mse(Fth3, Fph3, 0)

            pos = pos + 1</div>

<div class="viewcode-block" id="Antenna.savevsh3"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.savevsh3">[docs]</a>    def savevsh3(self,force=False):
        &quot;&quot;&quot; save antenna in vsh3 format

        Create a .vsh3 antenna file


        &quot;&quot;&quot;

        # create vsh3 file

        _filevsh3 = os.path.splitext(self._filename)[0]+&#39;.vsh3&#39;
        filevsh3 = pyu.getlong(_filevsh3, pstruc[&#39;DIRANT&#39;])

        #filevsh3 = pyu.getlong(self._filename,&#39;ant&#39;)

        if os.path.isfile(filevsh3) and not force:
            print( filevsh3, &#39; already exist&#39;)
        else:
            print( &#39;create &#39;, filevsh3, &#39; file&#39;)

            coeff = {}
            coeff[&#39;fmin&#39;] = self.fGHz[0]
            coeff[&#39;fmax&#39;] = self.fGHz[-1]
            coeff[&#39;Br.ind&#39;] = self.C.Br.ind3
            coeff[&#39;Bi.ind&#39;] = self.C.Bi.ind3
            coeff[&#39;Cr.ind&#39;] = self.C.Cr.ind3
            coeff[&#39;Ci.ind&#39;] = self.C.Ci.ind3
            coeff[&#39;Br.k&#39;] = self.C.Br.k2
            coeff[&#39;Bi.k&#39;] = self.C.Bi.k2
            coeff[&#39;Cr.k&#39;] = self.C.Cr.k2
            coeff[&#39;Ci.k&#39;] = self.C.Ci.k2
            coeff[&#39;Br.s3&#39;] = self.C.Br.s3
            coeff[&#39;Bi.s3&#39;] = self.C.Bi.s3
            coeff[&#39;Cr.s3&#39;] = self.C.Cr.s3
            coeff[&#39;Ci.s3&#39;] = self.C.Ci.s3
            if self.evaluated:
                coeff[&#39;sl&#39;] = self.sl
                coeff[&#39;el&#39;] = self.el
            io.savemat(filevsh3, coeff, appendmat=False)</div>

<div class="viewcode-block" id="Antenna.savesh2"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.savesh2">[docs]</a>    def savesh2(self):
        &quot;&quot;&quot; save coeff in  .sh2 antenna file

        &quot;&quot;&quot;

        # create sh2 file
        #typ = self._filename.split(&#39;.&#39;)[1]
        #self.typ = typ

        _filesh2 = self._filename.replace(&#39;.&#39;+ self.typ, &#39;.sh2&#39;)
        filesh2 = pyu.getlong(_filesh2, pstruc[&#39;DIRANT&#39;])
        if os.path.isfile(filesh2):
            print(filesh2, &#39; already exist&#39;)
        else:
            print(&#39;create &#39;, filesh2, &#39; file&#39;)
            coeff = {}
            coeff[&#39;fmin&#39;] = self.fGHz[0]
            coeff[&#39;fmax&#39;] = self.fGHz[-1]


            coeff[&#39;Cx.ind&#39;] = self.S.Cx.ind2
            coeff[&#39;Cy.ind&#39;] = self.S.Cy.ind2
            coeff[&#39;Cz.ind&#39;] = self.S.Cz.ind2
            coeff[&#39;Cx.lmax&#39;]= self.S.Cx.lmax
            coeff[&#39;Cy.lmax&#39;]= self.S.Cy.lmax
            coeff[&#39;Cz.lmax&#39;]= self.S.Cz.lmax

            coeff[&#39;Cx.s2&#39;] = self.S.Cx.s2
            coeff[&#39;Cy.s2&#39;] = self.S.Cy.s2
            coeff[&#39;Cz.s2&#39;] = self.S.Cz.s2
            io.savemat(filesh2, coeff, appendmat=False)</div>

<div class="viewcode-block" id="Antenna.savesh3"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.savesh3">[docs]</a>    def savesh3(self):
        &quot;&quot;&quot; save antenna in sh3 format

        create a .sh3 antenna file

        &quot;&quot;&quot;
        # create sh3 file
        # if self._filename has an extension 
        # it is replace by .sh3
        #typ = self._filename.split(&#39;.&#39;)[1]
        #self.typ = typ
        _filesh3 = self._filename.replace(&#39;.&#39;+ self.typ, &#39;.sh3&#39;)
        filesh3 = pyu.getlong(_filesh3, pstruc[&#39;DIRANT&#39;])
        if os.path.isfile(filesh3):
            print(filesh3, &#39; already exist&#39;)
        else:
            print(&#39;create &#39;, filesh3, &#39; file&#39;)

            coeff = {}
            coeff[&#39;fmin&#39;] = self.fGHz[0]
            coeff[&#39;fmax&#39;] = self.fGHz[-1]
            coeff[&#39;Cx.ind&#39;] = self.S.Cx.ind3
            coeff[&#39;Cy.ind&#39;] = self.S.Cy.ind3
            coeff[&#39;Cz.ind&#39;] = self.S.Cz.ind3

            coeff[&#39;Cx.k&#39;] = self.S.Cx.k2
            coeff[&#39;Cy.k&#39;] = self.S.Cy.k2
            coeff[&#39;Cz.k&#39;] = self.S.Cz.k2


            coeff[&#39;Cx.lmax&#39;]= self.S.Cx.lmax
            coeff[&#39;Cy.lmax&#39;]= self.S.Cy.lmax
            coeff[&#39;Cz.lmax&#39;]= self.S.Cz.lmax

            coeff[&#39;Cx.s3&#39;] = self.S.Cx.s3
            coeff[&#39;Cy.s3&#39;] = self.S.Cy.s3
            coeff[&#39;Cz.s3&#39;] = self.S.Cz.s3


            io.savemat(filesh3, coeff, appendmat=False)</div>

<div class="viewcode-block" id="Antenna.loadvsh3"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.loadvsh3">[docs]</a>    def loadvsh3(self):
        &quot;&quot;&quot; Load antenna&#39;s vsh3 file

            vsh3 file contains a thresholded version of vsh coefficients in shape 3

        &quot;&quot;&quot;

        _filevsh3 = self._filename
        filevsh3 = pyu.getlong(_filevsh3, pstruc[&#39;DIRANT&#39;])
        self.evaluated = False

        if os.path.isfile(filevsh3):
            coeff = io.loadmat(filevsh3, appendmat=False)
            #
            # This test is to fix a problem with 2 different
            # behavior of io.loadmat
            #
            if type(coeff[&#39;fmin&#39;]) == float:
                fmin = coeff[&#39;fmin&#39;]
                fmax = coeff[&#39;fmax&#39;]
            else:
                fmin = coeff[&#39;fmin&#39;][0][0]
                fmax = coeff[&#39;fmax&#39;][0][0]
            # .. Warning
            # Warning modification takes only one dimension for k
            # if the .vsh3 format evolve it may not work anymore
            #
            Br = VCoeff(&#39;s3&#39;, fmin, fmax, coeff[&#39;Br.s3&#39;],
                         coeff[&#39;Br.ind&#39;], coeff[&#39;Br.k&#39;][0])
            Bi = VCoeff(&#39;s3&#39;, fmin, fmax, coeff[&#39;Bi.s3&#39;],
                         coeff[&#39;Bi.ind&#39;], coeff[&#39;Bi.k&#39;][0])
            Cr = VCoeff(&#39;s3&#39;, fmin, fmax, coeff[&#39;Cr.s3&#39;],
                         coeff[&#39;Cr.ind&#39;], coeff[&#39;Cr.k&#39;][0])
            Ci = VCoeff(&#39;s3&#39;, fmin, fmax, coeff[&#39;Ci.s3&#39;],
                         coeff[&#39;Ci.ind&#39;], coeff[&#39;Ci.k&#39;][0])
            self.C = VSHCoeff(Br, Bi, Cr, Ci)
            self.nf = np.shape(Br.s3)[0]
            self.fGHz = np.linspace(fmin, fmax, self.nf)

            if &#39;sl&#39; in coeff:
                self.sl = coeff[&#39;sl&#39;][0]
                self.el = coeff[&#39;el&#39;][0]

        else:
            print(_filevsh3, &#39; does not exist&#39;)</div>

<div class="viewcode-block" id="Antenna.loadsh3"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.loadsh3">[docs]</a>    def loadsh3(self):
        &quot;&quot;&quot; Load antenna&#39;s sh3 file

            sh3 file contains a thesholded version of ssh coefficients in shape 3

        &quot;&quot;&quot;
        _filesh3 = self._filename.split(&#39;.&#39;)[0]+&#39;.sh3&#39;
        filesh3 = pyu.getlong(_filesh3, pstruc[&#39;DIRANT&#39;])
        self.evaluated = False

        if os.path.isfile(filesh3):
            coeff = io.loadmat(filesh3, appendmat=False)

            #
            # This test is to fix a problem with 2 different
            # behavior of io.loadmat
            #
            if type(coeff[&#39;fmin&#39;]) == float:
                fmin = coeff[&#39;fmin&#39;]
                fmax = coeff[&#39;fmax&#39;]
            else:
                fmin = coeff[&#39;fmin&#39;][0][0]
                fmax = coeff[&#39;fmax&#39;][0][0]
            # .. Warning
            # Warning modification takes only one dimension for k
            # if the .sh3 format evolve it may not work anymore
            #


            if type(coeff[&#39;Cx.lmax&#39;]) == float:
                lmax = coeff[&#39;Cx.lmax&#39;]
            else:
                lmax = coeff[&#39;Cx.lmax&#39;][0][0]

            Cx = SCoeff(typ = &#39;s3&#39;,
                        fmin = fmin ,
                        fmax = fmax ,
                        lmax = lmax,
                        data = coeff[&#39;Cx.s3&#39;],
                        ind =  coeff[&#39;Cx.ind&#39;],
                        k =  np.squeeze(coeff[&#39;Cx.k&#39;]))


            Cy = SCoeff(typ= &#39;s3&#39;,
                        fmin = fmin ,
                        fmax = fmax ,
                        lmax = lmax,
                        data = coeff[&#39;Cy.s3&#39;],
                        ind =  coeff[&#39;Cy.ind&#39;],
                        k =  np.squeeze(coeff[&#39;Cy.k&#39;]))



            Cz = SCoeff(typ = &#39;s3&#39;,
                        fmin = fmin ,
                        fmax = fmax ,
                        data = coeff[&#39;Cz.s3&#39;],
                        lmax = lmax,
                        ind =  coeff[&#39;Cz.ind&#39;],
                        k =  np.squeeze(coeff[&#39;Cz.k&#39;]))


            if not &#39;S&#39; in self.__dict__.keys():
                self.S = SSHCoeff(Cx, Cy,Cz)
            else:
                self.S.sets3(Cx,Cy,Cz)

            self.nf = np.shape(Cx.s3)[0]
            self.fGHz = np.linspace(fmin, fmax, self.nf)
        else:
            print(_filesh3, &#39; does not exist&#39;)</div>

<div class="viewcode-block" id="Antenna.savevsh2"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.savevsh2">[docs]</a>    def savevsh2(self, filename = &#39;&#39;):
        &quot;&quot;&quot; save coeff in  a .vsh2 antenna file

        Parameters
        ----------

        filename : string 

        &quot;&quot;&quot;

        # create vsh2 file
        if filename == &#39;&#39;:
            _filevsh2 = self._filename.replace(&#39;.trx&#39;, &#39;.vsh2&#39;)

        _filevsh2  = filename
        filevsh2 = pyu.getlong(_filevsh2, pstruc[&#39;DIRANT&#39;])

        if os.path.isfile(filevsh2):
            print(filevsh2, &#39; already exist&#39;)
        else:
            print(&#39;create &#39;, filevsh2, &#39; file&#39;)

            coeff = {}
            coeff[&#39;fmin&#39;] = self.fGHz[0]
            coeff[&#39;fmax&#39;] = self.fGHz[-1]
            coeff[&#39;Br.ind&#39;] = self.C.Br.ind2
            coeff[&#39;Bi.ind&#39;] = self.C.Bi.ind2
            coeff[&#39;Cr.ind&#39;] = self.C.Cr.ind2
            coeff[&#39;Ci.ind&#39;] = self.C.Ci.ind2
            coeff[&#39;Br.s2&#39;] = self.C.Br.s2
            coeff[&#39;Bi.s2&#39;] = self.C.Bi.s2
            coeff[&#39;Cr.s2&#39;] = self.C.Cr.s2
            coeff[&#39;Ci.s2&#39;] = self.C.Ci.s2

            io.savemat(filevsh2, coeff, appendmat=False)</div>



<div class="viewcode-block" id="Antenna.loadsh2"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.loadsh2">[docs]</a>    def loadsh2(self):
        &quot;&quot;&quot; load  spherical harmonics coefficient in shape  2

        &quot;&quot;&quot;
        _filesh2 = self._filename.split(&#39;.&#39;)[0]+&#39;.sh2&#39;
        filesh2 = pyu.getlong(_filesh2, pstruc[&#39;DIRANT&#39;])

        if os.path.isfile(filesh2):
            coeff = io.loadmat(filesh2, appendmat=False)
            #
            # This test is to fix a problem with 2 different
            # behavior of io.loadmat
            #
            if type(coeff[&#39;fmin&#39;]) == float:
                fmin = coeff[&#39;fmin&#39;]
                fmax = coeff[&#39;fmax&#39;]
            else:
                fmin = coeff[&#39;fmin&#39;][0][0]
                fmax = coeff[&#39;fmax&#39;][0][0]


            if type(coeff[&#39;Cx.lmax&#39;]) == float:
                lmax = coeff[&#39;Cx.lmax&#39;]
            else:
                lmax = coeff[&#39;Cx.lmax&#39;][0][0]


            Cx = SCoeff(typ=&#39;s2&#39;,
                        fmin=fmin,
                        fmax=fmax,
                        lmax = lmax,
                        data=coeff[&#39;Cx.s2&#39;],
                        ind=coeff[&#39;Cx.ind&#39;])

            Cy = SCoeff(typ=&#39;s2&#39;,
                        fmin=fmin,
                        fmax=fmax,
                        lmax = lmax,
                        data=coeff[&#39;Cy.s2&#39;],
                        ind=coeff[&#39;Cy.ind&#39;])
            Cz = SCoeff(typ=&#39;s2&#39;,
                        fmin=fmin,
                        fmax=fmax,
                        lmax = lmax,
                        data=coeff[&#39;Cz.s2&#39;],
                        ind=coeff[&#39;Cz.ind&#39;])


            self.S = SSHCoeff(Cx, Cy,Cz)
            Nf = np.shape(Cx.s2)[0]
            self.fGHz = np.linspace(fmin, fmax, Nf)
        else:
            print( _filesh2, &#39; does not exist&#39;)</div>



<div class="viewcode-block" id="Antenna.loadvsh2"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.loadvsh2">[docs]</a>    def loadvsh2(self):
        &quot;&quot;&quot; load antenna from .vsh2 file format

        Load antenna&#39;s vsh2 file which only contains
        the vsh coefficients in shape 2

        &quot;&quot;&quot;

        _filevsh2 = self._filename
        filevsh2 = pyu.getlong(_filevsh2, pstruc[&#39;DIRANT&#39;])

        if os.path.isfile(filevsh2):
            coeff = io.loadmat(filevsh2, appendmat=False)
            #
            # This test is to fix a problem with 2 different
            # behavior of io.loadmat
            #
            if type(coeff[&#39;fmin&#39;]) == float:
                fmin = coeff[&#39;fmin&#39;]
                fmax = coeff[&#39;fmax&#39;]
            else:
                fmin = coeff[&#39;fmin&#39;][0][0]
                fmax = coeff[&#39;fmax&#39;][0][0]

            Br = VCoeff(typ=&#39;s2&#39;, fmin=fmin, fmax=fmax,
                         data=coeff[&#39;Br.s2&#39;], ind=coeff[&#39;Br.ind&#39;])
            Bi = VCoeff(typ=&#39;s2&#39;, fmin=fmin, fmax=fmax,
                         data=coeff[&#39;Bi.s2&#39;], ind=coeff[&#39;Bi.ind&#39;])
            Cr = VCoeff(typ=&#39;s2&#39;, fmin=fmin, fmax=fmax,
                         data=coeff[&#39;Cr.s2&#39;], ind=coeff[&#39;Cr.ind&#39;])
            Ci = VCoeff(typ=&#39;s2&#39;, fmin=fmin, fmax=fmax,
                         data=coeff[&#39;Ci.s2&#39;], ind=coeff[&#39;Ci.ind&#39;])
            self.C = VSHCoeff(Br, Bi, Cr, Ci)
            Nf = np.shape(Br.s2)[0]
            self.fGHz = np.linspace(fmin, fmax, Nf)
        else:
            print( _filevsh2, &#39; does not exist&#39;)</div>

<div class="viewcode-block" id="Antenna.loadvsh3_old"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.loadvsh3_old">[docs]</a>    def loadvsh3_old(self):
        &quot;&quot;&quot; Load antenna vsh coefficients in shape 3

        &quot;&quot;&quot;

        _filevsh3 = self._filename
        filevsh3 = getlong(_filevsh3, pstruc[&#39;DIRANT&#39;])
        fmin = 2.
        fmax = 8.
        if os.path.isfile(filevsh3):
            coeff = io.loadmat(filevsh3, appendmat=False)
            Br = VCoeff(&#39;s3&#39;, fmin, fmax, coeff[&#39;Br.s3&#39;],
                         coeff[&#39;Br.ind&#39;], coeff[&#39;Br.k&#39;])
            Bi = VCoeff(&#39;s3&#39;, fmin, fmax, coeff[&#39;Bi.s3&#39;],
                         coeff[&#39;Bi.ind&#39;], coeff[&#39;Bi.k&#39;])
            Cr = VCoeff(&#39;s3&#39;, fmin, fmax, coeff[&#39;Cr.s3&#39;],
                         coeff[&#39;Cr.ind&#39;], coeff[&#39;Cr.k&#39;])
            Ci = VCoeff(&#39;s3&#39;, fmin, fmax, coeff[&#39;Ci.s3&#39;],
                         coeff[&#39;Ci.ind&#39;], coeff[&#39;Ci.k&#39;])
            self.C = VSHCoeff(Br, Bi, Cr, Ci)
            self.fGHz = np.linspace(fmin, fmax, 121)
        else:
            print(_filevsh3, &#39; does not exist&#39;)</div>

<div class="viewcode-block" id="Antenna.pol2cart"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.pol2cart">[docs]</a>    def pol2cart(self, ith):
        &quot;&quot;&quot; converts FTheta, FPhi to Fx,Fy,Fz for theta=ith

        Parameters
        ----------
        ith : theta index

        Returns
        -------

        Fx
        Fy
        Fz

        See Also
        --------

        cart2pol

        &quot;&quot;&quot;
        Fth = self.Ft[:, ith, :]
        Fph = self.Fp[:, ith, :]
        th = self.theta[ith]
        ph = self.phi

        Fx = Fth * np.cos(th) * np.cos(ph) - Fph * np.sin(ph)
        Fy = Fth * np.cos(th) * np.sin(ph) + Fph * np.cos(ph)
        Fz = (-1) * Fth * np.sin(th)

        return(Fx, Fy, Fz)</div>

<div class="viewcode-block" id="Antenna.cart2pol"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.Antenna.html#pylayers.antprop.antenna.Antenna.cart2pol">[docs]</a>    def cart2pol(self, Fx, Fy, Fz, ith):
        &quot;&quot;&quot; converts Fx,Fy,Fz to Ftheta, Fphi for theta=ith

        Parameters
        ----------

        Fx  : np.array
        Fy  : np.array
        Fz  : np.array
        ith : theta index

        See Also
        --------

        pol2cart

        &quot;&quot;&quot;
        th = self.theta[ith]
        ph = self.phi

        Fth = Fx * np.cos(th) * np.cos(ph) + Fy * np.cos(th) * np.sin(ph) - Fz * np.sin(th)
        Fph = -Fx * np.sin(ph) + Fy * np.cos(th)

        SqG = np.sqrt(np.real(Fph * np.conj(Fph) + Fth * np.conj(Fth)))

        self.sqG[:, ith, :] = SqG
        self.Ft[:, ith, :] = Fth
        self.Fp[:, ith, :] = Fph</div></div>

<div class="viewcode-block" id="forcesympol"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.forcesympol.html#pylayers.antprop.antenna.forcesympol">[docs]</a>def forcesympol(A):
    &quot;&quot;&quot; plot VSH transform vsh basis in 3D plot

    Parameters
    ----------

    n,m   : integer values (m&lt;=n)
    theta : ndarray
    phi   : ndarray
    sf    : boolean
        if sf : plotted figures are saved in a *.png file
        else  : plotted figures aren&#39;t saved

    Examples
    --------

    .. plot::
        :include-source:

        &gt;&gt;&gt; from pylayers.antprop.antenna import *
        &gt;&gt;&gt; import  matplotlib.pyplot as plt
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; n=5
        &gt;&gt;&gt; m=3
        &gt;&gt;&gt; theta = np.linspace(0,np.pi,30)
        &gt;&gt;&gt; phi   = np.linspace(0,2*np.pi,60)
        &gt;&gt;&gt; plotVW(n,m,theta,phi)

    &quot;&quot;&quot;
    # calculate v and w
    if m &lt;= n:
        theta[np.where(theta == np.pi / 2)[0]] = np.pi / 2 + \
            1e-10  # .. todo :: not clean
        x = -np.cos(theta)
        Pmm1n, Pmp1n = AFLegendre(n, m, x)

        t1 = np.sqrt((n + m) * (n - m + 1))
        t2 = np.sqrt((n - m) * (n + m + 1))
        y1 = t1 * Pmm1n[:, m, n] - t2 * Pmp1n[:, m, n]
        y2 = t1 * Pmm1n[:, m, n] + t2 * Pmp1n[:, m, n]

        Ephi = np.exp(1j * m * phi)
        cphi = np.cos(m * phi)
        if m == 0:
            sphi = 1e-10
        else:
            sphi = np.sin(m * phi)

        ny = len(y1)
        ne = len(Ephi)
        vy = np.ones(ny)
        ve = np.ones(ne)
        Y1 = np.outer(y1, ve)
        Y2 = np.outer(y2, ve)
        EPh = np.outer(vy, Ephi)

        const = (-1.0) ** n / (2 * np.sqrt(n * (n + 1)))
        V = const * Y1 * EPh
        #V[np.isinf(V)|isnan(V)]=0
        Vcos = cphi * V
        Vsin = sphi * V

        if m == 0:
            #W=np.zeros((len(theta),len(phi)))
            W = np.ones((len(theta), len(phi))) * 1e-10
        else:
            Waux = Y2 * EPh
            x1 = 1.0 / x
            W = np.outer(x1, const) * Waux
        Wcos = cphi * W
        Wsin = sphi * W

        # plot V and W
        Ntheta = np.size(theta)
        vt = np.ones(Ntheta)
        Nphi = np.size(phi)
        vp = np.ones(Nphi)
        Phi = np.outer(vt, phi)
        Theta = np.outer(theta, vp)

        #figdirV=&#39;/home/rburghel/Bureau/bases_decomposition_VW/base_V_Vsin_Vcos/&#39;
        figdirV = &#39;./&#39;
        ext1 = &#39;.pdf&#39;
        ext2 = &#39;.eps&#39;
        ext3 = &#39;.png&#39;

        fig = plt.figure()
        ax = axes3d.Axes3D(fig)
        X = abs(V) * np.cos(Phi) * np.sin(Theta)
        Y = abs(V) * np.sin(Phi) * np.sin(Theta)
        Z = abs(V) * np.cos(Theta)
        ax.set_xlabel(&#39;X&#39;)
        ax.set_ylabel(&#39;Y&#39;)
        ax.set_zlabel(&#39;Z&#39;)
        ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.hot_r)
        ax.set_xlim3d([-1, 1])
        ax.set_ylim3d([-1, 1])
        ax.set_zlim3d([-1, 1])
        if sf:
            sz = fig.get_size_inches()
            fig.set_size_inches(sz * 1.8)
            figname = figdirV + &#39;V&#39; + str(n) + str(m)
            fig.savefig(figname + ext1, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext2, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext3, orientation=&#39;portrait&#39;)

        fig = plt.figure()
        ax = axes3d.Axes3D(fig)
        X = abs(Vcos) * np.cos(Phi) * np.sin(Theta)
        Y = abs(Vcos) * np.sin(Phi) * np.sin(Theta)
        Z = abs(Vcos) * np.cos(Theta)
        ax.set_xlabel(&#39;X&#39;)
        ax.set_ylabel(&#39;Y&#39;)
        ax.set_zlabel(&#39;Z&#39;)
        ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.hot_r)
        ax.set_xlim3d([-1, 1])
        ax.set_ylim3d([-1, 1])
        ax.set_zlim3d([-1, 1])

        if sf:
            sz = fig.get_size_inches()
            fig.set_size_inches(sz * 1.8)
            figname = figdirV + &#39;Vcos&#39; + str(n) + str(m) + &#39;.jpg&#39;
            fig.savefig(figname + ext1, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext2, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext3, orientation=&#39;portrait&#39;)

        fig = plt.figure()
        ax = axes3d.Axes3D(fig)
        X = abs(Vsin) * np.cos(Phi) * np.sin(Theta)
        Y = abs(Vsin) * np.sin(Phi) * np.sin(Theta)
        Z = abs(Vsin) * np.cos(Theta)
        ax.set_xlabel(&#39;X&#39;)
        ax.set_ylabel(&#39;Y&#39;)
        ax.set_zlabel(&#39;Z&#39;)
        ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.hot_r)
        ax.set_xlim3d([-1, 1])
        ax.set_ylim3d([-1, 1])
        ax.set_zlim3d([-1, 1])
        if sf:
            sz = fig.get_size_inches()
            fig.set_size_inches(sz * 1.8)
            figname = figdirV + &#39;Vsin&#39; + str(n) + str(m) + &#39;.jpg&#39;
            fig.savefig(figname + ext1, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext2, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext3, orientation=&#39;portrait&#39;)

        #figdirW=&#39;/home/rburghel/Bureau/bases_decomposition_VW/base_W_Wsin_Wcos/&#39;
        figdirW = &#39;./&#39;

        fig = plt.figure()
        ax = axes3d.Axes3D(fig)
        X = abs(W) * np.cos(Phi) * np.sin(Theta)
        Y = abs(W) * np.sin(Phi) * np.sin(Theta)
        Z = abs(W) * np.cos(Theta)
        ax.set_xlabel(&#39;X&#39;)
        ax.set_ylabel(&#39;Y&#39;)
        ax.set_zlabel(&#39;Z&#39;)
        ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.hot_r)
        ax.set_xlim3d([-1, 1])
        ax.set_ylim3d([-1, 1])
        ax.set_zlim3d([-1, 1])
        if sf:
            sz = fig.get_size_inches()
            fig.set_size_inches(sz * 1.8)
            figname = figdirW + &#39;W&#39; + str(n) + str(m)
            fig.savefig(figname + ext1, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext2, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext3, orientation=&#39;portrait&#39;)

        fig = plt.figure()
        ax = axes3d.Axes3D(fig)
        X = abs(Wcos) * np.cos(Phi) * np.sin(Theta)
        Y = abs(Wcos) * np.sin(Phi) * np.sin(Theta)
        Z = abs(Wcos) * np.cos(Theta)
        ax.set_xlabel(&#39;X&#39;)
        ax.set_ylabel(&#39;Y&#39;)
        ax.set_zlabel(&#39;Z&#39;)
        ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.hot_r)
        ax.set_xlim3d([-1, 1])
        ax.set_ylim3d([-1, 1])
        ax.set_zlim3d([-1, 1])
        if sf:
            sz = fig.get_size_inches()
            fig.set_size_inches(sz * 1.8)
            figname = figdirW + &#39;Wcos&#39; + str(n) + str(m)
            fig.savefig(figname + ext1, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext2, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext3, orientation=&#39;portrait&#39;)

        fig = plt.figure()
        ax = axes3d.Axes3D(fig)
        X = abs(Wsin) * np.cos(Phi) * np.sin(Theta)
        Y = abs(Wsin) * np.sin(Phi) * np.sin(Theta)

        fig = plt.figure()
        ax = axes3d.Axes3D(fig)
        X = abs(Wsin) * np.cos(Phi) * np.sin(Theta)
        Y = abs(Wsin) * np.sin(Phi) * np.sin(Theta)
        Z = abs(Wsin) * np.cos(Theta)
        ax.set_xlabel(&#39;X&#39;)
        ax.set_ylabel(&#39;Y&#39;)
        ax.set_zlabel(&#39;Z&#39;)
        ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.hot_r)
        ax.set_xlim3d([-1, 1])
        ax.set_ylim3d([-1, 1])
        ax.set_zlim3d([-1, 1])
        if sf:
            sz = fig.get_size_inches()
            fig.set_size_inches(sz * 1.8)
            figname = figdirW + &#39;Wsin&#39; + str(n) + str(m)
            fig.savefig(figname + ext1, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext2, orientation=&#39;portrait&#39;)
            fig.savefig(figname + ext3, orientation=&#39;portrait&#39;)

        plt.show()

    else:
        print(&quot;Error: m&gt;n!!!&quot;)</div>

<div class="viewcode-block" id="compdiag"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.compdiag.html#pylayers.antprop.antenna.compdiag">[docs]</a>def compdiag(k, A, th, ph, Fthr, Fphr, typ=&#39;modulus&#39;, lang=&#39;english&#39;, fontsize=18):
    &quot;&quot;&quot; makes comparison between original pattern and reconstructed pattern

    Parameters
    ----------

    k : frequency index
    A : Antenna

    ph : phi base      (1 x Np)
    th : theta base    (1 x Nt)

    Fthr : Fth output of Fsynth Nf x (Ntheta*Tphi)
    Fphr : Fth output of Fsynth Nf x (Ntheta*Tphi)

    lang = &#39;french&#39;
         = &#39;english&#39;

    &quot;&quot;&quot;

    Nf = np.shape(Fthr)[0]

    #Fthr = Fthr.reshape(Nf,len(th),len(ph))
    #Fphr = Fphr.reshape(Nf,len(th),len(ph))

    plt.figure()
    rc(&#39;text&#39;, usetex=True)
    Ftho = A.Ftheta
    Fpho = A.Fphi

    # limites module Fthr, Ftho, Fphr, Fpho
    maxTr = abs(Fthr[:, :, k]).max()
    maxTo = abs(Ftho[:, :, k ]).max()
    MmT = max(maxTr, maxTo)

    minTr = abs(Fthr[ :, :, k ]).min()
    minTo = abs(Ftho[ :, :, k ]).min()
    mmT = min(minTr, minTo)

    maxPr = abs(Fphr[ :, :, k ]).max()
    maxPo = abs(Fpho[ :, :, k ]).max()
    MmP = max(maxPr, maxPo)

    minPr = abs(Fphr[ :, :, k ]).min()
    minPo = abs(Fpho[ :, :, k ]).min()
    mmP = min(minPr, minPo)

    # limites real Fthr, Ftho, Fphr, Fpho
    maxTrr = np.real(Fthr[ :, :, k ]).max()
    maxTor = np.real(Ftho[ :, :, k ]).max()
    MrT = max(maxTrr, maxTor)

    minTrr = np.real(Fthr[ :, :, k ]).min()
    minTor = np.real(Ftho[ :, :, k ]).min()
    mrT = min(minTrr, minTor)

    maxPrr = np.real(Fphr[ :, :, k ]).max()
    maxPor = np.real(Fpho[ :, :, k ]).max()
    MrP = max(maxPrr, maxPor)

    minPrr = np.real(Fphr[ :, :, k ]).min()
    minPor = np.real(Fpho[ :, :, k ]).min()
    mrP = min(minPrr, minPor)

    # limites real Fthr, Ftho, Fphr, Fpho
    maxTri = np.imag(Fthr[ :, :, k ]).max()
    maxToi = np.imag(Ftho[ :, :, k ]).max()
    MiT = max(maxTri, maxToi)

    minTri = np.imag(Fthr[ :, :, k ]).min()
    minToi = np.imag(Ftho[ :, :, k ]).min()
    miT = min(minTri, minToi)

    maxPri = np.imag(Fphr[ :, :, k ]).max()
    maxPoi = np.imag(Fpho[ :, :, k ]).max()
    MiP = max(maxPri, maxPoi)

    minPri = np.imag(Fphr[ :, :, k ]).min()
    minPoi = np.imag(Fpho[ :, :, k ]).min()
    miP = min(minPri, minPoi)

    # limithes arg Fth,Fph
    maxATr = np.angle(Fthr[ :, :, k ]).max()
    maxATo = np.angle(Ftho[ :, :, k ]).max()
    maT = max(maxATr, maxATo)
    minATr = np.angle(Fthr[ :, :, k ]).min()
    minATo = np.angle(Ftho[ :, :, k ]).min()
    maT0 = min(minATr, minATo)

    maxAPr = np.angle(Fphr[ :, :, k ]).max()
    maxAPo = np.angle(Fpho[ :, :, k ]).max()
    maP = max(maxAPr, maxAPo)
    minAPr = np.angle(Fphr[ :, :, k ]).min()
    minAPo = np.angle(Fpho[ :, :, k ]).min()
    maP0 = min(minAPr, minAPo)

    ax = plt.axes([0, 0, 360, 180])
    rtd = 180 / np.pi

    plt.subplot(221)
    if typ == &#39;modulus&#39;:
    #
    #cmap=cm.jet
        #pcolor(A.phi*rtd,A.theta*rtd,abs(Ftho[k,:,:]),vmin=0,vmax=mmT)
            #
    #cmap= gray
    #pcolor(A.phi*rtd,A.theta*rtd,abs(Ftho[k,:,:]),cmap=cm.gray_r,vmin=0,vmax=mmT)
            #
    #cmap=cm.hot
        plt.pcolor(A.phi * rtd, A.theta * rtd, abs(Ftho[ :, :, k ]),
                   cmap=cm.hot_r, vmin=mmT, vmax=MmT)
        plt.title(r&#39;$|F_{\theta}|$ original&#39;, fontsize=fontsize)

    if typ == &#39;real&#39;:
        #pcolor(A.phi*rtd,A.theta*rtd,real(Ftho[k,:,:]),cmap=cm.gray_r,vmin=0,vmax=mmT)
        plt.pcolor(A.phi * rtd, A.theta * rtd, np.real(Ftho[ :, :, k ]),
                   cmap=cm.hot_r, vmin=mrT, vmax=MrT)
        title(r&#39;Re ($F_{\theta}$) original&#39;, fontsize=fontsize)
    if typ == &#39;imag&#39;:
        #pcolor(A.phi*rtd,A.theta*rtd,imag(Ftho[k,:,:]),cmap=cm.gray_r,vmin=0,vmax=mmT)
        pcolor(A.phi * rtd, A.theta * rtd, np.imag(Ftho[ :, :, k ]),
               cmap=cm.hot_r, vmin=miT, vmax=MiT)
        title(r&#39;Im ($F_{\theta}$) original&#39;, fontsize=fontsize)
    if typ == &#39;phase&#39;:
        #pcolor(A.phi*rtd,A.theta*rtd,angle(Ftho[k,:,:]),cmap=cm.gray_r,vmin=maT0,vmax=maT)
        plt.pcolor(A.phi * rtd, A.theta * rtd, np.angle(Ftho[ :, :, k ]),
                   cmap=cm.hot_r, vmin=maT0, vmax=maT)
        if lang == &#39;french&#39;:
            plt.title(r&#39;Arg ($F_{\theta}$) original&#39;, fontsize=fontsize)
        else:
            plt.title(r&#39;Ang ($F_{\theta}$) original&#39;, fontsize=fontsize)
    plt.axis([0, 360, 0, 180])
    plt.ylabel(r&#39;$\theta$ (deg)&#39;, fontsize=fontsize)
    plt.xticks(fontsize=fontsize)
    plt.yticks(fontsize=fontsize)
    cbar = plt.colorbar()
    for t in cbar.ax.get_yticklabels():
        t.set_fontsize(fontsize)

    plt.subplot(222)
    if typ == &#39;modulus&#39;:
        plt.pcolor(A.phi * rtd, A.theta * rtd, abs(Fpho[:, :, k ]),
                   cmap=cm.hot_r, vmin=mmP, vmax=MmP)
        plt.title(&#39;$|F_{\phi}|$ original&#39;, fontsize=fontsize)
    if typ == &#39;real&#39;:
        plt.pcolor(A.phi * rtd, A.theta * rtd, np.real(Fpho[ :, :, k ]),
                   cmap=cm.hot_r, vmin=mrP, vmax=MrP)
        plt.title(&#39;Re ($F_{\phi}$) original&#39;, fontsize=fontsize)
    if typ == &#39;imag&#39;:
        plt.pcolor(A.phi * rtd, A.theta * rtd, np.imag(Fpho[ :, :, k ]),
                   cmap=cm.hot_r, vmin=miP, vmax=MiP)
        plt.title(&#39;Im ($F_{\phi}$) original&#39;, fontsize=fontsize)
    if typ == &#39;phase&#39;:
        plt.pcolor(A.phi * rtd, A.theta * rtd, np.angle(Fpho[ :, :, k ]),
                   cmap=cm.hot_r, vmin=maP0, vmax=maP)
        if lang == &#39;french&#39;:
            plt.title(&#39;Arg ($F_{\phi}$) original&#39;, fontsize=fontsize)
        else:
            plt.title(&#39;Ang ($F_{\phi}$) original&#39;, fontsize=fontsize)
    plt.axis([0, 360, 0, 180])
    plt.xticks(fontsize=fontsize)
    plt.yticks(fontsize=fontsize)
    cbar = plt.colorbar()
    for t in cbar.ax.get_yticklabels():
        t.set_fontsize(fontsize)

    plt.subplot(223)
    if typ == &#39;modulus&#39;:
        plt.pcolor(ph * rtd, th * rtd, abs(Fthr[:, :, k ]),
                   cmap=cm.hot_r, vmin=mmT, vmax=MmT)
        if lang == &#39;french&#39;:
            plt.title(r&#39;$|F_{\theta}|$ reconstruit&#39;, fontsize=fontsize)
        else:
            plt.title(r&#39;$|F_{\theta}|$ reconstructed&#39;, fontsize=fontsize)
    if typ == &#39;real&#39;:
        plt.pcolor(ph * rtd, th * rtd, np.real(Fthr[:,:,k ]),
                   cmap=cm.hot_r, vmin=mrT, vmax=MrT)
        if lang == &#39;french&#39;:
            title(r&#39;Re ($F_{\theta}$) reconstruit&#39;, fontsize=fontsize)
        else:
            title(r&#39;Re ($F_{\theta}$) reconstructed&#39;, fontsize=fontsize)
    if typ == &#39;imag&#39;:
        plt.pcolor(ph * rtd, th * rtd, np.imag(Fthr[ :, :, k ]),
                   cmap=cm.hot_r, vmin=miT, vmax=MiT)
        if lang == &#39;french&#39;:
            plt.title(r&#39;Im ($F_{\theta}$) reconstruit&#39;, fontsize=fontsize)
        else:
            plt.title(r&#39;Im ($F_{\theta}$) reconstructed&#39;, fontsize=fontsize)
    if typ == &#39;phase&#39;:
        plt.pcolor(A.phi * rtd, A.theta * rtd, np.angle(Fthr[:,:,k]),
                   cmap=cm.hot_r, vmin=maT0, vmax=maT)
        if lang == &#39;french&#39;:
            plt.title(r&#39;Arg ($F_{\theta}$) reconstruit&#39;, fontsize=fontsize)
        else:
            plt.title(r&#39;Ang ($F_{\theta}$) reconstructed&#39;, fontsize=fontsize)
    plt.axis([0, 360, 0, 180])
    plt.xlabel(r&#39;$\phi$ (deg)&#39;, fontsize=fontsize)
    plt.ylabel(r&#39;$\theta$ (deg)&#39;, fontsize=fontsize)
    plt.xticks(fontsize=fontsize)
    plt.yticks(fontsize=fontsize)
    cbar = plt.colorbar()
    for t in cbar.ax.get_yticklabels():
        t.set_fontsize(fontsize)

    plt.subplot(224)
    if typ == &#39;modulus&#39;:
        plt.pcolor(ph * rtd, th * rtd, abs(Fphr[ :, :,k]),
                   cmap=cm.hot_r, vmin=mmP, vmax=MmP)
        if lang == &#39;french&#39;:
            plt.title(&#39;$|F_{\phi}|$ reconstruit&#39;, fontsize=fontsize)
        else:
            plt.title(&#39;$|F_{\phi}|$ reconstructed&#39;, fontsize=fontsize)
    if typ == &#39;real&#39;:
        plt.pcolor(ph * rtd, th * rtd, np.real(Fphr[ :, :,k]),
                   cmap=cm.hot_r, vmin=mrP, vmax=MrP)
        if lang == &#39;french&#39;:
            plt.title(&#39;Re ($F_{\phi}$) reconstruit&#39;, fontsize=fontsize)
        else:
            plt.title(&#39;Re ($F_{\phi}$) reconstructed&#39;, fontsize=fontsize)
    if typ == &#39;imag&#39;:
        plt.pcolor(ph * rtd, th * rtd, np.imag(Fphr[ :, :,k]),
                   cmap=cm.hot_r, vmin=miP, vmax=MiP)
        if lang == &#39;french&#39;:
            plt.title(&#39;Im ($F_{\phi}$) reconstruit&#39;, fontsize=fontsize)
        else:
            plt.title(&#39;Im ($F_{\phi}$) reconstructed&#39;, fontsize=fontsize)
    if typ == &#39;phase&#39;:
        plt.pcolor(A.phi * rtd, A.theta * rtd, np.angle(Fphr[ :, :,k]),
                   cmap=cm.hot_r, vmin=maP0, vmax=maP)
        if lang == &#39;french&#39;:
            plt.title(&#39;Arg ($F_{\phi}$) reconstruit&#39;, fontsize=fontsize)
        else:
            plt.title(&#39;Ang ($F_{\phi}$) reconstructed&#39;, fontsize=fontsize)
    plt.axis([0, 360, 0, 180])
    plt.xlabel(r&#39;$\phi$ (deg)&#39;, fontsize=fontsize)
    plt.xticks(fontsize=fontsize)
    plt.yticks(fontsize=fontsize)
    cbar = plt.colorbar()
    for t in cbar.ax.get_yticklabels():
        t.set_fontsize(fontsize)</div>

<div class="viewcode-block" id="BeamGauss"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.BeamGauss.html#pylayers.antprop.antenna.BeamGauss">[docs]</a>def BeamGauss(theta,phi,Gmax=19.77,HPBW_az=10,HPBW_el=40,Tilt=10):
    &quot;&quot;&quot; Beam with a Gaussian shape

    Parameters
    ----------
                
    theta : float 
          angle in degree
    phi   : float 
          angle in degree
    Gmax  : float 
    HPBW_az : float  
        Half Power Beamwidth azimuth degree
    HPBW_el : float
        Half Power Beamwidth elevation degree
    Tilt : float 
        angle in degree 

    &quot;&quot;&quot;
    c = np.pi/180.
    az = c*(theta-(Tilt+90))*2*np.sqrt(np.log(2))
    el = c*phi*2*np.sqrt(np.log(2))
    taz = -(az/(HPBW_az*c))**2
    tel = -(el/(HPBW_el*c))**2
    gain = 10**(Gmax/10.)*np.exp(taz)*np.exp(tel)
    return(gain)</div>

<div class="viewcode-block" id="show3D"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.show3D.html#pylayers.antprop.antenna.show3D">[docs]</a>def show3D(F, theta, phi, k, col=True):
    &quot;&quot;&quot; show 3D matplotlib diagram

    Parameters
    ----------

    F      : ndarray (Nf,Nt,Np)
    theta  : ndarray (1xNt)
        angle
    phi    : ndarray (1xNp)
        angle
    theta  : ndarray (Nt)
    k      : int
        frequency index
    col    : boolean
        if col  -&gt; color coded plot3D
        if col == False -&gt; simple plot3D

    Examples
    --------

    .. plot::
        :include-source:

        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; from pylayers.antprop.antenna import *
        &gt;&gt;&gt; A = Antenna(&#39;defant.vsh3&#39;)
        &gt;&gt;&gt; A.eval(grid=True)


    Warnings
    --------

        len(theta) must be equal with shape(F)[1]
        len(phi) must be equal with shape(F)[2]

    &quot;&quot;&quot;

    nth = len(theta)
    nph = len(phi)

    if k &gt;= np.shape(F)[0]:
        print(&#39;Error: frequency index k not in F defined interval&#39;)
    if nth != np.shape(F)[1]:
        print(&#39;Error: shape mistmatch between theta and F&#39;)

    if nph != np.shape(F)[2]:
        print(&#39;Error: shape mistmatch between phi and F&#39;)

    fig = plt.figure()
    ax = axes3d.Axes3D(fig)

    V = F[k, :, :]

    vt = np.ones(nth)
    vp = np.ones(nph)
    Th = np.outer(theta, vp)
    Ph = np.outer(vt, phi)

    X = abs(V) * np.cos(Ph) * np.sin(Th)
    Y = abs(V) * np.sin(Ph) * np.sin(Th)
    Z = abs(V) * np.cos(Th)

    ax.set_xlabel(&#39;X&#39;)
    ax.set_ylabel(&#39;Y&#39;)
    ax.set_zlabel(&#39;Z&#39;)

    if (col):
        ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.hot_r)
    else:
        ax.plot3D(np.ravel(X), np.ravel(Y), np.ravel(Z))</div>

<div class="viewcode-block" id="AntPosRot"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.AntPosRot.html#pylayers.antprop.antenna.AntPosRot">[docs]</a>class AntPosRot(Antenna):
    &quot;&quot;&quot; Antenna + position + Rotation

    Notes
    -----

    This class implement an antenna at a position p
    with an orientation T

    &quot;&quot;&quot;
    def __init__(self,name,p,T):
        #super(AntPosRot,self).__init__(self,typ=name)
        Antenna.__init__(self,typ=name)
        self.p = p 
        self.T = T 

    def __repr__(self):
        st = self._filename+&#39;\n\n&#39;
        st = st +&quot;p:   &quot;+ str(self.p)+&#39;\n\n&#39;
        st = st +&quot;T:  &quot;+ str(self.T)+&#39;\n&#39;
        return(st)                        

<div class="viewcode-block" id="AntPosRot.show3"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.AntPosRot.html#pylayers.antprop.antenna.AntPosRot.show3">[docs]</a>    def show3(self,**kwargs):
        self._show3(newfig=False,
                interact=False,
                T=self.T,
                po=self.p,
                **kwargs)</div>

<div class="viewcode-block" id="AntPosRot.field"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.AntPosRot.html#pylayers.antprop.antenna.AntPosRot.field">[docs]</a>    def field(self,p):
        &quot;&quot;&quot; calculate field at points p 

        Parameters
        ----------

        p : np.array (N,3)
            observation point 

        &quot;&quot;&quot;

        rad_to_deg = 180/np.pi
        assert p.shape[-1]==3

        if len(p.shape)==1:
            r = p[None,:]-self.p[None,:]
        else:
            r = p-self.p[None,:]
        
        dist = np.sqrt(np.sum(r*r,axis=-1))[:,None]
        u = r/dist 
        th = np.arccos(u[:,2])
        ph = np.arctan2(u[:,1],u[:,0])
        tang = np.vstack((th,ph)).T
        #print(&quot;global&quot;,tang*rad_to_deg)
        tangl,Rt = geu.BTB(tang, self.T)
        #print(&quot;local&quot;,tangl*rad_to_deg)
        self.eval(th=tangl[:,0],ph=tangl[:,1],grid=False)

        E = (self.Ft[:,None,:]*self.T[:,2][None,:,None]
            +self.Fp[:,None,:]*self.T[:,0][None,:,None])
        P = np.exp(-1j*2*np.pi*self.fGHz[None,None,:]*dist[...,None]/0.3)/dist[...,None]
        EP = E*P
        return(EP)</div></div>

def _gain(Ft,Fp):
    &quot;&quot;&quot;  calculates antenna gain

    Parameters
    ----------
    Ft
    Fp

    Returns
    -------

    G  : np.array(Nt,Np,Nf) dtype:float
        linear gain 
              or np.array(Nr,Nf)
    sqG : np.array(Nt,Np,Nf) dtype:float 
        linear sqare root of gain 
              or np.array(Nr,Nf)
    efficiency : np.array (,Nf) dtype:float 
        efficiency 
    hpster : np.array (,Nf) dtype:float
        half power solid angle :  1 ~ 4pi steradian 
    ehpbw : np.array (,Nf) dtyp:float 
        equivalent half power beamwidth (radians)

    Notes
    -----

    .. math:: 

        G(\theta,phi) = |F_{\\theta}|^2 + |F_{\\phi}|^2

    &quot;&quot;&quot;
    G = np.real( Fp * np.conj(Fp)
              +  Ft * np.conj(Ft) )

    return(G)


def _hpbw(G,th,ph):
    &quot;&quot;&quot; half power beamwidth 

    Parameters
    ----------

    Gain : Ftheta
        Nt x Np 
    th : np.array
        ,Nt
    ph : np.array
        ,Np

    Returns
    -------

    ehpbw : effective half power beamwidth 
    hpster : half power solid angle (steradians)

    &quot;&quot;&quot;
    #
    GdB = 10*np.log10(G)
    GdBmax = np.max(np.max(GdB,axis=0),axis=0)
    
    dt = th[1]-th[0]
    dp = ph[1]-ph[0]
    Nt = len(th)
    Np = len(ph)
    Nf = GdB.shape[2]
    hpster = np.zeros(Nf)
    ehpbw  =  np.zeros(Nf)
    for k in range(Nf):
        U  = np.zeros((Nt,Np))
        A = GdB[:,:,k]*np.ones(Nt)[:,None]*np.ones(Np)[None,:]
        u = np.where(A&gt;(GdBmax[k]-3))
        U[u] = 1
        V  = U*np.sin(th)[:,None]
        hpster[k]  = np.sum(V)*dt*dp/(4*np.pi)
        ehpbw[k]  = np.arccos(1-2*hpster[k])

    return ehpbw,hpster 

def _efficiency(G,th,ph):
    &quot;&quot;&quot; determine antenna efficiency 

    Parameters
    ----------
    Gain : Ftheta
        Nt x Np 
    th : np.array
        ,Nt
    ph : np.array
        ,Np

    Returns
    -------

    oefficiency : 

    &quot;&quot;&quot;
    #
    dt = th[1]-th[0]
    dp = ph[1]-ph[0]
    Nt = len(th)
    Np = len(ph)
    Gs = G*np.sin(th)[:,None,None]*np.ones(Np)[None,:,None]
    efficiency = np.sum(np.sum(Gs,axis=0),axis=0)*dt*dp/(4*np.pi)
    return efficiency

def _dirmax(G,th,ph):
    &quot;&quot;&quot; determine information in Gmax direction 

    Parameters
    ----------
    Gain : Ftheta
        Nt x Np 
    th : np.array
        ,Nt
    # GdBmax (,Nf)
    # Get direction of Gmax and get the polarisation state in that direction 
    # 
    Returns
    --------
    &quot;&quot;&quot;

    GdB = 10*np.log10(G)
    GdBmax = np.max(np.max(GdB,axis=0),axis=0)
    umax = np.array(np.where(GdB==GdBmax))[:,0]
    theta_max = th[umax[0]]
    phi_max = ph[umax[1]]
    M = geu.SphericalBasis(np.array([[theta_max,phi_max]]))
    sl = M[:,2].squeeze()
    uth = M[:,0] 
    uph = M[:,1] 
    el = Ft[tuple(umax)]*uth + Fp[tuple(umax)]*uph
    eln = el/np.linalg.norm(el)
    el = np.abs(eln.squeeze())
    hl = np.cross(sl,el)
    return GdBmax,theta_max,phi_max,(hl,sl,el)

<div class="viewcode-block" id="F0"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.F0.html#pylayers.antprop.antenna.F0">[docs]</a>def F0(nu,sigma):
    &quot;&quot;&quot; F0 function for horn antenna pattern 
    
    Parameters
    ----------

    nu : np.array 
        (....,nf)
    sigma : np.array 
        (,nf) 

    Notes
    -----
    http://www.ece.rutgers.edu/~orfanidi/ewa/ch18.pdf

    18.3.2

    &quot;&quot;&quot;
    nuos  = nu/sigma
    argp = nuos + sigma
    argm = nuos - sigma
    expf = np.exp(1j*(np.pi/2)*nuos**2)
    sf   = 1./sigma
    sp , cp = fresnel(argp)
    sm , cm = fresnel(argm)
    Fp = cp-1j*sp
    Fm = cm-1j*sm

    F = sf*expf*(Fp -Fm)
    return F</div>

<div class="viewcode-block" id="F1"><a class="viewcode-back" href="../../../api/pylayers.antprop.antenna.F1.html#pylayers.antprop.antenna.F1">[docs]</a>def F1(nu,sigma):
    &quot;&quot;&quot; F1 function for horn antenna pattern

    http://www.ece.rutgers.edu/~orfanidi/ewa/ch18.pdf

    18.3.3

    &quot;&quot;&quot;
    F = 0.5*(F0(nu+0.5,sigma)+F0(nu-0.5,sigma))
    return F</div>

if (__name__ == &quot;__main__&quot;):
    doctest.testmod()
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team
      <span class="lastupdated">
        Last updated on Apr 02, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>