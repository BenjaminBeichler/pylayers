

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.antprop.spharm &mdash; PyLayers</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_issue314.html">Exemple of issue 314</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_dakar.html">Outdoor Radio Coverage with Deygout Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_cover.html">Outdoor Radio Coverage with Deygout Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction_polar.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html">1&nbsp;&nbsp;&nbsp;pylayers.util.project Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.layout">2&nbsp;&nbsp;&nbsp;pylayers.gis.layout Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.selectl">3&nbsp;&nbsp;&nbsp;pylayers.gis.selectl Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.srtm">4&nbsp;&nbsp;&nbsp;pylayers.gis.srtm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.osmparser">5&nbsp;&nbsp;&nbsp;pylayers.gis.osmparser Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.ezone">6&nbsp;&nbsp;&nbsp;pylayers.gis.ezone Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antenna">7&nbsp;&nbsp;&nbsp;pylayers.antprop.antenna Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.aarray">8&nbsp;&nbsp;&nbsp;pylayers.antprop.aarray Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.spharm">9&nbsp;&nbsp;&nbsp;pylayers.antprop.spharm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antssh">10&nbsp;&nbsp;&nbsp;pylayers.antprop.antssh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antvsh">11&nbsp;&nbsp;&nbsp;pylayers.antprop.antvsh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.slab">12&nbsp;&nbsp;&nbsp;pylayers.antprop.slab Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.signature">13&nbsp;&nbsp;&nbsp;pylayers.antprop.signature Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.interactions">14&nbsp;&nbsp;&nbsp;pylayers.antprop.interactions Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffraction">15&nbsp;&nbsp;&nbsp;pylayers.antprop.diffraction Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffRT">16&nbsp;&nbsp;&nbsp;pylayers.antprop.diffRT Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.rays">17&nbsp;&nbsp;&nbsp;pylayers.antprop.rays Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.loss">18&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.channel">19&nbsp;&nbsp;&nbsp;pylayers.antprop.channel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id39">20&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coverage">21&nbsp;&nbsp;&nbsp;pylayers.antprop.coverage Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coeffModel">22&nbsp;&nbsp;&nbsp;pylayers.antprop.coeffModel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.link">23&nbsp;&nbsp;&nbsp;pylayers.simul.link Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit">24&nbsp;&nbsp;&nbsp;pylayers.simul.exploit Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit_simulnet">25&nbsp;&nbsp;&nbsp;pylayers.simul.exploit_simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simulnet">26&nbsp;&nbsp;&nbsp;pylayers.simul.simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simultraj">27&nbsp;&nbsp;&nbsp;pylayers.simul.simultraj Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.exploit.simnet">28&nbsp;&nbsp;&nbsp;pylayers.exploit.simnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesuwb">29&nbsp;&nbsp;&nbsp;pylayers.measures.mesuwb Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesmimo">30&nbsp;&nbsp;&nbsp;pylayers.measures.mesmimo Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.cormoran">31&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.vna.E5072A">32&nbsp;&nbsp;&nbsp;pylayers.measures.vna.E5072A Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.parker.smparker">33&nbsp;&nbsp;&nbsp;pylayers.measures.parker.smparker Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.bsignal">34&nbsp;&nbsp;&nbsp;pylayers.signal.bsignal Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.standard">35&nbsp;&nbsp;&nbsp;pylayers.signal.standard Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.device">36&nbsp;&nbsp;&nbsp;pylayers.signal.device Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.DF">37&nbsp;&nbsp;&nbsp;pylayers.signal.DF Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.waveform">38&nbsp;&nbsp;&nbsp;pylayers.signal.waveform Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.agent">39&nbsp;&nbsp;&nbsp;pylayers.mobility.agent Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.ban.body">40&nbsp;&nbsp;&nbsp;pylayers.mobility.ban.body Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id138">41&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pylayers.antprop.spharm</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.antprop.spharm</h1><div class="highlight"><pre>
<span></span># -*- coding:Utf-8 -*-
&quot;&quot;&quot;
.. currentmodule:: pylayers.antprop.spharm

.. autosummary::
    :members:

&quot;&quot;&quot;
from __future__ import print_function
import doctest
import os
import glob
import doctest
import subprocess
import os
import re
import sys
import pdb
import numpy as np
import scipy as sp
import scipy.special as special
from scipy import io
import matplotlib.pylab as plt
from scipy.misc import factorial
import pylayers.util.pyutil as pyu
from pylayers.util.project import *
from pylayers.util.plotutil import *
from matplotlib.font_manager import FontProperties
from mpl_toolkits.mplot3d import axes3d
from scipy import sparse
from matplotlib import rc
from matplotlib import cm

<div class="viewcode-block" id="indexssh"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.indexssh.html#pylayers.antprop.spharm.indexssh">[docs]</a>def indexssh(L,mirror=True):
    &quot;&quot;&quot; create [l,m] indexation from Lmax

    Parameters
    ----------

    L : maximum order
    mirror : boolean
        if True the output contains negative m indices

    Returns
    -------

    t : np.array
        [l,m]   Ncoeff x 2

    Examples
    --------

        &gt;&gt;&gt; from pylayers.antprop.spharm import *
        &gt;&gt;&gt; indexssh(2)
        array([[ 0.,  0.],
               [ 1.,  0.],
               [ 2.,  0.],
               [ 1.,  1.],
               [ 2.,  1.],
               [ 2.,  2.],
               [ 1., -1.],
               [ 2., -1.],
               [ 2., -2.]])

    &quot;&quot;&quot;

    for k in range(L+1):
        l = np.arange(k,L+1)
        m = k*np.ones(L+1-k)
        v = np.vstack((l,m)).T
        try:
            t = np.vstack((t,v))
        except:
            t = v

    if mirror:
        u =  t[L+1:,:]
        v =  np.vstack((u[:,0],-u[:,1])).T
        #v = v[::-1,:]
        t = np.vstack((t,v))

    return t</div>

<div class="viewcode-block" id="indexvsh"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.indexvsh.html#pylayers.antprop.spharm.indexvsh">[docs]</a>def indexvsh(L):
    &quot;&quot;&quot; calculate index of vsh

    Parameters
    ----------
    L : int
      degree max


    Returns
    -------

    t : ndarray ( (L+1)(L+2)/2 ,  2 )
       tab for indexing the upper triangle

    Examples
    --------

    &gt;&gt;&gt; from pylayers.antprop.antenna import *
    &gt;&gt;&gt; indexvsh(3)
    array([[1, 0],
           [1, 1],
           [2, 0],
           [2, 1],
           [2, 2],
           [3, 0],
           [3, 1],
           [3, 2],
           [3, 3]])

    &quot;&quot;&quot;
    Kmax = (L + 1) * (L + 2) / 2
    k = np.arange(1,Kmax)
    l = np.ceil((-1 + np.sqrt(1 + 8 * (k + 1))) / 2) - 1
    m = k - l * (l + 1) / 2
    u = np.vstack((l, m)).T
    t = u.astype(int)
    return(t)</div>

<div class="viewcode-block" id="index_vsh"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.index_vsh.html#pylayers.antprop.spharm.index_vsh">[docs]</a>def index_vsh(L, M):
    &quot;&quot;&quot; vector spherical harmonics indexing

    Parameters
    ----------

    L : int
        degree max   sum(1..L)   L points
    M : int
        order max    sum(0..M)   M+1 points

    M &lt;=L

    ind[0] = n
    ind[1] = m

    Notes
    -----

    This function is more generic than indexvsh because it allows to have M&lt;&gt;L

    See Also
    --------

    indexvsh

    &quot;&quot;&quot;
    if M &gt; L:
        print(&quot;indexvsh error M&gt;L&quot;)

    Kmax1 = (M + 1) * (M + 2) / 2
    #k = np.arange(Kmax1)
    k = np.arange(1,Kmax1)
    l = np.ceil((-1 + np.sqrt(1 + 8 * (k + 1))) / 2) - 1
    m = k - l * (l + 1) / 2
    if (M &lt; L):
        l1 = np.outer(np.arange(L - M) + M + 1, np.ones(M + 1)).ravel()
        m1 = np.outer(np.ones(L - M), np.arange(M + 1)).ravel()
        l = np.hstack((l, l1))
        m = np.hstack((m, m1))

    u = np.vstack((l, m)).T
    t = u.astype(int)
    return(t)</div>

<div class="viewcode-block" id="VectorCoeff"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VectorCoeff.html#pylayers.antprop.spharm.VectorCoeff">[docs]</a>class VectorCoeff(PyLayers):
    &quot;&quot;&quot;  class vector spherical harmonics


    &quot;&quot;&quot;
    def __init__(self,
                 typ,
                 fmin=0.6,
                 fmax=6,
                 data=np.array([]),
                 ind=np.array([]) ):
        &quot;&quot;&quot;  class constructor

        Parameters
        ----------

        typ : string
        fmin : float
            min frequency GHz
        fmax : float
            max frequency GHz
        data : np.array
        ind : np.array

        &quot;&quot;&quot;

        self.s1 = np.array([])
        self.s3 = np.array([])
        self.s4 = np.array([])

        self.fmin = fmin
        self.fmax = fmax

        if typ == &#39;s1&#39;:
            self.inits1(data,ind)

<div class="viewcode-block" id="VectorCoeff.inits1"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VectorCoeff.html#pylayers.antprop.spharm.VectorCoeff.inits1">[docs]</a>    def inits1(self, data, ind):
        &quot;&quot;&quot; init shape 1

        Parameters
        ----------

        data :
        ind :

        &quot;&quot;&quot;
        sh = np.shape(data)
        self.s1 = data
        self.ind_s1 = ind
        self.Nf = sh[0]</div></div>

<div class="viewcode-block" id="SSHCoeff"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SSHCoeff.html#pylayers.antprop.spharm.SSHCoeff">[docs]</a>class SSHCoeff(PyLayers):
    &quot;&quot;&quot; scalar spherical harmonics

    Attributes
    ----------

    Cx : coefficient for x axis
    Cy : coefficient for y axis
    Cz : coefficient for z axis

    &quot;&quot;&quot;
    def __init__(self, Cx,Cy,Cz):
        &quot;&quot;&quot; class constructor

        Parameters
        ----------

        Cx : SCoeff
        Cy : SCoeff
        Cz : SCoeff

        &quot;&quot;&quot;

        self.Cx = Cx
        self.Cy = Cy
        self.Cz = Cz


    def __repr__(self):
        st = &#39;SSH Coeff \n&#39;
        st = st + &#39;------------------\n&#39;
        st = st + self.Cx.__repr__()
        st = st + self.Cy.__repr__()
        st = st + self.Cz.__repr__()
        return(st)

<div class="viewcode-block" id="SSHCoeff.s2tos3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SSHCoeff.html#pylayers.antprop.spharm.SSHCoeff.s2tos3">[docs]</a>    def s2tos3(self, threshold=-1):
        &quot;&quot;&quot; convert scalar spherical coefficients from shape 2 to shape 3

        Parameters
        ----------

        threshold : float
            default (-1)

        Notes
        -----

        s3 corresponds to energy thresholded coefficients

        &quot;&quot;&quot;

        if threshold!=-1:
            # integrates energy over frequency axis = 0
            Ex = np.sum(np.abs(self.Cx.s2) ** 2, axis=0)
            Ey = np.sum(np.abs(self.Cy.s2) ** 2, axis=0)
            Ez = np.sum(np.abs(self.Cz.s2) ** 2, axis=0)

            # calculates total Energy
            E = Ex + Ey + Ez

            ind = np.nonzero(E &gt; (E.max() * threshold))[0]

            self.Cx.ind3 = self.Cx.ind2[ind]
            self.Cx.s3 = self.Cx.s2[:, ind]
            self.Cx.k2 = ind

            self.Cy.ind3 = self.Cy.ind2[ind]
            self.Cy.s3 = self.Cy.s2[:, ind]
            self.Cy.k2 = ind

            self.Cz.ind3 = self.Cz.ind2[ind]
            self.Cz.s3 = self.Cz.s2[:, ind]
            self.Cz.k2 = ind
        else:
            self.Cx.ind3 = self.Cx.ind2
            self.Cx.s3 = self.Cx.s2
            self.Cx.k2 = np.arange(0,self.Cx.ind2.shape[0])

            self.Cy.ind3 = self.Cy.ind2
            self.Cy.s3 = self.Cy.s2
            self.Cy.k2 = np.arange(0,self.Cy.ind2.shape[0])

            self.Cz.ind3 = self.Cz.ind2
            self.Cz.s3 = self.Cz.s2
            self.Cz.k2 = np.arange(0,self.Cz.ind2.shape[0])</div>

<div class="viewcode-block" id="SSHCoeff.sets3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SSHCoeff.html#pylayers.antprop.spharm.SSHCoeff.sets3">[docs]</a>    def sets3(self,Cx,Cy,Cz):
        &quot;&quot;&quot; set shape 3

        Parameters
        ----------

        Cx : SCoeff
        Cy : SCoeff
        Cz : SCoeff

        &quot;&quot;&quot;

        self.Cx.ind3 = Cx.ind3
        self.Cx.s3 = Cx.s3
        self.Cx.k2 = Cx.k2

        self.Cy.ind3 = Cy.ind3
        self.Cy.s3 = Cy.s3
        self.Cy.k2 = Cy.k2

        self.Cz.ind3 = Cz.ind3
        self.Cz.s3 = Cz.s3
        self.Cz.k2 = Cz.k2</div></div>


<div class="viewcode-block" id="SCoeff"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SCoeff.html#pylayers.antprop.spharm.SCoeff">[docs]</a>class SCoeff(PyLayers):
    &quot;&quot;&quot; scalar Spherical Harmonics coefficients

    d = np.array [Nf,N+1,M+1]

    Attributes
    ----------

    s2  shape 2   np.array [ Nf x (N+1)*(M+1)   ]
    s3  shape 3   np.array [ Nf x K     ]
    ind [ K x 2]

    &quot;&quot;&quot;

    def __init__(self, typ=&#39;s2&#39;, fmin=0.6, fmax=6,lmax=20,  data=np.array([]),
                 ind=np.array([]), k=np.array([])):
        &quot;&quot;&quot; init VCoeff

         Parameters
         ----------

         typ : string
            &#39;s2&#39; | &#39;s3&#39;
         fmin : float
         fmax : float
         data : ndarray
         ind  : ndarray
         k    : ndarray

         Notes
         -----
         s2 , s3 containers are created

        &quot;&quot;&quot;

        #~ defaults = { &#39;typ&#39;: &#39;s2&#39;,
                    #~ &#39;fmin&#39; : 0.6,
                    #~ &#39;fmax&#39; : 6,
                    #~ &#39;lmax&#39; : 20,
                    #~ &#39;data&#39; : [],
                    #~ &#39;ind&#39; : [],
                    #~ &#39;k&#39;   : [] }
#~
        #~ for key, value in defaults.items():
            #~ if key not in kwargs:
                #~ kwargs[key] = value

        self.fmin = fmin
        self.fmax = fmax
        self.lmax = lmax

        if typ == &#39;s2&#39;:
            self.s2 = np.array([])
            self.inits2(data,ind)
        if typ == &#39;s3&#39;:
            self.s3 = np.array([])
            self.inits3(data, ind, k)

    def __repr__(self):

        st = &quot;Nf   : &quot; +  str(self.Nf) + &quot;\n&quot;
        st = st +  &quot;fmin (GHz) : &quot;+  str(self.fmin) + &quot;\n&quot;
        st = st +  &quot;fmax (GHz) : &quot;+  str(self.fmax) + &quot;\n&quot;

        if &#39;s2&#39; in self.__dict__.keys():
            sh2 = np.shape(self.s2)
            if sh2[0] != 0:
                st = st + &quot;NCoeff s2  : &quot; + str(len(self.ind2))+ &quot;\n&quot;

        if &#39;s3&#39; in self.__dict__.keys():
            sh3 = np.shape(self.s3)
            if sh3[0] != 0:
                st = st + &quot;Ncoeff s3 : &quot; + str(len(self.ind3))+ &quot;\n&quot;

        return(st)

<div class="viewcode-block" id="SCoeff.inits2"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SCoeff.html#pylayers.antprop.spharm.SCoeff.inits2">[docs]</a>    def inits2(self, data, ind):
        &quot;&quot;&quot; initialize shape 2 format

        Parameters
        ----------

        data : shape 2 data
        ind  : np.array
            index for shape 2

        &quot;&quot;&quot;

        sh = np.shape(data)
        # first axis is frequency
        self.Nf = sh[0]

        # second axis is the maximum number of coeff
        self.s2 = data

        #self.ind2 = indexssh(lmax)
        self.ind2 = ind</div>

<div class="viewcode-block" id="SCoeff.inits3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SCoeff.html#pylayers.antprop.spharm.SCoeff.inits3">[docs]</a>    def inits3(self, data, ind, k):
        &quot;&quot;&quot; initialize shape 3 format

        Parameters
        ----------

        data  : shape 3 data
        ind   : shape 3 indexing
        k     : k

        &quot;&quot;&quot;

        sh = np.shape(data)
        self.Nf = sh[0]
        self.s3 = data
        self.ind3 = ind
        self.k2 = k</div>

<div class="viewcode-block" id="SCoeff.delete"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SCoeff.html#pylayers.antprop.spharm.SCoeff.delete">[docs]</a>    def delete(self, ind, typ):
        &quot;&quot;&quot; delete coeff

        Parameters
        ----------

        ind   : int
        typ   : int
                2  shape 2  (Nf , N*M   )
                3  shape 3  (Nf , K )  T ( K x 2 )
        &quot;&quot;&quot;

        if typ == 2:
            ind2 = self.ind2[ind]
            s2 = self.s2[:, ind]

            a = delete(self.ind2, ind, axis=0)
            b = delete(self.s2, ind, axis=1)
            self.ind2 = a
            self.s2 = b

        if typ == 3:

            ind3 = self.ind3[ind]
            k2 = self.k2[ind]
            s3 = self.s3[:, ind]

            a = delete(self.ind3, ind, axis=0)
            b = delete(self.k2, ind)
            c = delete(self.s3, ind, axis=1)

            self.ind3 = a
            self.k2 = b
            self.s3 = c</div>

<div class="viewcode-block" id="SCoeff.put"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SCoeff.html#pylayers.antprop.spharm.SCoeff.put">[docs]</a>    def put(self, typ):
        &quot;&quot;&quot; recover last deleted coeff

        Parameters
        ----------

        typ : int
                2 : shape 2  (Nf , N*M   )
                3 : shape 3  (Nf , K )  T ( K x 2 )
        &quot;&quot;&quot;

        if typ == 2:

            file_ind = pyu.getlong(&quot;outfile_i2.txt&quot;, pstruc[&#39;DIRANT&#39;])
            aux = load(file_ind)
            ind = aux[0]
            ind2 = np.array([aux[1], aux[2]])

            file_s2 = pyu.getlong(&quot;outfile_s2.txt&quot;, pstruc[&#39;DIRANT&#39;])
            s2 = load(file_s2)

            self.s2p = s2

            a = insert(self.ind2, ind, ind2, axis=0)
            b = insert(self.s2, ind, s2, axis=1)

            self.ind2 = a
            self.s2 = b

        if typ == 3:

            file_ind = pyu.getlong(&quot;outfile_i3.txt&quot;, pstruc[&#39;DIRANT&#39;])
            aux = load(file_ind)
            ind = aux[0]
            ind3 = np.array([aux[1], aux[2]])
            k2 = aux[3]

            file_s3 = pyu.getlong(&quot;outfile_s3.txt&quot;, pstruc[&#39;DIRANT&#39;])
            s3 = load(file_s3)

            a = insert(self.ind3, ind, ind3, axis=0)
            b = insert(self.k2, ind, k2)
            c = insert(self.s3, ind, s3[0], axis=1)

            self.ind3 = a
            self.k2 = b
            self.s3 = c

            os.remove(file_ind)
            os.remove(file_s3)</div>

<div class="viewcode-block" id="SCoeff.delete3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SCoeff.html#pylayers.antprop.spharm.SCoeff.delete3">[docs]</a>    def delete3(self, ind):
        &quot;&quot;&quot; delete coeff.s3

        Parameters
        ----------

        ind : int

        &quot;&quot;&quot;
        a = delete(self.ind3, ind, axis=0)
        b = delete(self.k2, ind)
        c = delete(self.s3, ind, axis=1)
        self.ind3 = a
        self.k2 = b
        self.s3 = c</div>

<div class="viewcode-block" id="SCoeff.put3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SCoeff.html#pylayers.antprop.spharm.SCoeff.put3">[docs]</a>    def put3(self, i, i3):
        &quot;&quot;&quot; function put3

        Parameters
        ----------
        i  : int
        i3 : int

        &quot;&quot;&quot;

        k2 = i3[0] * (i3[0] + 1) / 2 + i3[1]
        ind3 = self.ind2[k2]
        s3 = self.s2[:, k2]

        a = insert(self.ind3, i, ind3, axis=0)
        b = insert(self.k2, i, k2)
        c = insert(self.s3, i, s3, axis=1)

        self.ind3 = a
        self.k2 = b
        self.s3 = c</div>

<div class="viewcode-block" id="SCoeff.s3tos2"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SCoeff.html#pylayers.antprop.spharm.SCoeff.s3tos2">[docs]</a>    def s3tos2(self):
        &quot;&quot;&quot; transform shape3 to shape 2

        s2  shape 2   array [ Nf x (L+1)*(M+1) ]
        s3  shape 3   array [ Nf x K     ] ind [ K x 2]

        Notes
        -----

        The shape of s2 is (Lmax+1)*(Lmax+2)/2

        k2  : is the list of conserved indices in shape 3
        ind3 : np.array (K3, 2) are the conserved (l,m) indices

        ind3 and k2 have one common dimension

        &quot;&quot;&quot;
        # retrieve Nf and Lmax to build a void s2 structure
        Nf   = np.shape(self.s3)[0]
        Lmax = max(self.ind3[:,0])
        # -1 added due to an extra last element otherwise
        # K2   = (Lmax+1)*(Lmax+2)/2
        K2   = (Lmax+1)*(Lmax+2)/2 -1
        self.s2 = np.zeros((Nf,K2),dtype=complex)
        # fill s2 with s3 at proper coefficient location
        self.s2[:,self.k2] = self.s3
        self.L2 = Lmax
        self.M2 = Lmax
        self.ind2 = indexvsh(Lmax)</div>



    # def s2tos1(self):
    #     &quot;&quot;&quot; transform shape2 to shape 1

    #     s2  shape 2   array [ Nf x (L+1)*(M+1) ]
    #     s1  shape 1   array [ Nf , (L+1) , (M+1) ]

    #     &quot;&quot;&quot;
    #     Nf   = np.shape(self.s2)[0]
    #     Lmax = max(self.ind2[:,0])
    #     self.s1 = np.zeros((Nf,Lmax+1,Lmax+1),dtype=complex)
    #     self.s1[:,self.ind2[:,0],self.ind2[:,1]]=self.s2


<div class="viewcode-block" id="SCoeff.plot"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SCoeff.html#pylayers.antprop.spharm.SCoeff.plot">[docs]</a>    def plot(self,typ=&#39;s3&#39;,title=&#39;&#39;,xl=False,yl=False,log=False,stem=True,color=&#39;b&#39;):
        &quot;&quot;&quot; plot coeff

        Parameters
        ----------

        typ : string
            &#39;s3&#39;
        title
        xl
        yl
        log
        stem: boolean
        color
        &quot;&quot;&quot;
        if typ==&#39;s3&#39;:
            indices = self.ind3
            tl = indices[:,0]
            C =[]
            for l in np.unique(tl):
                k = np.where(tl==l)
                a = np.real(np.sum(self.s3[:,k]*np.conj(self.s3[:,k])))
                C.append(a)
            C = np.real(np.array(C))
            Cs = np.sqrt(C)
            if log:
                Cs = 20*log10(Cs)
            if stem:
                plt.stem(np.unique(tl),Cs,markerfmt=color+&#39;o&#39;)
            else:
                plt.plot(np.unique(tl),Cs,color=color)
            #plt.axis([0,max(tl),0,5])
            plt.title(title)
            if xl:
                plt.xlabel(&#39;degree l&#39;)
            if yl:
                plt.ylabel(&#39;Integrated Module of coeff&#39;)</div>

<div class="viewcode-block" id="SCoeff.show"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.SCoeff.html#pylayers.antprop.spharm.SCoeff.show">[docs]</a>    def show(self,
             typ=&#39;s1&#39;,
             k = 0,
             L = -1,
             M = -1,
             kmax = 1000,
             seuildb = 50,
             titre = &#39;SHC&#39;,
             xl = True,
             yl = True,
             fontsize=14,
             dB = True,
             cmap = plt.cm.hot_r,
             anim = True):
        &quot;&quot;&quot; show coeff

        Parameters
        ----------

        typ :  string
            default (&#39;s1&#39;)
            &#39;s1&#39;  shape 1  (Nf , L , M )
            &#39;s2&#39;  shape 2  (Nf , L*M )
            &#39;s3&#39;  shape 3  (Nf , K )  and  ( K x 2 )

        k  : integer
            frequency index default 0

        N, M = maximal value for degree, mode respectively
        (not to be defined if &#39;s2&#39; or &#39;s3&#39;)

        &quot;&quot;&quot;

        fa = np.linspace(self.fmin, self.fmax, self.Nf)
        if typ == &#39;s1&#39;:
            if L == -1:
                L = self.L1
            if M == -1:
                M = self.M1
            Mg, Ng = np.meshgrid(np.arange(M), np.arange(L))
            if anim:
                fig = plt.gcf()
                ax = fig.gca()
                v = np.abs(self.s1[k, 0:N, 0:M])
                if dB:
                    v = 20 * np.log10(v)
                p = plt.scatter(Mg, Ng, c=v, s=30, cmap=cmap,
                            linewidth=0, vmin=-seuildb, vmax=0)
                cb = plt.colorbar()
                cb.set_label(&#39;Level dB&#39;)
                plt.draw()
            else:
                v = np.abs(self.s1[k, 0:N, 0:M])
                if dB:
                    vdB = 20 * np.log10(v + 1e-15)
                    plt.scatter(Mg, Ng, c=vdB, s=30, cmap=cmap, linewidth=0,
                                vmin=-seuildb, vmax=0)
                    plt.title(titre)
                    cb = plt.colorbar()
                    cb.set_label(&#39;Level dB&#39;)
                else:
                    plt.scatter(Mg, Ng, c=v, s=30, cmap=cmap, linewidth=0)
                    plt.title(titre)
                    cb = plt.colorbar()
                    cb.set_label(&#39;Level (linear scale)&#39;)

                if xl:
                    plt.xlabel(&#39;m&#39;, fontsize=fontsize)
                if yl:
                    plt.ylabel(&#39;n&#39;, fontsize=fontsize)

        if typ == &#39;s2&#39;:
            if np.shape(self.s2)[1] &lt;= 1:
                plt.plot(fa, 10 * np.log10(abs(self.s2[:, 0])))
            else:
                K = np.shape(self.s2)[1]
            kmax = min(kmax,K)
            db = 20 * np.log10(abs(self.s2[:, 0:kmax] + 1e-15))
            col = 1 - (db &gt; -seuildb) * (db + seuildb) / seuildb
            #
            #gray
            #
            #pcolor(np.arange(K+1)[0:kmax],self.fa,col,cmap=cm.gray_r,vmin=0.0,vmax=1.0)
            #
            #color
            #
            plt.pcolor(np.arange(K + 1)[0:kmax], fa, col, cmap=plt.cm.hot, vmin=0.0, vmax=1.0)
            if xl:
                plt.xlabel(&#39;index&#39;, fontsize=fontsize)
            if yl:
                plt.ylabel(&#39;Frequency (GHz)&#39;, fontsize=fontsize)

        if typ == &#39;s3&#39;:
            if np.shape(self.s3)[1] &lt;= 1:
                plt.plot(fa, 10 * np.log10(abs(self.s3[:, 0])))
            else:
                K = np.shape(self.s3)[1]

            kmax = min(kmax,K)
            db = 20 * np.log10(abs(self.s3[:, 0:kmax] + 1e-15))
            col = 1 - (db &gt; -seuildb) * (db + seuildb) / seuildb
            plt.pcolor(np.arange(K + 1)[0:kmax], fa, col,
                   cmap=plt.cm.hot, vmin=0.0, vmax=1.0)
            if xl:
                plt.xlabel(&#39;index&#39;, fontsize=fontsize)
            if yl:
                plt.ylabel(&#39;Frequency (GHz)&#39;, fontsize=fontsize)

                #echelle=[str(0), str(-10), str(-20), str(-30), str(-40), str(-50)]
        if (typ == &#39;s2&#39;) | (typ ==&#39;s3&#39;) :

            echelle = [str(0), str(-seuildb + 40), str(-seuildb + 30),
                       str(-seuildb + 20), str(-seuildb + 10), str(-seuildb)]
            cbar = plt.colorbar(ticks=[0, 0.2, 0.4, 0.6, 0.8, 1])
            cbar.ax.set_yticklabels(echelle)
            cbar.ax.set_ylim(1, 0)
            for t in cbar.ax.get_yticklabels():
                t.set_fontsize(fontsize)
            plt.xticks(fontsize=fontsize)
            plt.yticks(fontsize=fontsize)
            plt.title(titre, fontsize=fontsize + 2)</div></div>

<div class="viewcode-block" id="VCoeff"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff">[docs]</a>class VCoeff(object):
    &quot;&quot;&quot; Spherical Harmonics Coefficient

    d = np.array [Nf,N+1,M+1]

    Attributes
    ----------

    s1  shape 1   np.array [ Nf x (N+1) x (M+1) ]
    s2  shape 2   np.array [ Nf x (N+1)*(M+1)   ]
    s3  shape 3   np.array [ Nf x K     ]
    ind [ K x 2]

    &quot;&quot;&quot;

    def __init__(self, typ, fmin=0.6, fmax=6, data=np.array([]),
                 ind=np.array([]), k=np.array([])):
        &quot;&quot;&quot; init VCoeff

         Parameters
         ----------
         typ : string
            &#39;s1&#39; | &#39;s2&#39; | &#39;s3&#39;
         fmin : float
         fmax : float
         data : ndarray
         ind  : ndarray
         k    : ndarray

         s1, s2 , s3 containers are created
        &quot;&quot;&quot;

        self.s1 = np.array([])
        self.s2 = np.array([])
        self.s3 = np.array([])
        self.fmin = fmin
        self.fmax = fmax
        if typ == &#39;s1&#39;:
            self.inits1(data)
        if typ == &#39;s2&#39;:
            self.inits2(data)
        if typ == &#39;s3&#39;:
            self.inits3(data, ind, k)

    def __repr__(self):

        st = &quot;Nf   : &quot; +  str(self.Nf) + &quot;\n&quot;
        st = st +  &quot;fmin (GHz) : &quot;+  str(self.fmin) + &quot;\n&quot;
        st = st +  &quot;fmax (GHz) : &quot;+  str(self.fmax) + &quot;\n&quot;

        sh1 = np.shape(self.s1)
        sh2 = np.shape(self.s2)
        sh3 = np.shape(self.s3)

        if sh1[0] != 0:
            st =  &quot;L1  : &quot; + str(self.L1) + &quot;\n&quot;
            st = st + &quot;M1  : &quot; + str(self.M1)+ &quot;\n&quot;
            st = st + &quot;Ncoeff s1 &quot; + str(self.M1* self.L1)+ &quot;\n&quot;
        if sh2[0] != 0:
            st = st + &quot;NCoeff s2  : &quot; + str(len(self.ind2))+ &quot;\n&quot;
        if sh3[0] != 0:
            st = st + &quot;Ncoeff s3 : &quot; + str(len(self.ind3))+ &quot;\n&quot;

        return(st)

<div class="viewcode-block" id="VCoeff.inits1"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff.inits1">[docs]</a>    def inits1(self, data):
        &quot;&quot;&quot; initialize shape 1 format

        Parameters
        ----------
        data  : shape 1 data

        &quot;&quot;&quot;
        sh = np.shape(data)
        L = sh[1] - 1
        M = sh[2] - 1
        if M &gt; L:
            print(&#39;VCoeff : M&gt;N &#39;)
            exit()
        else:
            self.s1 = data
            self.L1 = L
            self.M1 = M
        self.Nf = sh[0]</div>

<div class="viewcode-block" id="VCoeff.inits2"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff.inits2">[docs]</a>    def inits2(self, data):
        &quot;&quot;&quot; initialize shape 2 format

        Parameters
        ----------
         data : shape 2 data

        &quot;&quot;&quot;
        sh = np.shape(data)
        self.Nf = sh[0]
        kmax = sh[1]
        nmax = np.ceil((-1 + np.sqrt(1 + 8 * (kmax + 1))) / 2) - 1
        t = indexvsh(nmax)
        L2 = t[:, 0].max() - 1
        M2 = t[:, 1].max() - 1
        self.s2 = data
        self.L2 = L2
        self.M2 = M2
        self.ind2 = index_vsh(L2, M2)</div>

<div class="viewcode-block" id="VCoeff.inits3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff.inits3">[docs]</a>    def inits3(self, data, ind, k):
        &quot;&quot;&quot; initialize shape 3 format

        Parameters
        ----------
         data  : shape 3 data
         ind   : ishape 3 indexing
         k     : k

        &quot;&quot;&quot;
        sh = np.shape(data)
        self.Nf = sh[0]
        self.s3 = data
        self.ind3 = ind
        self.k2 = k</div>

<div class="viewcode-block" id="VCoeff.s1tos2"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff.s1tos2">[docs]</a>    def s1tos2(self, L2=-1):
        &quot;&quot;&quot; convert shape 1 --&gt; shape 2

        shape 1   array [ Nf , (L+1) , (M+1) ]
        shape 2   array [ Nf , (L+1) * (M+1) ]

        l = 0...L2
        m = 0...M2

        Parameters
        ----------

        L2 : int &lt;= L1
            shape 1 has 3 axis - shape 2 has 2 axis
            by default all s1 coefficients are kept L2=-1 means L2=min(L1,M1) because M2 must be equal to L2

        See Also
        --------

        index_vsh

        &quot;&quot;&quot;

        if L2 == -1:
            L2 = min(self.L1, self.M1)
        M2 = L2
        if (L2 &lt;= self.L1):
            self.L2 = L2
            self.M2 = M2
            self.ind2 = index_vsh(L2, M2)
            self.s2 = self.s1[:, self.ind2[:, 0], self.ind2[:, 1]]
        else:
            print(&#39;error VCoeff s1tos2: L2&gt;L1&#39;)</div>

<div class="viewcode-block" id="VCoeff.delete"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff.delete">[docs]</a>    def delete(self, ind, typ):
        &quot;&quot;&quot; delete coeff

        Parameters
        ----------

        ind   : int
        typ   : int
                2  shape 2  (Nf , N*M   )
                3  shape 3  (Nf , K )  T ( K x 2 )
        &quot;&quot;&quot;

        if typ == 2:
            ind2 = self.ind2[ind]
            s2 = self.s2[:, ind]

            a = delete(self.ind2, ind, axis=0)
            b = delete(self.s2, ind, axis=1)
            self.ind2 = a
            self.s2 = b

        if typ == 3:

            ind3 = self.ind3[ind]
            k2 = self.k2[ind]
            s3 = self.s3[:, ind]

            a = delete(self.ind3, ind, axis=0)
            b = delete(self.k2, ind)
            c = delete(self.s3, ind, axis=1)
            self.ind3 = a
            self.k2 = b
            self.s3 = c</div>

<div class="viewcode-block" id="VCoeff.put"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff.put">[docs]</a>    def put(self, typ):
        &quot;&quot;&quot; recover last deleted coeff

        Parameters
        ----------
        typ : int
                2 : shape 2  (Nf , N*M   )
                3 : shape 3  (Nf , K )  T ( K x 2 )
        &quot;&quot;&quot;

        if typ == 2:

            file_ind = pyu.getlong(&quot;outfile_i2.txt&quot;, pstruc[&#39;DIRANT&#39;])
            aux = load(file_ind)
            ind = aux[0]
            ind2 = np.array([aux[1], aux[2]])

            file_s2 = pyu.getlong(&quot;outfile_s2.txt&quot;, pstruc[&#39;DIRANT&#39;])
            s2 = load(file_s2)

            self.s2p = s2

            a = insert(self.ind2, ind, ind2, axis=0)
            b = insert(self.s2, ind, s2, axis=1)

            self.ind2 = a
            self.s2 = b

        if typ == 3:

            file_ind = pyu.getlong(&quot;outfile_i3.txt&quot;, pstruc[&#39;DIRANT&#39;])
            aux = load(file_ind)
            ind = aux[0]
            ind3 = np.array([aux[1], aux[2]])
            k2 = aux[3]

            file_s3 = pyu.getlong(&quot;outfile_s3.txt&quot;, pstruc[&#39;DIRANT&#39;])
            s3 = load(file_s3)

            a = insert(self.ind3, ind, ind3, axis=0)
            b = insert(self.k2, ind, k2)
            c = insert(self.s3, ind, s3[0], axis=1)

            self.ind3 = a
            self.k2 = b
            self.s3 = c

            os.remove(file_ind)
            os.remove(file_s3)</div>

<div class="viewcode-block" id="VCoeff.delete3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff.delete3">[docs]</a>    def delete3(self, ind):
        &quot;&quot;&quot; delete coeff.s3

        Parameters
        ----------

        ind : int

        &quot;&quot;&quot;
        a = delete(self.ind3, ind, axis=0)
        b = delete(self.k2, ind)
        c = delete(self.s3, ind, axis=1)
        self.ind3 = a
        self.k2 = b
        self.s3 = c</div>

<div class="viewcode-block" id="VCoeff.put3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff.put3">[docs]</a>    def put3(self, i, i3):
        &quot;&quot;&quot; function put 3

        Parameters
        ----------
        i  : int
        i3 : int

        &quot;&quot;&quot;

        k2 = i3[0] * (i3[0] + 1) / 2 + i3[1]
        ind3 = self.ind2[k2]
        s3 = self.s2[:, k2]

        a = insert(self.ind3, i, ind3, axis=0)
        b = insert(self.k2, i, k2)
        c = insert(self.s3, i, s3, axis=1)

        self.ind3 = a
        self.k2 = b
        self.s3 = c</div>

<div class="viewcode-block" id="VCoeff.s3tos2"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff.s3tos2">[docs]</a>    def s3tos2(self):
        &quot;&quot;&quot; transform shape3 to shape 2

        s2  shape 2   array [ Nf x (L+1)*(M+1) ]
        s3  shape 3   array [ Nf x K     ] ind [ K x 2]

        Notes
        -----

        The shape of s2 is (Lmax+1)*(Lmax+2)/2

        k2  : is the list of conserved indices in shape 3
        ind3 : np.array (K3, 2) are the conserved (l,m) indices 

        ind3 and k2 have one common dimension

        &quot;&quot;&quot;
        # retrieve Nf and Lmax to build a void s2 structure
        Nf   = np.shape(self.s3)[0]
        Lmax = max(self.ind3[:,0])
        # K2   = (Lmax+1)*(Lmax+2)/2
        # -1 added due to an extra last element otherwise
        K2   = (Lmax+1)*(Lmax+2)/2 
        self.s2 = np.zeros((Nf,K2),dtype=complex)
        # fill s2 with s3 at proper coefficient location
        self.s2[:,self.k2] = self.s3
        self.L2 = Lmax
        self.M2 = Lmax
        self.ind2 = indexvsh(Lmax)</div>

    # def s2tos1(self):
    #     &quot;&quot;&quot; transform shape2 to shape 1

    #     s2  shape 2   array [ Nf x (L+1)*(M+1) ]
    #     s1  shape 1   array [ Nf , (L+1) , (M+1) ]

    #     &quot;&quot;&quot;
    #     Nf   = np.shape(self.s2)[0]
    #     Lmax = max(self.ind2[:,0])
    #     self.s1 = np.zeros((Nf,Lmax+1,Lmax+1),dtype=complex)
    #     self.s1[:,self.ind2[:,0],self.ind2[:,1]]=self.s2

<div class="viewcode-block" id="VCoeff.plot"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff.plot">[docs]</a>    def plot(self,typ=&#39;s3&#39;,title=&#39;&#39;,xl=False,yl=False,log=False,stem=True,color=&#39;b&#39;):
        &quot;&quot;&quot;
        &quot;&quot;&quot;
        if typ==&#39;s3&#39;:
            indices = self.ind3
            tl = indices[:,0]
            C =[]
            for l in np.unique(tl):
                k = np.where(tl==l)
                a = np.real(np.sum(self.s3[:,k]*np.conj(self.s3[:,k])))
                C.append(a)
            C = np.real(np.array(C))
            Cs = np.sqrt(C)
            if log:
                Cs = 20*log10(Cs)
            if stem:
                plt.stem(np.unique(tl),Cs,markerfmt=color+&#39;o&#39;)
            else:
                plt.plot(np.unique(tl),Cs,color=color)
            #plt.axis([0,max(tl),0,5])
            plt.title(title)
            if xl:
                plt.xlabel(&#39;degree l&#39;)
            if yl:
                plt.ylabel(&#39;Integrated Module of coeff&#39;)</div>

<div class="viewcode-block" id="VCoeff.show"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VCoeff.html#pylayers.antprop.spharm.VCoeff.show">[docs]</a>    def show(self,
             typ=&#39;s1&#39;,
             k = 0,
             L = -1,
             M = -1,
             kmax = 1000,
             seuildb = 50,
             titre = &#39;SHC&#39;,
             xl = True,
             yl = True,
             fontsize=14,
             dB = True,
             cmap = plt.cm.hot_r,
             anim = True):
        &quot;&quot;&quot; show coeff

        Parameters
        ----------
        typ :  string
            default (&#39;s1&#39;)
            &#39;s1&#39;  shape 1  (Nf , N , M )
            &#39;s2&#39;  shape 2  (Nf , N*M   )
            &#39;s3&#39;  shape 3  (Nf , K )  T ( K x 2 )

        k  : integer
            frequency index default 0

        N, M = maximal value for degree, mode respectively
        (not to be defined if &#39;s2&#39; or &#39;s3&#39;)

        &quot;&quot;&quot;

        fa = np.linspace(self.fmin, self.fmax, self.Nf)
        if typ == &#39;s1&#39;:
            if L == -1:
                L = self.L1
            if M == -1:
                M = self.M1
            Mg, Ng = np.meshgrid(np.arange(M), np.arange(L))
            if anim:
                fig = plt.gcf()
                ax = fig.gca()
                v = np.abs(self.s1[k, 0:L, 0:M])
                if dB:
                    v = 20 * np.log10(v)
                p = plt.scatter(Mg, Ng, c=v, s=30, cmap=cmap,
                            linewidth=0, vmin=-seuildb, vmax=0)
                plt.colorbar()
                plt.draw()
            else:
                v = np.abs(self.s1[k, 0:L, 0:M])
                if dB:
                    vdB = 20 * np.log10(v + 1e-15)
                    plt.scatter(Mg, Ng, c=vdB, s=30, cmap=cmap, linewidth=0,
                                vmin=-seuildb, vmax=0)
                    plt.title(titre)
                    plt.colorbar()
                else:
                    plt.scatter(Mg, Ng, c=v, s=30, cmap=cmap, linewidth=0)
                    plt.title(titre)
                    plt.colorbar()

                if xl:
                    plt.xlabel(&#39;m&#39;, fontsize=fontsize)
                if yl:
                    plt.ylabel(&#39;n&#39;, fontsize=fontsize)

        if typ == &#39;s2&#39;:
            if np.shape(self.s2)[1] &lt;= 1:
                plt.plot(fa, 10 * np.log10(abs(self.s2[:, 0])))
            else:
                K = np.shape(self.s2)[1]
            
            kmax = min(kmax,K)
            db = 20 * np.log10(abs(self.s2[:, 0:kmax] + 1e-15))
            col = 1 - (db &gt; -seuildb) * (db + seuildb) / seuildb
            #
            #gray
            #
            #pcolor(np.arange(K+1)[0:kmax],self.fa,col,cmap=cm.gray_r,vmin=0.0,vmax=1.0)
            #
            #color
            #
            plt.pcolor(np.arange(K + 1)[0:kmax], fa, col, cmap=plt.cm.hot, vmin=0.0, vmax=1.0)
            if xl:
                plt.xlabel(&#39;index&#39;, fontsize=fontsize)
            if yl:
                plt.ylabel(&#39;Frequency (GHz)&#39;, fontsize=fontsize)

        if typ == &#39;s3&#39;:
            if np.shape(self.s3)[1] &lt;= 1:
                plt.plot(fa, 10 * np.log10(abs(self.s3[:, 0])))
            else:
                K = np.shape(self.s3)[1]

            kmax = min(kmax,K)
            db = 20 * np.log10(abs(self.s3[:, 0:kmax] + 1e-15))
            col = 1 - (db &gt; -seuildb) * (db + seuildb) / seuildb
            plt.pcolor(np.arange(K + 1)[0:kmax], fa, col,
                   cmap=plt.cm.hot, vmin=0.0, vmax=1.0)
            if xl:
                plt.xlabel(&#39;index&#39;, fontsize=fontsize)
            if yl:
                plt.ylabel(&#39;Frequency (GHz)&#39;, fontsize=fontsize)

                #echelle=[str(0), str(-10), str(-20), str(-30), str(-40), str(-50)]
        if (typ == &#39;s2&#39;) | (typ ==&#39;s3&#39;) :

            echelle = [str(0), str(-seuildb + 40), str(-seuildb + 30), 
                       str(-seuildb + 20), str(-seuildb + 10), str(-seuildb)]
            cbar = plt.colorbar(ticks=[0, 0.2, 0.4, 0.6, 0.8, 1])
            cbar.ax.set_yticklabels(echelle)
            cbar.ax.set_ylim(1, 0)
            for t in cbar.ax.get_yticklabels():
                t.set_fontsize(fontsize)
            plt.xticks(fontsize=fontsize)
            plt.yticks(fontsize=fontsize)
            plt.title(titre, fontsize=fontsize + 2)</div></div>

<div class="viewcode-block" id="VSHCoeff"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VSHCoeff.html#pylayers.antprop.spharm.VSHCoeff">[docs]</a>class VSHCoeff(object):
    &quot;&quot;&quot; Vector Spherical Harmonics Coefficients class

    &quot;&quot;&quot;
    def __init__(self, Br, Bi, Cr, Ci):
        &quot;&quot;&quot; Init  VSHCoeff

        Parameters
        ----------

        Br :
        Bi :
        Cr :
        Ci :

        &quot;&quot;&quot;

        self.Br = Br
        self.Bi = Bi
        self.Cr = Cr
        self.Ci = Ci

    def __repr__(self):
        &quot;&quot;&quot;
        &quot;&quot;&quot;
        st = &quot;Br&quot;+&#39;\n&#39;
        st = st + &quot;-------------&quot;+&#39;\n&#39;
        st = st + self.Br.__repr__()+&#39;\n&#39;
        st = st + &quot;Bi&quot;+&#39;\n&#39;
        st = st + &quot;-------------&quot;+&#39;\n&#39;
        st = st + self.Bi.__repr__()+&#39;\n&#39;
        st = st + &quot;Cr&quot;+&#39;\n&#39;
        st = st + &quot;-------------&quot;+&#39;\n&#39;
        st = st + self.Cr.__repr__()+&#39;\n&#39;
        st = st + &quot;Ci&quot;+&#39;\n&#39;
        st = st + &quot;-------------&quot;+&#39;\n&#39;
        st = st + self.Ci.__repr__()
        return(st)

<div class="viewcode-block" id="VSHCoeff.plot"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VSHCoeff.html#pylayers.antprop.spharm.VSHCoeff.plot">[docs]</a>    def plot(self, typ=&#39;s3&#39;, titre=&#39;titre&#39;, log=False, stem=True, subp=True):
        &quot;&quot;&quot; plot coeff

        Parameters
        ----------

        typ
        titre
        log
        stem
        subp

        &quot;&quot;&quot;
        fa = np.linspace(self.Br.fmin,self.Br.fmax,self.Br.Nf)
        st = titre+&#39;  shape : &#39;+typ
        plt.suptitle(st,fontsize=14)
        if subp:
            plt.subplot(221)
            titre = &#39;$\sum_f \sum_m |Br_{l}^{(m)}(f)|$&#39;
            self.Br.plot(typ=typ,title=titre, yl=True,color=&#39;r&#39;,stem=stem,log=log)
        else:
            self.Br.plot(typ=typ,color=&#39;r&#39;,stem=stem,log=log)
        if subp:
            plt.subplot(222)
            titre = &#39;$\sum_f \sum_m |Bi_{l}^{(m)}(f)|$&#39;
            self.Bi.plot(typ=typ,title=titrei,color=&#39;m&#39;,stem=stem,log=log)
        else:
            self.Bi.plot(typ=typ,color=&#39;m&#39;,stem=stem,log=log)
        if subp:
            plt.subplot(223)
            titre = &#39;$\sum_f \sum_m |Cr_{l}^{(m)}(f)|$&#39;
            self.Cr.plot(typ=typ,title=titre, xl=True, yl=True,color=&#39;b&#39;,stem=stem,log=log)
        else:
            self.Cr.plot(typ=typ,color=&#39;b&#39;,stem=stem,log=log)
        if subp:
            plt.subplot(224)
            titre = &#39;$\sum_f \sum_m |Ci_{l}^{(m)}(f)|$&#39;
            self.Ci.plot(typ=typ, title = titre, xl=True,color=&#39;c&#39;,stem=stem,log=log)
        else:
            self.Ci.plot(typ=typ,xl=True,yl=True,color=&#39;c&#39;,stem=stem,log=log)
        if not subp:
            plt.legend((&#39;$\sum_f \sum_m |Br_{l}^{(m)}(f)|$&#39;,
                        &#39;$\sum_f \sum_m |Bi_{l}^{(m)}(f)|$&#39;,
                        &#39;$\sum_f \sum_m |Cr_{l}^{(m)}(f)|$&#39;,
                        &#39;$\sum_f \sum_m |Ci_{l}^{(m)}(f)|$&#39;))</div>

<div class="viewcode-block" id="VSHCoeff.show"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VSHCoeff.html#pylayers.antprop.spharm.VSHCoeff.show">[docs]</a>    def show(self, typ=&#39;s1&#39;, k=1, N=-1, M=-1, kmax = 1000, seuildb=50,
             animate=False,title=&#39;&#39;):
        &quot;&quot;&quot; show VSH coeff

        Parameters
        ----------

        typ : str
            {&#39;s1&#39;,&#39;s2&#39;,&#39;s3&#39;}
        k  : int
            frequency index
        N  : int
        M  : int
        kmax : int
            maximum of the unfolded coefficient axes
        seuildB  : float
        animate : boolean
                default False
        title : string

        &quot;&quot;&quot;
        if not animate:
            fa = np.linspace(self.Br.fmin,self.Br.fmax,self.Br.Nf)
            st = title + &#39;  shape : &#39;+typ
            plt.suptitle(st,fontsize=14)
            plt.subplot(221)
            titre = &#39;$|Br_{n}^{(m)}|$&#39;
            self.Br.show(typ=typ,titre=titre, xl=False, yl=True)
            plt.subplot(222)
            titre = &#39;$|Bi_{n}^{(m)}|$&#39;
            self.Bi.show(typ=typ,titre=titre, xl=False, yl=False)
            plt.subplot(223)
            titre = &#39;$|Cr_{n}^{(m)}|$&#39;
            self.Cr.show(typ=typ,titre=titre, xl=True, yl=True)
            plt.subplot(224)
            titre = &#39;$|Ci_{n}^{(m)}|$&#39;
            self.Ci.show(typ=typ, titre = titre, xl=True, yl=False)
        else:
            for k in np.arange(self.Br.Nf):
                plt.subplot(221)
                titre = &#39;$|Br_{n}^{(m)}|$&#39;
                self.Br.show(typ, titre = titre, xl=False, yl=True)
                plt.subplot(222)
                titre = &#39;$|Bi_{n}^{(m)}|$&#39;
                self.Bi.show(typ, titre = titre, xl=False, yl=False)
                plt.subplot(223)
                titre = &#39;$|Cr_{n}^{(m)}|$&#39;
                self.Cr.show(typ, titre = titre , xl=True, yl=True)
                plt.subplot(224)
                titre = &#39;$|Ci_{n}^{(m)}|$&#39;
                self.Ci.show(typ, titre = titre , xl=True, yl=False)</div>
    #    show()

<div class="viewcode-block" id="VSHCoeff.s1tos2"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VSHCoeff.html#pylayers.antprop.spharm.VSHCoeff.s1tos2">[docs]</a>    def s1tos2(self, L2=-1):
        &quot;&quot;&quot; convert shape 1 to shape 2

        shape 1   array [ Nf x (L+1) x (M+1) ]
        shape 2   array [ Nf x (L+1)*(M+1)   ]

        Parameters
        ----------

        L2 : max level
            default (-1 means all values)

        &quot;&quot;&quot;
        self.Bi.s1tos2(L2)
        self.Br.s1tos2(L2)
        self.Ci.s1tos2(L2)
        self.Cr.s1tos2(L2)</div>

<div class="viewcode-block" id="VSHCoeff.s2tos3_new"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VSHCoeff.html#pylayers.antprop.spharm.VSHCoeff.s2tos3_new">[docs]</a>    def s2tos3_new(self, k):
        &quot;&quot;&quot; convert vector spherical coefficient from shape 2 to shape 3

        Parameters
        ----------

        k : number of coeff

        &quot;&quot;&quot;

        EBr = np.sum(np.abs(self.Br.s2) ** 2, axis=0)
        EBi = np.sum(np.abs(self.Bi.s2) ** 2, axis=0)
        ECr = np.sum(np.abs(self.Cr.s2) ** 2, axis=0)
        ECi = np.sum(np.abs(self.Ci.s2) ** 2, axis=0)

        E  = EBr + EBi + ECr + ECi

        ib = np.argsort(E)[::-1]

        print(self.Br.ind2[ib[k-1]])
        print(self.Cr.ind2[ib[k-1]])
        print(self.Ci.ind2[ib[k-1]])
        print(self.Bi.ind2[ib[k-1]])
        #ind = np.nonzero(E &gt; (E.max() * threshold))[0]
        self.Br.ind3 = self.Br.ind2[ib[range(k)]]
        self.Br.s3 = self.Br.s2[:, ib[range(k)]]
        self.Br.k2 = ib[range(k)]

        self.Bi.ind3 = self.Bi.ind2[ib[range(k)]]
        self.Bi.s3 = self.Bi.s2[:, ib[range(k)]]
        self.Bi.k2 = ib[range(k)]

        self.Cr.ind3 = self.Cr.ind2[ib[range(k)]]
        self.Cr.s3 = self.Cr.s2[:, ib[range(k)]]
        self.Cr.k2 = ib[range(k)]

        self.Ci.ind3 = self.Ci.ind2[ib[range(k)]]
        self.Ci.s3 = self.Ci.s2[:, ib[range(k)]]
        self.Ci.k2 = ib[range(k)]
        return E[ib[k-1]]</div>

<div class="viewcode-block" id="VSHCoeff.s2tos3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VSHCoeff.html#pylayers.antprop.spharm.VSHCoeff.s2tos3">[docs]</a>    def s2tos3(self, threshold=-1):
        &quot;&quot;&quot; convert vector spherical coefficients from shape 2 to shape 3

        Parameters
        ----------

        threshold : float
            default 1e-20

        Energy thresholded coefficients

        &quot;&quot;&quot;

        # integrates energy over frequency  axis = 0
        if threshold!=-1:
            EBr = np.sum(np.abs(self.Br.s2) ** 2, axis=0)
            EBi = np.sum(np.abs(self.Bi.s2) ** 2, axis=0)
            ECr = np.sum(np.abs(self.Cr.s2) ** 2, axis=0)
            ECi = np.sum(np.abs(self.Ci.s2) ** 2, axis=0)

            E = EBr + EBi + ECr + ECi

            ind = np.nonzero(E &gt; (E.max() * threshold))[0]

            self.Br.ind3 = self.Br.ind2[ind]
            self.Br.s3 = self.Br.s2[:, ind]
            self.Br.k2 = ind

            self.Bi.ind3 = self.Bi.ind2[ind]
            self.Bi.s3 = self.Bi.s2[:, ind]
            self.Bi.k2 = ind

            self.Cr.ind3 = self.Cr.ind2[ind]
            self.Cr.s3 = self.Cr.s2[:, ind]
            self.Cr.k2 = ind

            self.Ci.ind3 = self.Ci.ind2[ind]
            self.Ci.s3 = self.Ci.s2[:, ind]
            self.Ci.k2 = ind
        else:
            self.Br.ind3 = self.Br.ind2
            self.Br.s3 = self.Br.s2
            self.Br.k2 = np.arange(0,self.Br.ind2.shape[0])

            self.Bi.ind3 = self.Bi.ind2
            self.Bi.s3 = self.Bi.s2
            self.Bi.k2 = np.arange(0,self.Bi.ind2.shape[0])

            self.Cr.ind3 = self.Cr.ind2
            self.Cr.s3 = self.Cr.s2
            self.Cr.k2 = np.arange(0,self.Cr.ind2.shape[0])

            self.Ci.ind3 = self.Ci.ind2
            self.Ci.s3 = self.Ci.s2
            self.Ci.k2 = np.arange(0,self.Ci.ind2.shape[0])</div>

<div class="viewcode-block" id="VSHCoeff.s3tos2"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VSHCoeff.html#pylayers.antprop.spharm.VSHCoeff.s3tos2">[docs]</a>    def s3tos2(self):
        &quot;&quot;&quot; shape 3 to shape 2

        &quot;&quot;&quot;
        self.Br.s3tos2()
        self.Bi.s3tos2()
        self.Cr.s3tos2()
        self.Ci.s3tos2()</div>

    # def s2tos1(self):
    #     &quot;&quot;&quot; shape 2 to shape 1

    #     &quot;&quot;&quot;
    #     self.Br.s2tos1()
    #     self.Bi.s2tos1()
    #     self.Cr.s2tos1()
    #     self.Ci.s2tos1()

<div class="viewcode-block" id="VSHCoeff.strip3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VSHCoeff.html#pylayers.antprop.spharm.VSHCoeff.strip3">[docs]</a>    def strip3(self):
        &quot;&quot;&quot; Thresholded coefficient conversion

        The s3 minimum energy coefficient is deleted

        Returns
        -------

        ind : int
        ind3 : int

        &quot;&quot;&quot;
        EBr = sum(abs(self.Br.s3) ** 2, axis=0)
        EBi = sum(abs(self.Bi.s3) ** 2, axis=0)
        ECr = sum(abs(self.Cr.s3) ** 2, axis=0)
        ECi = sum(abs(self.Ci.s3) ** 2, axis=0)

        E = EBr + EBi + ECr + ECi

        Emin = min(E)
        ind  = find(E == Emin)
        ind3 = self.Br.ind3[ind]

        self.Br.delete3(ind)
        self.Bi.delete3(ind)
        self.Cr.delete3(ind)
        self.Ci.delete3(ind)

        return ind, ind3</div>

<div class="viewcode-block" id="VSHCoeff.energy"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VSHCoeff.html#pylayers.antprop.spharm.VSHCoeff.energy">[docs]</a>    def energy(self,typ=&#39;s1&#39;):
        &quot;&quot;&quot; returns aggregated energy over all coefficients

        Parameters
        ----------
        typ : string
            {&#39;s1&#39;|&#39;s2&#39;|&#39;s3&#39;}

        Returns
        -------

        E  : np.array in the same shape as typ
            s1 : (f,l,m)
            s2 : (f,l*m)
            s3 : (f,ncoeff&lt;lm)

        &quot;&quot;&quot;

        EBr= np.abs(getattr(self.Br,typ))**2
        EBi= np.abs(getattr(self.Bi,typ))**2
        ECr= np.abs(getattr(self.Cr,typ))**2
        ECi= np.abs(getattr(self.Ci,typ))**2

        E = EBr + EBi + ECr + ECi

        #EBr = np.sum(np.abs(self.Br.s3) ** 2, axis=0)
        #EBi = np.sum(np.abs(self.Bi.s3) ** 2, axis=0)
        #ECr = np.sum(np.abs(self.Cr.s3) ** 2, axis=0)
        #ECi = np.sum(np.abs(self.Ci.s3) ** 2, axis=0)

        #E = EBr + EBi + ECr + ECi
        #u = np.argsort(E)
        #Es = E[u]

        return(E)</div>

<div class="viewcode-block" id="VSHCoeff.drag3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VSHCoeff.html#pylayers.antprop.spharm.VSHCoeff.drag3">[docs]</a>    def drag3(self, Emin):
        &quot;&quot;&quot; thresholded coefficient conversion

        Parameters
        ----------
        Emin : Minimum energy

        &quot;&quot;&quot;
        EBr = sum(abs(self.Br.s3) ** 2, axis=0)
        EBi = sum(abs(self.Bi.s3) ** 2, axis=0)
        ECr = sum(abs(self.Cr.s3) ** 2, axis=0)
        ECi = sum(abs(self.Ci.s3) ** 2, axis=0)
        E = EBr + EBi + ECr + ECi

        ind = find(E == Emin)

        ind3 = self.Br.ind3[ind]

        self.Br.delete3(ind)
        self.Bi.delete3(ind)
        self.Cr.delete3(ind)
        self.Ci.delete3(ind)

        return ind, ind3</div>

<div class="viewcode-block" id="VSHCoeff.put3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VSHCoeff.html#pylayers.antprop.spharm.VSHCoeff.put3">[docs]</a>    def put3(self, i, i3):
        &quot;&quot;&quot;  put 3

        Parameters
        ----------

        i : int
        i3 : int

        &quot;&quot;&quot;
        self.Br.put3(i, i3)
        self.Bi.put3(i, i3)
        self.Cr.put3(i, i3)
        self.Ci.put3(i, i3)</div></div>

<div class="viewcode-block" id="AFLegendre3"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.AFLegendre3.html#pylayers.antprop.spharm.AFLegendre3">[docs]</a>def AFLegendre3(L, M, x):
    &quot;&quot;&quot; calculate Pmm1l and Pmp1l

    Parameters
    ----------
        L : int
            max order  (theta)   (also called l or level )
        M : int
            max degree (phi)
        x : np.array
            function argument

    Returns
    -------

    Pmm1l : ndarray (Nx , L , M )
        :math:`\\bar{P}_{l}^{(m-1)}(x)`

    Pmp1l : ndarray (Nx , L , M )
        :math:`\\bar{P}_{l}^{(m+1)}(x)`

    Notes
    -----

    This function returns :
        .. math::

            \\bar{P}_{l}^{(m-1)}(x)

            \\bar{P}_{l}^{(m+1)}(x)

     Where

        .. math::

            P_l^{(m)}(x)= \\sqrt{ \\frac{2}{2 l+1} \\frac{(l+m)!}{(l-m)!} } \\bar{P}_{l}^{(m)}(x)

    Examples
    --------


    &gt;&gt;&gt; Pmm1l,Pmp1l = AFLegendre3(5,4,np.array([0,1]))

    Notes
    -----

    L has to be greater or equal than M

    See Also
    --------

    VW

    &quot;&quot;&quot;
    PML = []
    nx = len(x)

    if M &lt; L:
        MM = np.arange(M + 2).reshape(M+2,1,1)
        LL = np.arange(L + 1).reshape(1,L+1,1)
    else:
        MM = np.arange(M + 1).reshape(M+1,1,1)
        LL = np.arange(L + 1).reshape(1,L+1,1)

    x  = x.reshape(1,1,nx)

    #
    # Warning : this is a dangerous factorial ratio
    # surprinsingly it works well
    #
    C1 = np.sqrt((LL + 0.5) * factorial(LL - MM) / factorial(LL + MM))
    Pml = special.lpmv(MM,LL,x)*C1

    Pml = np.swapaxes(Pml,0,2)
    Pml = np.swapaxes(Pml,1,2)

    if M &lt; L:
        Pmp1l = Pml[:, 1::1, :]
    else:
        Pmp1l = np.zeros((nx, M + 1, L + 1))
        Pmp1l[:, 0:-1, :] = Pml[:, 1::1, :]

    Pmm1l = np.zeros((nx, M + 1, L + 1))
    if M &lt; L:
        Pmm1l[:, 1::1, :] = Pml[:, 0:-2, :]
    else:
        Pmm1l[:, 1::1, :] = Pml[:, 0:-1, :]
        Pmm1l[:, 0, :] = -Pml[:, 1, :]

    return Pmm1l, Pmp1l</div>

<div class="viewcode-block" id="AFLegendre2"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.AFLegendre2.html#pylayers.antprop.spharm.AFLegendre2">[docs]</a>def AFLegendre2(L, M, x):
    &quot;&quot;&quot; calculate Pmm1l and Pmp1l

    Parameters
    ----------
        L : int
            max order  (theta)   (also called l or level )
        M : int
            max degree (phi)
        x : np.array
            function argument

    Returns
    -------

    Pmm1l : ndarray (Nx , L , M )
        :math:`\\bar{P}_{l}^{(m-1)}(x)`

    Pmp1l : ndarray (Nx , L , M )
        :math:`\\bar{P}_{l}^{(m+1)}(x)`

    Notes
    -----

    This function returns :
        .. math::

            \\bar{P}_{l}^{(m-1)}(x)

            \\bar{P}_{l}^{(m+1)}(x)

     Where

        .. math::

            P_l^{(m)}(x)= \\sqrt{ \\frac{2}{2 l+1} \\frac{(l+m)!}{(l-m)!} } \\bar{P}_{l}^{(m)}(x)

    Examples
    --------


    &gt;&gt;&gt; Pmm1l,Pmp1l = AFLegendre2(5,4,np.array([0,1]))

    Notes
    -----

    L has to be greater or equal than M

    See Also
    --------

    VW

    &quot;&quot;&quot;
    PML = []
    nx = len(x)
    if M &lt; L:
        MM = np.expand_dims(np.arange(M + 2),1)
        LL = np.expand_dims(np.arange(L + 1),0)
    else:
        MM = np.expand_dims(np.arange(M + 1),1)
        LL = np.expand_dims(np.arange(L + 1),0)
    #
    # Warning : this is a dangerous factorial ratio
    # surprinsingly it works well
    #
    C1 = np.sqrt((LL + 0.5) * factorial(LL - MM) / factorial(LL + MM))
    for i in range(nx):
        if M &lt; L:
            pml = special.lpmn(M + 1, L, x[i])[0]
        else:
            pml = special.lpmn(M, L, x[i])[0]
        pml = pml * C1
        PML.append(pml)

    Pml = np.array(PML)
    if M &lt; L:
        Pmp1l = Pml[:, 1::1, :]
    else:
        Pmp1l = np.zeros((nx, M + 1, L + 1))
        Pmp1l[:, 0:-1, :] = Pml[:, 1::1, :]

    Pmm1l = np.zeros((nx, M + 1, L + 1))
    if M &lt; L:
        Pmm1l[:, 1::1, :] = Pml[:, 0:-2, :]
    else:
        Pmm1l[:, 1::1, :] = Pml[:, 0:-1, :]
        Pmm1l[:, 0, :] = -Pml[:, 1, :]

    return Pmm1l, Pmp1l</div>

<div class="viewcode-block" id="AFLegendre"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.AFLegendre.html#pylayers.antprop.spharm.AFLegendre">[docs]</a>def AFLegendre(N, M, x):
    &quot;&quot;&quot; calculate Pmm1n and Pmp1n

    Parameters
    ----------

    N : int
        max order  (theta)   (also called l or level )
    M : int
        max degree (phi)
    x : np.array
            function argument

    Returns
    -------

    Pmm1l :  ndarray ( Ndir, M , L ) 

        :math:`\\bar{P}_{n}^{(m-1)}(x)`
    Pmp1l :  ndarray ( Ndir, M , L )
        :math:`\\bar{P}_{n}^{(m+1)}(x)`

    Notes
    -----

    This function returns :
        .. math::

            \\bar{P}_{l}^{(m-1)}(x)

            \\bar{P}_{l}^{(m+1)}(x)

     Where

        .. math::

            P_l^{(m)}(x)= \\sqrt{ \\frac{2}{2 l+1} \\frac{(l+m)!}{(l-m)!} } \\bar{P}_{l}^{(m)}(x)

    Examples
    --------

    &gt;&gt;&gt; Pmm1n,Pmp1n = AFLegendre(5,4,np.array([0,1]))

    See Also
    --------

    VW

    &quot;&quot;&quot;
    PMN = []
    nx = len(x)
    if M &lt; N:
        MM = np.outer(np.arange(M + 2), np.ones(N + 1))
        NN = np.outer(np.ones(M + 2), np.arange(N + 1))
    else:
        MM = np.outer(np.arange(M + 1), np.ones(N + 1))
        NN = np.outer(np.ones(M + 1), np.arange(N + 1))
    #
    # Warning : this is a dangerous factorial ratio
    # surprinsingly it works well
    #
    C1 = np.sqrt((NN + 0.5) * factorial(NN - MM) / factorial(NN + MM))
    del MM
    del NN
    for i in range(nx):
        if M &lt; N:
            pmn = special.lpmn(M + 1, N, x[i])[0]
        else:
            pmn = special.lpmn(M, N, x[i])[0]
        pmn = pmn * C1
        PMN.append(pmn)

    Pmn = np.array(PMN)
    if M &lt; N:
        Pmp1n = Pmn[:, 1::1, :]
    else:
        Pmp1n = np.zeros((nx, M + 1, N + 1))
        Pmp1n[:, 0:-1, :] = Pmn[:, 1::1, :]

    Pmm1n = np.zeros((nx, M + 1, N + 1))
    if M &lt; N:
        Pmm1n[:, 1::1, :] = Pmn[:, 0:-2, :]
    else:
        Pmm1n[:, 1::1, :] = Pmn[:, 0:-1, :]
        Pmm1n[:, 0, :] = -Pmn[:, 1, :]

    return Pmm1n, Pmp1n</div>

<div class="viewcode-block" id="VW2"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VW2.html#pylayers.antprop.spharm.VW2">[docs]</a>def VW2(l, m, x, phi, Pmm1l, Pmp1l):
    &quot;&quot;&quot; evaluate vector Spherical Harmonics basis functions

    Parameters
    ----------
    l    : ndarray (1 x K)
        level
    m    : ndarray (1 x K)
        mode
    x    :  ndarray (1 x Nray)

    phi   : np.array (1 x Nray)

    Pmm1l : Legendre Polynomial

    Pmp1l : Legendre Polynomial

    Returns
    -------

    V  : ndarray (Nray , L, M)
    W  : ndarray (Nray , L, M)

    See Also
    --------

    AFLegendre

    Nx x M x L

    Examples
    --------

    &quot;&quot;&quot;

    K   = len(l)
    Nr  = len(x)
    l   = l.reshape(1,K)
    m   = m.reshape(1,K)
    phi = phi.reshape(Nr,1)
    x   = x.reshape(Nr,1)

    t1 = np.sqrt((l + m) * (l - m + 1))
    t2 = np.sqrt((l - m) * (l + m + 1))

    Ephi = np.exp(1j*m*phi)

    Y1 = (t1 * Pmm1l[:,m,l] + t2 * Pmp1l[:,m,l]).reshape(Nr,K)
    Y2 = (t1 * Pmm1l[:,m,l] - t2 * Pmp1l[:,m,l]).reshape(Nr,K)

    W = Y1 * (-1.0) ** l / (2 * x * np.sqrt(l * (l + 1))) * Ephi
    W[np.isinf(W) | np.isnan(W)] = 0
    V = Y2 * (-1.0) ** l / (2 * np.sqrt(l * (l + 1))) * Ephi
    V[np.isinf(V) | np.isnan(V)] = 0
    return V, W</div>

<div class="viewcode-block" id="VW"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VW.html#pylayers.antprop.spharm.VW">[docs]</a>def VW(l, m, theta ,phi):
    &quot;&quot;&quot; evaluate vector Spherical Harmonics basis functions

    Parameters
    ----------

    l    : ndarray (1 x K)
        level
    m    : ndarray (1 x K)
        mode
    theta : np.array (1 x Nray)

    phi   : np.array (1 x Nray)


    Returns
    -------

    V  : ndarray (Nray , L, M)
    W  : ndarray (Nray , L, M)

    See Also
    --------

    AFLegendre

    Nray x M x L

    Examples
    --------


    &quot;&quot;&quot;

    if (type(l) == float) or (type(l)==int):
        l = np.array([l])
    if (type(m) == float) or (type(m)==int):
        m = np.array([m])

    assert(l.shape==m.shape)
    assert(theta.shape==phi.shape)

    L = np.max(l)
    M = np.max(m)

    # dirty fix
    index = np.where(abs(theta-np.pi/2)&lt;1e-5)[0]
    if len(index)&gt;0:
        theta[index]=np.pi/2-0.01
    x = -np.cos(theta)

    # The - sign is necessary to get the good reconstruction
    #     deduced from observation
    #     May be it comes from a different definition of theta in SPHEREPACK

    #Pmm1l, Pmp1l = AFLegendre(L, M, x)

    Pmm1l, Pmp1l = AFLegendre(L, L, x)

    K   = len(l)
    Nr  = len(x)

    l   = l.reshape(1,K)
    m   = m.reshape(1,K)
    phi = phi.reshape(Nr,1)
    x   = x.reshape(Nr,1)

    t1 = np.sqrt((l + m) * (l - m + 1))
    t2 = np.sqrt((l - m) * (l + m + 1))

    Ephi = np.exp(1j*m*phi)

    Y1 = (t1 * Pmm1l[:,m,l] + t2 * Pmp1l[:,m,l]).reshape(Nr,K)
    Y2 = (t1 * Pmm1l[:,m,l] - t2 * Pmp1l[:,m,l]).reshape(Nr,K)

    T =  (-1.0) ** l / (2 * np.sqrt(l * (l + 1))) * Ephi
    #W = Y1 * (-1.0) ** l / (2 * x * np.sqrt(l * (l + 1))) * Ephi
    #V = Y2 * (-1.0) ** l / (2 * np.sqrt(l * (l + 1))) * Ephi
    W = Y1 * T / x
    V = Y2 * T
    #
    # dirty fix
    #
    #W[np.isinf(W) | np.isnan(W)] = 0
    #V[np.isinf(V) | np.isnan(V)] = 0

    return V, W</div>

<div class="viewcode-block" id="VW0"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.VW0.html#pylayers.antprop.spharm.VW0">[docs]</a>def VW0(n, m, x, phi, Pmm1n, Pmp1n):
    &quot;&quot;&quot; evaluate vector Spherical Harmonics basis functions

    Parameters
    ----------
    n    : int
        level
    m    : int
        mode
    x    :  np.array
        function argument
    phi   : np.array
    Pmm1n : Legendre Polynomial
    Pmp1n : Legendre Polynomial


    Returns
    -------

    V
    W


    Examples
    --------

    &gt;&gt;&gt; from pylayers.antprop.antenna import *
    &gt;&gt;&gt; N = 2
    
    See Also
    --------

    AFLegendre


    &quot;&quot;&quot;
    t1 = np.outer(np.ones(len(x)), np.sqrt((n + m) * (n - m + 1)))
    t2 = np.outer(np.ones(len(x)), np.sqrt((n - m) * (n + m + 1)))
    Y1 = t1 * Pmm1n[:, m, n] + t2 * Pmp1n[:, m, n]
    Y2 = t1 * Pmm1n[:, m, n] - t2 * Pmp1n[:, m, n]

    Mphi = np.outer(phi, m)
    Ephi = np.exp(1j * Mphi)
    del Mphi
    Y1 = t1 * Pmm1n[:, m, n] + t2 * Pmp1n[:, m, n]
    Y2 = t1 * Pmm1n[:, m, n] - t2 * Pmp1n[:, m, n]
    del t1
    del t2
    W = Y1 * np.outer(1.0 / x, (-1.0) ** n / (2 * np.sqrt(n * (n + 1)))) * Ephi
    #W[np.isinf(W) | np.isnan(W)] = 0
    del Y1
    V = Y2 * np.outer( np.ones(len(x)), (-1.0) ** n / (2 * np.sqrt(n * (n + 1)))) * Ephi
    #V[np.isinf(V) | np.isnan(V)] = 0
    del Y2
    return V, W</div>

<div class="viewcode-block" id="plotVW"><a class="viewcode-back" href="../../../api/pylayers.antprop.spharm.plotVW.html#pylayers.antprop.spharm.plotVW">[docs]</a>def plotVW(l, m, theta, phi, sf=False):
    &quot;&quot;&quot; plot VSH transform vsh basis in 3D plot

        (V in fig1 and W in fig2)

    Parameters
    ----------

    n,m   : integer values (m&lt;=n)
    theta : ndarray
    phi   : ndarray
    sf    : boolean
        if sf : plotted figures are saved in a *.png file
        else  : plotted figures aren&#39;t saved

    Examples
    --------

    .. plot::
        :include-source:

        &gt;&gt;&gt; from pylayers.antprop.spharm import *
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; n=5
        &gt;&gt;&gt; m=3
        &gt;&gt;&gt; theta = np.linspace(0,np.pi,30)
        &gt;&gt;&gt; phi   = np.linspace(0,2*np.pi,60)
        &gt;&gt;&gt; plotVW(n,m,theta,phi)
        &gt;&gt;&gt; plt.show()

    &quot;&quot;&quot;
    # calculate v and w
    if m &lt;= l:
        theta[np.where(theta == np.pi / 2)[0]] = np.pi / 2 +  1e-10  # .. todo :: not clean
        x = -np.cos(theta)

        Pmm1l, Pmp1l = AFLegendre(l, m, x)

        t1 = np.sqrt((l + m) * (l - m + 1))
        t2 = np.sqrt((l - m) * (l + m + 1))
        y1 = t1 * Pmm1l[:, m, l] - t2 * Pmp1l[:, m, l]
        y2 = t1 * Pmm1l[:, m, l] + t2 * Pmp1l[:, m, l]

        Ephi = np.exp(1j * m * phi)
        cphi = np.cos(m * phi)
        if m == 0:
            sphi = 1e-10
        else:
            sphi = np.sin(m * phi)

        ny = len(y1)
        ne = len(Ephi)
        vy = np.ones(ny)
        ve = np.ones(ne)
        Y1 = np.outer(y1, ve)
        Y2 = np.outer(y2, ve)
        EPh = np.outer(vy, Ephi)

        const = (-1.0) ** l / (2 * np.sqrt(l * (l + 1)))
        V = const * Y1 * EPh
        #V[np.isinf(V)|isnan(V)]=0
        Vcos = cphi * V
        Vsin = sphi * V

        if m == 0:
            #W=np.zeros((len(theta),len(phi)))
            W = np.ones((len(theta), len(phi))) * 1e-10
        else:
            Waux = Y2 * EPh
            x1 = 1.0 / x
            W = np.outer(x1, const) * Waux

        Wcos = cphi * W
        Wsin = sphi * W

        #figdirV=&#39;/home/rburghel/Bureau/bases_decomposition_VW/base_V_Vsin_Vcos/&#39;
        figdirV = &#39;./&#39;
        ext1 = &#39;.pdf&#39;
        ext2 = &#39;.eps&#39;
        ext3 = &#39;.png&#39;
        slm = &#39; l = &#39;+str(l)+&#39; m = &#39;+str(m)
        #fig1 = plt.figure()
        #pol3D(fig1,abs(V),theta,phi,title=&#39;$|V|$&#39;+slm)
        #fig2 = plt.figure()
        #pol3D(fig2,abs(Vcos),theta,phi,title=&#39;$\Re V$&#39;+slm)
        #fig3 = plt.figure()
        #pol3D(fig3,abs(Vsin),theta,phi,title=&#39;$\Im V$&#39;+slm)
        #fig4 = plt.figure()
        #pol3D(fig4,abs(W),theta,phi,title=&#39;$|W|$&#39;+slm)
        #fig5 = plt.figure()
        #pol3D(fig5,abs(Wcos),theta,phi,title=&#39;$\Re W&#39;+slm)
        #fig6 = plt.figure()
        #pol3D(fig6,abs(Wsin),theta,phi,title=&#39;$\Im W$&#39;+slm)
        #plt.show()

    else:
        print(&quot;Error: m&gt;n!!!&quot;)
    return(V,W)</div>

if (__name__ == &quot;__main__&quot;):
    doctest.testmod()
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team.
      Last updated on Feb 01, 2019.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>